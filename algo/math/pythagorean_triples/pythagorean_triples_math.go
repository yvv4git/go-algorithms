package main

import "fmt"

/*
Математический подход к генерации пифагоровых троек.
Используем формулы для примитивных троек: a = m^2 - n^2, b = 2*m*n, c = m^2 + n^2,
где m > n > 0, gcd(m,n)=1, m-n нечетное.
Затем генерируем кратные: k*a, k*b, k*c для k >=1.

Временная сложность: O(n), поскольку количество троек пропорционально n.
Пространственная сложность: O(1), используем только константное количество переменных.
Почему: генерируем только валидные тройки с помощью формул, без перебора всех пар, что эффективнее для больших n.
*/

func main() {
	// Устанавливаем примерное значение n
	n := 10
	// Вызываем функцию для подсчета троек
	result := countPythagoreanTriplesMath(n)
	// Выводим результат
	fmt.Printf("Количество пифагоровых троек до %d (математический подход): %d\n", n, result)
}

// Функция для вычисления НОД (наибольшего общего делителя)
func gcd(a, b int) int {
	for b != 0 {
		a, b = b, a%b
	}

	return a
}

// Функция для подсчета количества пифагоровых троек с использованием математической генерации
// n - верхняя граница для чисел a, b, c (1 <= a < b < c <= n)
func countPythagoreanTriplesMath(n int) int {
	count := 0
	// Перебираем m начиная с 2
	for m := 2; ; m++ {
		found := false
		// Перебираем nn от 1 до m-1
		for nn := 1; nn < m; nn++ {
			// Проверяем условия: НОД(m, nn) == 1 и m-nn нечетное
			if gcd(m, nn) == 1 && (m-nn)%2 == 1 {
				// Вычисляем примитивную тройку
				a := m*m - nn*nn
				b := 2 * m * nn
				c := m*m + nn*nn
				// Если c > n, пропускаем
				if c > n {
					continue
				}
				found = true
				// Генерируем все кратные тройки
				for k := 1; ; k++ {
					ka := k * a
					kb := k * b
					kc := k * c
					// Если любое значение превышает n, прекращаем
					if ka > n || kb > n || kc > n {
						break
					}
					count++
				}
			}
		}
		// Если для этого m не нашли ни одной тройки с c <= n, прекращаем
		if !found && m*m+(m-1)*(m-1) > n {
			break
		}
	}
	return count
}
