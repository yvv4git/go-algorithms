# Heap Sort


## Info
Сортировка кучей (пирамидальная сортировка) - это алгоритм сортировки, 
основанный на сравнении элементов и использующий структуру данных "двоичная куча". 
Этот алгоритм особенно полезен, когда требуется сортировка с постоянным использованием памяти, 
но обычно не применяется, если важна устойчивость сортировки.

За счет того, что данные можно хранить в массиве, структура данных очень мало потребляет памяти.


## Основные характеристики:
- **Временная сложность**: O(n log n) во всех случаях
- **Пространственная сложность**: O(1) - сортировка на месте
- **Устойчивость**: Неустойчивая


## Свойства
- **Алгоритмическая парадигма**: Сравнительная сортировка
- **Тип данных**: Работает с массивами произвольного типа, поддерживающего сравнение
- **Рекурсия**: Не использует рекурсию, реализуется итеративно
- **Адаптивность**: Не адаптивный (производительность не улучшается на частично отсортированных данных)
- **Параллелизация**: Сложно поддается эффективному распараллеливанию
- **Кэш-эффективность**: Низкая из-за непоследовательного доступа к памяти


## Принцип работы
1. Построение max-кучи из входных данных
2. Последовательное извлечение максимального элемента из кучи и его размещение в конце массива
3. Перестроение кучи с оставшимися элементами


## Когда и где использовать?
- **Приоритетные очереди**: Часто используется для реализации очередей с приоритетом
- **Встроенные сортировки**: Некоторые языки используют вариации heap sort для встроенных функций сортировки
- **Ограниченная память**: Идеален для систем с ограниченной памятью благодаря сортировке на месте
- **Худший случай**: Гарантированная O(n log n) сложность делает его предсказуемым для чувствительных ко времени систем
- **Не рекомендуется**:
  - Когда важна устойчивость сортировки
  - Для почти отсортированных данных (лучше использовать insertion sort)
  - Когда важна скорость на небольших массивах






## Просеивание
Просеивание (sift down) - ключевая операция в алгоритме сортировки кучей, которая восстанавливает свойства кучи.

**Алгоритм просеивания вниз**:
1. Начинаем с указанного узла
2. Сравниваем его с дочерними элементами
3. Если какой-то дочерний элемент больше (для max-кучи), меняем их местами
4. Повторяем процесс для нового положения элемента
5. Заканчиваем, когда элемент больше своих потомков или достигнут конец кучи

**Сложность**: O(log n) для одного просеивания

**Визуализация**:
```
       16
     /    \
    4      10
   / \    /
 14   2  8

После просеивания 4:
       16
     /    \
    14     10
   / \    /
 4   2  8
```


## Позиция элемента в массиве
- Для элемента с индексом 1 (значение 14):
  - Родитель: (1-1)//2 = 0 (значение 16)
  - Левый потомок: 2*1+1 = 3 (значение 4)
  - Правый потомок: 2*1+2 = 4 (значение 2)
