# Quick sort
Быстрая сортировка - лучший алгоритм сортировки для большинства задач. 
Но с некотором, но. А именно, среди алгоритмов сравнения.

## Классификация
Алгоритм по своей природе является рекурсивным.


## Тезисно
- Алгоритм сортирует кусок массива с индексами от L до R включительно.
- У алгоритма есть база рекурсии, без этого нельзя. Так как выйдем за пределы массива.

## Описание
1. Выбирается опорный элемент B с индексом $(L + R) / 2$ .
2. Кусок разбивается на 2 части, состоящие из элементов, которые >= и <= опорному.
3. Затем, для каждой из частей запускается эта же функция рекурсивно, но с новыми L, R.
4. Кусочки будут постепенно уменьшаться, пока мы не дойдем до базы рекурсии.

Основная идея - берем опорную точку (pivot), проходим массив, чтобы элементы, которые меньше опорной точки оказались слева от нее, а которые больше - справа.  
Дальше берем часть массива до опорной точки и вторую часть после опортной точки,  повторяем на них сортировку.   
Продолжаем до того момента, как сортируемая часть массива будет пустой или состоять из одного элемента.


## Оценка времени работы
Зависит от того, на сколько удачно удалось разбить массив на 2 части.
В идеале должно разделиться на 2 одинаковые части.
$g(n) = n + 2(n/2) + 4(n/4) + ... + n(n/n) = n log_2 n$
Раз: $g(n) <= n log_2 n $ 
Выходит: $g(n) \in O(n log_2 n)$
Это очень хороший показатель для алгоритмов сортировки.

## Почему O(n log(n))
Дело в том, что алгоритм рукурсивный и на каждом уровне стека он проиходится по n элементам.  
При этом, каждый уровень это $O(log_n)$.
Получается, что всего $O(n \log{n})$


## Ньюансы
Если разбиение происходит не ровно пополам, то количество уровней начинает
увеличиваться. 
В лучшем случае: $O(n log_2 n)$
В худшем случае: $O(n^2)$
В среднем случае: $O(n log_2 n)$