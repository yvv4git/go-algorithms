package main

import (
	"fmt"
	"math"
	"sort"
)

// BucketSort выполняет блочную сортировку для массива с числами от 0 до 1.
//
// Временная сложность: O(n + k), где k — количество ведёрок.
// n — количество элементов в сортируемом массиве.
// k — количество ведер (buckets), которые создаются для распределения элементов (часто k = n, но это не обязательно).
//
// Пространственная сложность: O(n + k) — на ведра и результат.
//
// Все значения находятся в диапазоне от 0 (включительно) до 1 (исключая 1): [0.0, 1.0).
// Количество ведер равно n, то есть столько же, сколько элементов в массиве.
// Умножаем значение на количество ведер. Это превращает диапазон [0, 1) в диапазон [0, n):
// Например, при n = 10:
// - 0.12 * 10 = 1.2
// - 0.78 * 10 = 7.8
// - 0.99 * 10 = 9.9
//
// Округляем вниз до целого числа — получаем индекс ведра:
// - math.Floor(1.2) = 1
// - math.Floor(7.8) = 7
// - math.Floor(9.9) = 9
// Таким образом, каждый элемент равномерно распределяется по ведрам, в зависимости от того, насколько он близок к 0 или к 1.
func BucketSort(arr []float64) []float64 {
	n := len(arr)
	if n <= 0 {
		return arr
	}

	// Создаём n пустых "ведёрок" (слайсов)
	buckets := make([][]float64, n)

	// Распределяем элементы по ведёркам
	for _, value := range arr {
		// Индекс ведра вычисляется по формуле
		index := int(math.Floor(value * float64(n)))
		if index == n {
			index = n - 1 // Для случая, когда value == 1.0
		}
		buckets[index] = append(buckets[index], value)
	}

	// Сортируем отдельные ведра
	for i := 0; i < n; i++ {
		sort.Float64s(buckets[i]) // можно использовать любую сортировку
	}

	// Собираем отсортированный результат
	result := make([]float64, 0, n)
	for i := 0; i < n; i++ {
		result = append(result, buckets[i]...)
	}

	return result
}

func main() {
	// Пример входных данных (должны быть от 0.0 до 1.0 для корректности)
	data := []float64{0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68}
	fmt.Println("До сортировки:", data)

	sorted := BucketSort(data)
	fmt.Println("После сортировки:", sorted)
}
