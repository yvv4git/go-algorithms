# Блочная сортировка (Bucket Sort)


## Описание
Блочная сортировка (Bucket Sort) — это алгоритм сортировки, который распределяет элементы входного массива по "ведрам" (блокам), после чего каждый блок сортируется отдельно (обычно другим алгоритмом сортировки, например, сортировкой вставками). Затем отсортированные блоки объединяются в итоговый отсортированный массив.

Блочная сортировка эффективна, когда входные данные равномерно распределены по диапазону, так как в этом случае элементы равномерно распределяются по ведрам, что минимизирует время сортировки внутри каждого блока.

### Принцип работы
1. Создается массив пустых "ведер" (блоков).
2. Распределение элементов: каждый элемент исходного массива помещается в соответствующее ведро на основе определенного критерия (например, диапазона значений).
3. Сортировка ведер: каждый непустой блок сортируется отдельно (часто используется сортировка вставками).
4. Объединение: элементы из всех ведер собираются в исходный массив в порядке возрастания.


## Время работы
- **Лучший случай**: O(n + k), когда элементы равномерно распределены по ведрам, и сортировка внутри каждого ведра занимает O(1).
- **Средний случай**: O(n + n²/k + k), где k — количество ведер. Если k ≈ n, то сложность стремится к O(n).
- **Худший случай**: O(n²), когда все элементы попадают в одно ведро, и внутри него применяется квадратичный алгоритм сортировки (например, сортировка вставками).


## Пространственная сложность
- **Пространственная сложность**: O(n + k), так как требуется дополнительная память для хранения ведер и их содержимого.


## Псевдокод
1. Создать массив из k пустых ведер (блоков).
2. Для каждого элемента в исходном массиве:
   - Определить индекс ведра, в которое он должен попасть.
   - Добавить элемент в соответствующее ведро.
3. Для каждого непустого ведра:
   - Отсортировать элементы внутри (например, сортировкой вставками).
4. Объединить элементы всех ведер в исходный массив в порядке возрастания.



## Пример
Допустим, у нас есть массив чисел: `[0.42, 0.32, 0.75, 0.12, 0.89]`, и мы используем 5 ведер для диапазона [0, 1).

Шаги алгоритма:
1. Распределение по ведрам:
   - Ведро 0 (0.0–0.2): `[0.12]`
   - Ведро 1 (0.2–0.4): `[0.32, 0.42]`
   - Ведро 2 (0.4–0.6): `[]`
   - Ведро 3 (0.6–0.8): `[0.75]`
   - Ведро 4 (0.8–1.0): `[0.89]`
2. Сортировка внутри ведер (если требуется):
   - Ведро 1 после сортировки: `[0.32, 0.42]` (уже отсортировано)
3. Объединение: `[0.12, 0.32, 0.42, 0.75, 0.89]`


## Плюсы
- Эффективен при равномерном распределении данных.
- В среднем случае работает за линейное время O(n).
- Хорошо подходит для сортировки чисел с плавающей точкой в ограниченном диапазоне.



## Минусы
- Неэффективен, если данные неравномерно распределены (может выродиться в O(n²)).
- Требует дополнительной памяти для хранения ведер.
- Не подходит для данных с большим разбросом значений, так как требует большого количества ведер.


## Оценка сложности алгоритма
Если данные распределены равномерно, то:
- Распределение по ведрам: O(n)
- Сортировка внутри каждого ведра: O(k * (n/k)^2) = O(n^2/k) (если используется сортировка вставками)
- Объединение: O(k)

Итоговая сложность:  
O(n + n^2/k + k)  

Если k ≈ n, то:  
O(n + n + n) = O(n)  

В худшем случае (все элементы в одном ведре):  
O(n^2)  