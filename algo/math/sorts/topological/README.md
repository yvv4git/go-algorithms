# Topological sort


## Info
Топологическая сортировка — это линейное упорядочивание вершин ориентированного ациклического графа (DAG — Directed Acyclic Graph), 
такое, что для каждого ребра (u, v) вершина u предшествует вершине v в упорядочении. 
Топологическая сортировка применяется, например, в задачах планирования, где нужно определить порядок выполнения задач с учетом их зависимостей.

Алгоритм топологической сортировки работает с DAG (прямой ациклический граф). 
Смысл топологической сортировки в том, что если какой-либо узел указывает на другой узел, то после него будет идти узел, указывающий на другой узел. 
Таким образом, в этом случае, если у нас есть циклический граф, мы не можем предсказать, какой узел после какого узла. 
Вот почему алгоритм топологической сортировки работает только с ациклическим графом, а не с циклическим графом.


## Подходы реализации
Существует несколько подходов к реализации топологической сортировки. 
- Один из наиболее распространенных — использование обхода в глубину (DFS).
- Использовать алгоритм Кана(Kahn's Algritm.)


## Сложность
- Time Complexity
Это связано с тем, что алгоритм посещает каждую вершину и ребро ровно один раз.
V — количество вершин (nodes).
E — количество ребер (edges).

- Space Complexity
O(V), где V — количество вершин.
Это связано с необходимостью хранить вспомогательные структуры данных, 
такие как стек или очередь, а также результат (отсортированный список вершин).


## Решение - алгоритм DFS
1. Инициализация:
1.1. Создается массив visited, чтобы отслеживать посещенные вершины.
1.2. Создается стек stack, в который будут добавляться вершины после завершения их обработки.

2. Обход в глубину (DFS):
2.1. Для каждой вершины, если она не посещена, вызывается рекурсивная функция dfs.
2.2. Внутри dfs:
2.2.1. Вершина отмечается как посещенная.
2.2.2. Рекурсивно вызывается dfs для всех соседей вершины.
2.2.3. После обработки всех соседей вершина добавляется в стек.

3. Получение результата:
3.1. После завершения обхода всех вершин, результат топологической сортировки — это стек в обратном порядке.



## Решение - алгоримт Кана
Кроме алгоритма топологической сортировки с использованием DFS, 
существует еще один популярный метод — алгоритм Кана (Kahn's Algorithm), 
который основан на использовании входящих степеней вершин. 
Этот алгоритм также работает с ориентированным ациклическим графом (DAG) и имеет временную сложность O(V + E).

1. Инициализация:
1.1. Создается массив inDegree, чтобы хранить количество входящих ребер для каждой вершины.
1.2. Создается очередь queue, в которую будут добавляться вершины с входящей степенью 0.
1.3. Создается массив result, в который будет записываться результат топологической сортировки.

2. Подготовка:
2.1. Вычисляется входящая степень для каждой вершины:

Для каждого ребра (u, v) увеличивается значение inDegree[v].
2.2. Добавляются в очередь все вершины, у которых входящая степень равна 0.

3. Обработка очереди:
3.1. Пока очередь не пуста:
3.1.1. Извлекается вершина u из очереди.
3.1.2. Вершина u добавляется в массив result.
3.1.3. Для каждого соседа v вершины u:
- Уменьшается входящая степень inDegree[v].
- Если inDegree[v] становится 0, вершина v добавляется в очередь.

4. Получение результата:
4.1. Если количество вершин в массиве result равно общему количеству вершин, то результат — это массив result.
4.2. Если количество вершин в массиве result меньше общего количества вершин, то граф содержит цикл, и топологическая сортировка невозможна.