# Сортировка пузырьком (Bubble Sort)

## Описание

Сортировка пузырьком (Bubble Sort) — это простой алгоритм сортировки, который многократно проходит по списку, сравнивает соседние элементы и меняет их местами, если они идут в неправильном порядке. Процесс повторяется, пока весь список не станет отсортированным.

Сортировка пузырьком — это базовый и интуитивно понятный алгоритм сортировки, но его высокая сложность делает его неэффективным для работы с большими объемами данных. Тем не менее, благодаря простоте реализации, он может быть полезен в учебных целях и в случае сортировки небольших массивов.


### Принцип работы

1. Алгоритм начинает с первого элемента и сравнивает его с последующим.
2. Если текущий элемент больше следующего, они меняются местами.
3. После одного прохода наибольший элемент окажется в конце списка.
4. Алгоритм повторяет эти шаги для оставшейся части списка, игнорируя последний отсортированный элемент.
5. Процесс продолжается до тех пор, пока не будет выполнен еще один проход без обменов элементов.

## Время работы

- **Лучший случай**: O(n), когда список уже отсортирован (алгоритм обнаружит, что обменов не требуется).
- **Средний и худший случаи**: O(n^2), так как каждый элемент может быть сравнен с каждым другим элементом в списке.

## Пространственная сложность

- **Пространственная сложность**: O(1), так как алгоритм сортирует элементы на месте, не требуя дополнительной памяти.

## Псевдокод

1. Для i от 0 до n-1:
   - Для j от 0 до n-i-1:
     - Если list[j] > list[j+1], то:
       - Поменять местами list[j] и list[j+1]

## Пример

Допустим, у нас есть массив чисел: `[5, 3, 8, 4, 2]`

Шаги алгоритма:
1. Сравниваем 5 и 3, меняем местами -> `[3, 5, 8, 4, 2]`
2. Сравниваем 5 и 8, не меняем местами -> `[3, 5, 8, 4, 2]`
3. Сравниваем 8 и 4, меняем местами -> `[3, 5, 4, 8, 2]`
4. Сравниваем 8 и 2, меняем местами -> `[3, 5, 4, 2, 8]`

Теперь повторяем шаги для оставшейся части списка `[3, 5, 4, 2]` и продолжаем процесс до полной сортировки.

## Плюсы

- Простота реализации и понимания.
- Хорошо работает на малых объемах данных.
  
## Минусы

- Низкая эффективность для больших массивов из-за квадратичной сложности.
- Часто требует множество сравнений и обменов, что делает его медленным по сравнению с другими алгоритмами сортировки, такими как QuickSort или MergeSort.



## Оценка сложности алгоритма
$g(n) = 1+2+...+(n-2)+(n-1) = n(n-1)/2 <= n^2 / 2$  
А значит: $g(n) <= n^2$  
Из этого следует: $g(n) \in O(n^2)$  
Результат: O(n^2)  