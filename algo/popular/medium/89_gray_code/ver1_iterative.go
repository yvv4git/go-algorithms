package main

import (
	"fmt"
	"math"
)

// Функция для генерации серийного кода Грея
func grayCode(n int) []int {
	/*
		METHOD: Iterative
		TIME COMPLEXITY: O(2^n), где n - количество битов в коде Грея. Это связано с тем, что мы генерируем каждый следующий элемент кода Грея, используя предыдущий.
		SPACE COMPLEXITY: O(2^n), так как мы храним все элементы кода Грея в результирующем срезе.
	*/
	// Проверка на корректность входных данных
	if n < 1 {
		return []int{}
	}

	// Инициализация результирующего среза.
	// Количество элементов в коде Грея равно 2^n, поэтому длина среза должна быть равна этому количеству.
	result := make([]int, int(math.Pow(2, float64(n))))

	// Инициализация первого элемента.
	// Первый элемент в серийном коде Грея всегда равен 0, потому что код Грея основан на принципе,
	// что любые два соседних числа отличаются ровно одним битом.
	// Первый элемент — это единственный число, которое не имеет предыдущего соседа, поэтому он всегда равен 0.
	// Вот пример, как это работает для двух битов:
	// 00 - 0
	// 01 - 1
	// 11 - 3
	// 10 - 2
	// Все числа отличаются ровно одним битом от предыдущего, кроме первого, который всегда равен 0.
	result[0] = 0

	// Генерация остальных элементов.
	for i := 1; i <= n; i++ {
		prevLen := int(math.Pow(2, float64(i-1)))
		for j := prevLen - 1; j >= 0; j-- {
			result[2*prevLen-j-1] = result[j] | prevLen
		}
	}

	return result
}

func main() {
	// Пример использования
	n := 3
	fmt.Println(grayCode(n))
}
