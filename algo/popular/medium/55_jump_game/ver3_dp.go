package main

func canJumpV3(nums []int) bool {
	/*
		METHOD: Dynamic programming

		TIME COMPLEXITY: O(n^2), так как для каждого индекса мы можем проверять до n других индексов.

		SPACE COMPLEXITY: O(n), так как мы используем дополнительный массив dp длиной n.
	*/
	n := len(nums)
	// Создаем массив dp, где dp[i] будет true, если мы можем достичь последнего индекса из индекса i.
	dp := make([]bool, n)
	// Изначально устанавливаем dp[n-1] в true, так как последний индекс достижим сам из себя.
	dp[n-1] = true

	// Начинаем обход с предпоследнего индекса и идем к началу массива.
	for i := n - 2; i >= 0; i-- {
		// Проверяем, можем ли мы достичь любого индекса, который уже помечен как достижимый.
		for j := 1; j <= nums[i] && i+j < n; j++ {
			if dp[i+j] {
				dp[i] = true
				break
			}
		}
	}

	// Результат будет в dp[0], так как нас интересует, можем ли мы достичь последнего индекса из начального.
	return dp[0]
}

//func main() {
//	fmt.Println(canJumpV3([]int{2, 3, 1, 1, 4})) // true
//	fmt.Println(canJumpV3([]int{3, 2, 1, 0, 4})) // false
//}
