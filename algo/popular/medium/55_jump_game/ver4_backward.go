package main

func canJumpV4(nums []int) bool {
	/*
		METHOD: Backwards Approach
		Подход, используемый в данном коде, можно назвать "обратным динамическим программированием" или "обратным жадным алгоритмом".
		Этот метод заключается в том, что мы начинаем с конца массива и постепенно движемся к началу, накапливая информацию о том,
		сколько шагов необходимо для достижения конца массива из каждой позиции.
		Это позволяет нам эффективно определить, можем ли мы достичь конца массива из начальной позиции.

		TIME COMPLEXITY: O(n), где n — длина массива nums.
		Это связано с тем, что мы проходим по массиву один раз, начиная с предпоследнего элемента и двигаясь к началу.

		SPACE COMPLEXITY: O(1), так как мы используем только одну дополнительную переменную needs для хранения количества шагов,
		необходимых для достижения конца массива. Никаких дополнительных структур данных или массивов не используется.
	*/
	// Если длина массива меньше или равна 1, то мы уже находимся в конце массива.
	if len(nums) <= 1 {
		return true
	}

	// Переменная needs будет хранить количество шагов, необходимых для достижения конца массива.
	// Начинаем с 1, так как нам нужно хотя бы один шаг, чтобы достичь последнего элемента.
	needs := 1

	// Начинаем обход массива с предпоследнего элемента и идем к началу массива.
	for i := len(nums) - 2; i > 0; i-- {
		// Если текущий элемент nums[i] больше или равен needs,
		// это означает, что мы можем достичь конца массива из этого элемента.
		// Поэтому сбрасываем needs обратно к 1.
		if nums[i] >= needs {
			needs = 1
			continue
		}
		// Если текущий элемент nums[i] меньше needs,
		// увеличиваем needs на 1, так как нам нужен еще один шаг, чтобы достичь конца массива.
		needs++
	}

	// Проверяем, можем ли мы достичь конца массива из первого элемента.
	// Если nums[0] больше или равен needs, то возвращаем true, иначе false.
	return nums[0] >= needs
}
