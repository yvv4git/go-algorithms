package main

import "fmt"

func jump(nums []int) int {
	/*
		METHOD: Dynamic programming
		Используется жадный алгоритм (Greedy Algorithm).
		На каждом шаге мы выбираем интервал, который позволяет нам достичь максимальной дальней позиции.
		Этот подход гарантирует, что мы найдем минимальное количество прыжков, необходимых для достижения последнего элемента.

		TIME COMPLEXITY: O(n), где n — длина массива nums. Мы проходим по массиву один раз.

		SPACE COMPLEXITY: O(1). Мы используем только константное количество дополнительной памяти.
	*/
	n := len(nums)
	if n == 1 {
		return 0
	}

	jumps := 0      // количество прыжков
	currentEnd := 0 // хранит текущий конец интервала, который мы можем достичь с текущего прыжка
	farthest := 0   // хранит самую дальнюю позицию, до которой мы можем допрыгнуть на текущем шаге

	for i := 0; i < n-1; i++ {
		// Находим максимальную позицию, до которой можно допрыгнуть из текущей позиции
		if i+nums[i] > farthest {
			farthest = i + nums[i]
		}

		// Если достигли конца текущего прыжка, обновляем количество прыжков и текущий конец
		if i == currentEnd {
			jumps++
			currentEnd = farthest
		}
	}

	return jumps
}

func main() {
	nums := []int{2, 3, 1, 1, 4}
	fmt.Println(jump(nums)) // Вывод: 2
}
