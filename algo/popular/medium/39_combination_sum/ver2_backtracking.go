package main

func combinationSumV2(candidates []int, target int) [][]int {
	/*
		METHOD: Backtracking
		TIME COMPLEXITY: O(N^T), где N - количество кандидатов, T - целевая сумма.
		Это связано с тем, что для каждого кандидата мы можем выбирать его несколько раз, пока сумма не превысит целевую.
		SPACE COMPLEXITY: O(T), так как в худшем случае глубина рекурсии может быть равна T,
		и для каждого уровня рекурсии мы храним текущий список чисел.

		Временная сложность
		Временная сложность O(N^T) обусловлена тем, что для каждого числа из кандидатов мы можем выбирать его несколько раз,
		пока сумма не превысит целевую. Это означает, что в худшем случае мы можем иметь дело с экспоненциальной сложностью,
		так как для каждого числа из кандидатов мы можем выбирать его или не выбирать, что дает нам 2^T операций, где T - целевая сумма.

		Пространственная сложность
		Пространственная сложность O(T) обусловлена тем, что в худшем случае глубина рекурсии может быть равна T,
		и для каждого уровня рекурсии мы храним текущий список чисел.
		Это означает, что в худшем случае мы можем иметь дело с линейной сложностью памяти,
		так как для каждого числа из кандидатов мы можем выбирать его или не выбирать, что дает нам T уровней рекурсии.
	*/
	res := make([][]int, 0)
	sub := make([]int, 0)

	helper(&res, sub, target, candidates, 0)
	return res
}

func helper(res *[][]int, sub []int, target int, candidates []int, index int) {
	sum := 0
	for _, num := range sub {
		sum += num
	}
	if sum == target {
		*res = append(*res, append([]int{}, sub...))
		return
	}
	if sum > target {
		return
	}

	for i := index; i < len(candidates); i++ {
		sub = append(sub, candidates[i])
		helper(res, sub, target, candidates, i)
		sub = sub[:len(sub)-1]
	}
}
