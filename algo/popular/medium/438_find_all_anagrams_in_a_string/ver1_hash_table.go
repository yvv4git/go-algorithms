package main

import "fmt"

// Функция для поиска всех анаграмм в строке
func findAnagrams(s string, p string) []int {
	/*
		METHOD: Hash table
		TIME COMPLEXITY: O(n), где n - длина строки s, так как мы проходим по строке s только один раз.
		SPACE COMPLEXITY: O(1), так как используется фиксированное количество памяти для хранения счетчиков и результата, независимо от размера входных данных.

		Для решения этой задачи, можно использовать словарь (или хеш-таблицу) для отслеживания количества вхождений каждого символа в строке p (которая является искомой анаграммой)
		и словарь для отслеживания количества вхождений символов в текущем окне строки s.

		Алгоритм следующий:
		1. Инициализируем два словаря для отслеживания количества вхождений символов в p и в текущем окне s.
		2. Проходим по строке s, используя два указателя: left и right. left указывает на начало окна, а right - на конец окна.
		3. Для каждого символа в строке s, увеличиваем счетчик в словаре для окна sCount.
		4. Если размер окна s[left:right] больше размера строки p, уменьшаем счетчик символа в левой позиции окна sCount[s[left]] и сдвигаем левый указатель вправо.
		5. Если счетчики для текущего окна sCount и pCount равны, то добавляем left в результат, так как это начало анаграммы.
		6. Повторяем шаги 3-5 до тех пор, пока правый указатель не достигнет конца строки s.
		7. Возвращаем список индексов, где начинаются все анаграммы.
	*/
	// Инициализируем срезы для отслеживания количества символов в строке p и в текущем окне s
	pCount, sCount := make([]int, 26), make([]int, 26)
	// Срез для хранения результатов
	result := []int{}

	// Заполняем срезы для строки p
	for _, ch := range p {
		pCount[ch-'a']++
	}

	// Инициализируем указатели для окна
	left, right := 0, 0
	for right < len(s) {
		// Добавляем текущий символ в окно
		sCount[s[right]-'a']++
		// Если размер окна больше, чем p, уменьшаем счетчик символа в левой позиции окна и сдвигаем левый указатель
		if right-left+1 > len(p) {
			sCount[s[left]-'a']--
			left++
		}
		// Если счетчики для текущего окна и p равны, добавляем left в результат
		if right-left+1 == len(p) && compare(pCount, sCount) {
			result = append(result, left)
		}
		right++
	}

	return result
}

// Функция для сравнения двух срезов
func compare(a, b []int) bool {
	for i := range a {
		if a[i] != b[i] {
			return false
		}
	}
	return true
}

func main() {
	s := "cbaebabacd"
	p := "abc"
	fmt.Println(findAnagrams(s, p)) // Вывод: [0, 6]
}
