package main

// Функция для преобразования отсортированного списка в бинарное дерево поиска
// Входные данные: указатель на начало списка
// Выходные данные: указатель на корень бинарного дерева поиска
// Временная сложность: O(n), так как мы проходим по всем узлам списка дважды: один раз для заполнения массива, а второй раз для построения дерева
// Пространственная сложность: O(n), так как мы храним все значения узлов списка в массиве
func sortedListToBST(head *ListNode) *TreeNode {
	// Если список пуст, то и дерево пусто
	if head == nil {
		return nil
	}

	var arr []int
	// Заполняем массив значениями узлов списка
	for head != nil {
		arr = append(arr, head.Val)
		head = head.Next
	}

	// Преобразуем отсортированный массив в бинарное дерево поиска
	return sortedArrayToBST(arr)
}

// Функция для преобразования отсортированного массива в бинарное дерево поиска
// Входные данные: отсортированный массив значений узлов
// Выходные данные: указатель на корень бинарного дерева поиска
// Временная сложность: O(n), так как на каждом уровне рекурсии мы делим массив на пополам, а затем рекурсивно обрабатываем каждую половину
// Пространственная сложность: O(log n), так как мы используем дополнительное пространство для стека вызовов рекурсии
func sortedArrayToBST(arr []int) *TreeNode {
	/*
		Method: Array
		Time complexity: O(n), так как на каждом уровне рекурсии мы делим массив на пополам, а затем рекурсивно обрабатываем каждую половину
		Space complexity: O(log n), так как мы используем дополнительное пространство для стека вызовов рекурсии


	*/
	// Если массив пуст, то и дерево пусто
	if len(arr) == 0 {
		return nil
	}

	// Находим средний элемент массива
	mid := len(arr) / 2
	// Создаем новую вершину дерева с значением среднего элемента
	root := &TreeNode{Val: arr[mid]}
	// Рекурсивно преобразуем левое и правое поддеревья
	root.Left = sortedArrayToBST(arr[:mid])
	root.Right = sortedArrayToBST(arr[mid+1:])

	return root
}
