package main

// Функция helper рекурсивно проверяет возможность достижения целевого объема воды
func helper(total, j1Cap, j2Cap int, target int, vis map[int]bool) bool {
	// Если текущий общий объем равен целевому, возвращаем true
	if total == target {
		return true
	}

	// Если этот общий объем уже был посещен, или если общий объем меньше 0,
	// или если общий объем больше суммы объемов двух ведер, возвращаем false
	if vis[total] || total < 0 || total > (j1Cap+j2Cap) {
		return false
	}

	// Помечаем текущий общий объем как посещенный
	vis[total] = true

	// Рекурсивно проверяем все возможные операции:
	// 1. Уменьшаем общий объем на объем первого ведра
	// 2. Уменьшаем общий объем на объем второго ведра
	// 3. Увеличиваем общий объем на объем первого ведра
	// 4. Увеличиваем общий объем на объем второго ведра
	t1 := helper(total-j1Cap, j1Cap, j2Cap, target, vis)
	t2 := helper(total-j2Cap, j1Cap, j2Cap, target, vis)
	t3 := helper(total+j1Cap, j1Cap, j2Cap, target, vis)
	t4 := helper(total+j2Cap, j1Cap, j2Cap, target, vis)

	// Возвращаем true, если хотя бы одна из рекурсивных проверок вернула true
	return t1 || t2 || t3 || t4
}

// Основная функция, решающая задачу
func canMeasureWaterV2(x int, y int, target int) bool {
	/*
		METHOD: DFS
		- Используется рекурсивный подход с отслеживанием посещенных состояний для проверки всех возможных комбинаций объемов воды в двух ведрах.
		- Рекурсивно проверяются все возможные операции: добавление и удаление воды из каждого ведра.

		TIME COMPLEXITY:
		- Временная сложность зависит от количества уникальных состояний, которые могут быть посещены.
		- В худшем случае, каждое состояние может быть посещено один раз, что приводит к экспоненциальной временной сложности O(2^n), где n - количество операций.

		SPACE COMPLEXITY:
		- Пространственная сложность определяется размером карты vis, которая хранит посещенные состояния.
		- В худшем случае, карта может содержать все возможные состояния, что приводит к пространственной сложности O(n), где n - количество уникальных состояний.
	*/
	// Создаем карту для отслеживания посещенных общих объемов
	vis := make(map[int]bool)
	// Начинаем с общего объема 0 и вызываем вспомогательную функцию
	return helper(0, x, y, target, vis)
}
