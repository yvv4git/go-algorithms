package main

func wordBreak(s string, wordDict []string) bool {
	/*
		METHOD: Dynamic programming
		TIME COMPLEXITY: O(n^2), где n - длина строки s. Это связано с двумя вложенными циклами, которые проходят по всем подстрокам строки s.
		SPACE COMPLEXITY: O(n), так как мы используем дополнительный массив dp для хранения результатов подзадач.

		Method
		Используемый подход - динамическое программирование.
		Мы создаем массив dp, где dp[i] будет истинным, если строка s[0:i] может быть разбита на слова из словаря.
		Затем мы заполняем этот массив, используя информацию о предыдущих подзадачах.
	*/

	// Создаем множество для быстрого поиска слов в словаре
	wordSet := make(map[string]bool)
	for _, word := range wordDict {
		wordSet[word] = true
	}

	// Создаем массив для хранения результатов подзадач
	dp := make([]bool, len(s)+1)
	dp[0] = true // Пустая строка всегда может быть разбита

	// Проходим по всем подстрокам s
	for i := 1; i <= len(s); i++ {
		for j := 0; j < i; j++ {
			// Если подстрока s[j:i] есть в словаре и dp[j] == true,
			// то подстрока s[0:i] может быть разбита
			if dp[j] && wordSet[s[j:i]] {
				dp[i] = true
				break
			}
		}
	}

	// Результат - последний элемент массива dp
	return dp[len(s)]
}
