//go:build ignore

package main

import "fmt"

// Проверяет наличие подмассива с суммой кратной k, используя префиксные суммы с остатками
func checkSubarraySum(nums []int, k int) bool {
	/*
		APPROACH: PREFIX SUM WITH MODULO
		Этот алгоритм использует метод префиксных сумм с учетом остатков от деления на k для эффективного поиска подмассива, сумма которого кратна k. Основная идея заключается в следующем:

		1. **Инициализация**:
		   - Создаем хеш-таблицу (remainderMap) для хранения остатков от деления префиксных сумм на k и их индексов.
		   - Добавляем начальное условие: remainderMap[0] = -1, чтобы учесть случай, когда весь подмассив от начала до текущего индекса имеет сумму, кратную k.

		2. **Обработка массива**:
		   - Проходим по массиву nums, накапливая префиксную сумму (prefixSum).
		   - Для каждого индекса i вычисляем остаток от деления prefixSum на k (remainder = prefixSum % k).
		   - Если остаток remainder уже есть в хеш-таблице, проверяем, удовлетворяет ли длина подмассива (i - prevIndex) условию ≥ 2.
		   - Если длина подмассива ≥ 2, возвращаем true, так как найден подмассив с суммой, кратной k.
		   - Если остаток еще не встречался, сохраняем его в хеш-таблицу с текущим индексом i.

		3. **Математическая основа**:
		   - Если для двух индексов i и j выполняется sum[i] % k == sum[j] % k, то сумма элементов подмассива от i+1 до j кратна k.
		   - Это следует из свойства: (sum[j] - sum[i]) % k == 0, где sum[j] - sum[i] — сумма элементов подмассива.

		4. **Крайние случаи**:
		   - Если длина массива < 2, возвращаем false, так как подмассив должен содержать минимум 2 элемента.
		   - Если k = 0, алгоритм корректно обрабатывает случаи, когда подмассив состоит из нулей (сумма = 0).

		ПРЕДУСЛОВИЯ:
		- Массив nums не пустой.
		- Количество элементов в массиве больше или равно 2.
		- k > 0.
		- Все элементы в массиве целые числа.

		ПОЛУЧАЕМ:
		- Нужно найти подмассив с суммой, кратной k.
		- Подмассивом считается последовательность элементов nums[i], nums[i+1], ..., nums[j], где i и j — индексы начала и конца подмассива.
		- Подмассив должен быть длиной не менее 2.
		- Если подмассив существует, он должен быть длиной не менее 2.
		- Если подмассив не существует, функция возвращает false.

		Сложность алгоритма:
		- TIME COMPLEXITY: O(n) — один проход по массиву.
		- SPACE COMPLEXITY: O(min(n,k)) — хеш-таблица хранит до min(n,k) остатков.

		Примечания:
		1. Используется подход с префиксными суммами и остатками от деления.
		2. Работает эффективно даже для больших массивов.
		3. Основан на математическом свойстве: если sum[i] % k == sum[j] % k, то сумма подмассива между i и j кратна k.
	*/
	n := len(nums)
	if n < 2 {
		return false
	}

	// Храним остатки от деления префиксных сумм на k и их индексы
	remainderMap := make(map[int]int)
	remainderMap[0] = -1 // Базовый случай для суммы 0

	prefixSum := 0
	for i := 0; i < n; i++ {
		prefixSum += nums[i]
		remainder := prefixSum % k

		// Если остаток уже встречался и расстояние между индексами ≥ 2
		if prevIndex, exists := remainderMap[remainder]; exists {
			if i-prevIndex >= 2 {
				return true
			}
		} else {
			// Сохраняем только первое вхождение остаток
			remainderMap[remainder] = i
		}
	}

	return false
}

func main() {
	// Пример 1 из условия задачи (ожидается true)
	nums1 := []int{23, 2, 4, 6, 7}
	k1 := 6
	fmt.Printf("Пример 1:\nВход: %v, k=%d\nРезультат: %t\n\n", nums1, k1, checkSubarraySum(nums1, k1))

	// Пример 2 из условия задачи (ожидается true)
	nums2 := []int{23, 2, 6, 4, 7}
	k2 := 6
	fmt.Printf("Пример 2:\nВход: %v, k=%d\nРезультат: %t\n\n", nums2, k2, checkSubarraySum(nums2, k2))

	// Пример 3 из условия задачи (ожидается false)
	nums3 := []int{23, 2, 6, 4, 7}
	k3 := 13
	fmt.Printf("Пример 3:\nВход: %v, k=%d\nРезультат: %t\n\n", nums3, k3, checkSubarraySum(nums3, k3))

	// Дополнительный пример с нулевой суммой (ожидается true)
	nums4 := []int{0, 0}
	k4 := 1
	fmt.Printf("Пример с нулями:\nВход: %v, k=%d\nРезультат: %t\n", nums4, k4, checkSubarraySum(nums4, k4))
}
