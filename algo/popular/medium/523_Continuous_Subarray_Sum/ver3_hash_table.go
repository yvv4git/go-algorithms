package main

import "fmt"

// Проверяет, существует ли подмассив длиной не менее 2 с суммой, кратной k
func checkSubarraySum(nums []int, k int) bool {
	/*
		APPROACH: HASH TABLE WITH REMAINDERS
		Алгоритм использует хеш-таблицу для хранения остатков от деления префиксных сумм на k, чтобы эффективно найти подмассив, сумма которого кратна k. Подход основан на математическом свойстве остатков и их повторений.

		1. **Инициализация хеш-таблицы**:
		   - Создаем map[int]int для хранения остатков (remainder) от деления префиксных сумм на k и их первого индекса.
		   - Добавляем начальное условие: remainderMap[0] = -1, чтобы учесть случай, когда подмассив начинается с индекса 0 и его сумма кратна k.

		2. **Итерация по массиву**:
		   - Проходим по массиву nums, накапливая префиксную сумму (sum).
		   - Для каждого индекса i вычисляем остаток: remainder = sum % k.
		   - Если остаток уже есть в хеш-таблице:
		     - Проверяем, составляет ли длина подмассива (i - prevIndex) не менее 2.
		     - Если условие выполнено, возвращаем true, так как найден подмассив с суммой, кратной k.
		   - Если остаток новый, сохраняем его в хеш-таблицу с текущим индексом i.

		3. **Математическое обоснование**:
		   - Если для индексов i и j выполняется sum[j] % k == sum[i] % k, то сумма элементов подмассива от i+1 до j кратна k, так как (sum[j] - sum[i]) % k == 0.
		   - Это позволяет находить подмассив, не перебирая все возможные комбинации.

		4. **Крайние случаи**:
		   - Если длина массива < 2, возвращаем false, так как подмассив должен содержать минимум 2 элемента.
		   - Если k = 0, алгоритм корректно обрабатывает случаи, где подмассив состоит из нулей (сумма = 0).
		   - Для отрицательных чисел в массиве нормализуем остаток, чтобы он был неотрицательным.

		ПРЕДУСЛОВИЯ:
		- Массив nums не пустой.
		- Количество элементов в массиве больше или равно 2.
		- k > 0.
		- Все элементы в массиве — целые числа.

		ПОЛУЧАЕМ:
		- Нужно найти подмассив с суммой, кратной k.
		- Подмассив — это последовательность элементов nums[i], nums[i+1], ..., nums[j].
		- Подмассив должен быть длиной не менее 2.
		- Если подмассив не существует, возвращаем false.

		Сложность алгоритма:
		- TIME COMPLEXITY: O(n) — один проход по массиву.
		- SPACE COMPLEXITY: O(min(n,k)) — хеш-таблица хранит до min(n,k) остатков.

		Примечания:
		1. Используется хеш-таблица для хранения остатков от деления префиксных сумм.
		2. Алгоритм эффективен для больших массивов благодаря линейной временной сложности.
		3. Нормализация остатков (для отрицательных чисел) обеспечивает корректность работы.
	*/
	if len(nums) < 2 {
		return false
	}

	// Хеш-таблица для хранения остатков и их индексов
	remainderMap := map[int]int{0: -1}
	sum := 0

	for i, num := range nums {
		sum += num

		// Вычисляем остаток, нормализуя его для отрицательных чисел
		remainder := sum % k
		if remainder < 0 {
			remainder += k
		}

		// Проверяем, встречался ли остаток ранее
		if prevIndex, exists := remainderMap[remainder]; exists {
			if i-prevIndex >= 2 {
				return true
			}
		} else {
			remainderMap[remainder] = i
		}
	}

	return false
}

func main() {
	// Пример 1: Ожидается true (подмассив [2, 4] имеет сумму 6, кратную k=6)
	nums1 := []int{23, 2, 4, 6, 7}
	k1 := 6
	fmt.Printf("Пример 1:\nВход: %v, k=%d\nРезультат: %t\n\n", nums1, k1, checkSubarraySum(nums1, k1))

	// Пример 2: Ожидается true (подмассив [2, 6, 4] имеет сумму 12, кратную k=6)
	nums2 := []int{23, 2, 6, 4, 7}
	k2 := 6
	fmt.Printf("Пример 2:\nВход: %v, k=%d\nРезультат: %t\n\n", nums2, k2, checkSubarraySum(nums2, k2))

	// Пример 3: Ожидается false (нет подмассива с суммой, кратной k=13)
	nums3 := []int{23, 2, 6, 4, 7}
	k3 := 13
	fmt.Printf("Пример 3:\nВход: %v, k=%d\nРезультат: %t\n\n", nums3, k3, checkSubarraySum(nums3, k3))

	// Пример 4: Ожидается true (подмассив [0, 0] имеет сумму 0, кратную k=1)
	nums4 := []int{0, 0}
	k4 := 1
	fmt.Printf("Пример с нулями:\nВход: %v, k=%d\nРезультат: %t\n", nums4, k4, checkSubarraySum(nums4, k4))
}
