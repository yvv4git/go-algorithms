//go:build ignore

package main

import "fmt"

// Проверяет, существует ли подмассив длиной ≥ 2 с суммой, кратной k
func checkSubarraySum(nums []int, k int) bool {
	/*
		APPROACH: BRUTE FORCE

		Сложность алгоритма:
		- TIME COMPLEXITY: O(n²) - два вложенных цикла по n элементов
		- SPACE COMPLEXITY: O(1) - используем только константное количество дополнительной памяти

		Примечания:
		1. Это решение методом полного перебора (brute force)
		2. Для больших массивов (n ~ 10^5) будет работать медленно
		3. Оптимальные решения используют префиксные суммы или хеш-таблицы
	*/
	n := len(nums)

	// Перебираем все возможные начальные индексы подмассивов
	for i := 0; i < n; i++ {
		sum := nums[i]

		// Перебираем все возможные конечные индексы подмассивов
		for j := i + 1; j < n; j++ {
			sum += nums[j]

			// Проверяем условие задачи:
			// 1) Длина подмассива ≥ 2 (гарантируется j > i)
			// 2) Сумма кратна k
			if sum%k == 0 {
				return true
			}
		}
	}

	// Не нашли подходящий подмассив
	return false
}

func main() {
	// Пример 1 из условия задачи (ожидается true)
	nums1 := []int{23, 2, 4, 6, 7}
	k1 := 6
	fmt.Printf("Пример 1:\nВход: %v, k=%d\nРезультат: %t\n\n", nums1, k1, checkSubarraySum(nums1, k1))

	// Пример 2 из условия задачи (ожидается true)
	nums2 := []int{23, 2, 6, 4, 7}
	k2 := 6
	fmt.Printf("Пример 2:\nВход: %v, k=%d\nРезультат: %t\n\n", nums2, k2, checkSubarraySum(nums2, k2))

	// Пример 3 из условия задачи (ожидается false)
	nums3 := []int{23, 2, 6, 4, 7}
	k3 := 13
	fmt.Printf("Пример 3:\nВход: %v, k=%d\nРезультат: %t\n\n", nums3, k3, checkSubarraySum(nums3, k3))

	// Дополнительный пример с небольшим массивом (ожидается false)
	nums4 := []int{1, 2}
	k4 := 4
	fmt.Printf("Дополнительный пример:\nВход: %v, k=%d\nРезультат: %t\n", nums4, k4, checkSubarraySum(nums4, k4))
}
