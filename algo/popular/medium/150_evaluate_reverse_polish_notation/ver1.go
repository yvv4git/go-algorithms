package main

import (
	"fmt"
	"strconv"
)

// Функция для вычисления выражения в обратной польской нотации
func evalRPN(tokens []string) int {
	/*
		METHOD: Stack
		Алгоритм вычисления ОПН обычно использует стек для хранения операндов.
		Когда встречается операнд, он помещается в стек. Когда встречается оператор,
		из стека извлекаются соответствующее количество операндов (обычно два), выполняется операция, и результат помещается обратно в стек.
		В конце вычислений в стеке останется одно значение, которое и будет результатом выражения.

		Задача решена с использованием стека для хранения операндов.
		Когда встречается операнд, он помещается в стек. Когда встречается оператор,
		из стека извлекаются два последних операнда, выполняется соответствующая операция, и результат помещается обратно в стек.
		В конце вычислений в стеке останется одно значение, которое является результатом выражения.
		Этот подход эффективно использует стек для вычисления выражений в обратной польской нотации.

		TIME COMPLEXITY: O(n), где n — количество токенов в выражении.
		Мы проходим по всем токенам один раз, и для каждого токена выполняем константное количество операций.

		SPACE COMPLEXITY: O(n), где n — количество токенов в выражении.
		В худшем случае (когда все токены — это операнды) мы будем хранить все операнды в стеке.
	*/
	// Стек для хранения операндов
	stack := []int{}

	// Проходим по всем токенам в выражении
	for _, token := range tokens {
		switch token {
		case "+":
			// Извлекаем два последних операнда из стека
			a, b := stack[len(stack)-2], stack[len(stack)-1]
			// Удаляем два последних элемента из стека
			stack = stack[:len(stack)-2]
			// Выполняем операцию сложения и добавляем результат в стек
			stack = append(stack, a+b)
		case "-":
			// Извлекаем два последних операнда из стека
			a, b := stack[len(stack)-2], stack[len(stack)-1]
			// Удаляем два последних элемента из стека
			stack = stack[:len(stack)-2]
			// Выполняем операцию вычитания и добавляем результат в стек
			stack = append(stack, a-b)
		case "*":
			// Извлекаем два последних операнда из стека
			a, b := stack[len(stack)-2], stack[len(stack)-1]
			// Удаляем два последних элемента из стека
			stack = stack[:len(stack)-2]
			// Выполняем операцию умножения и добавляем результат в стек
			stack = append(stack, a*b)
		case "/":
			// Извлекаем два последних операнда из стека
			a, b := stack[len(stack)-2], stack[len(stack)-1]
			// Удаляем два последних элемента из стека
			stack = stack[:len(stack)-2]
			// Выполняем операцию деления и добавляем результат в стек
			stack = append(stack, a/b)
		default:
			// Если токен не является оператором, то это операнд
			// Преобразуем строку в целое число и добавляем в стек
			num, _ := strconv.Atoi(token)
			stack = append(stack, num)
		}
	}

	// Результатом будет единственное оставшееся значение в стеке
	return stack[0]
}

func main() {
	tokens := []string{"2", "1", "+", "3", "*"}
	result := evalRPN(tokens)
	fmt.Println(result) // Вывод: 9
}
