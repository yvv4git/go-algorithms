package main

func canFinishV2(numCourses int, prerequisites [][]int) bool {
	/*
		METHOD: Topological sort
		Топологическая сортировка — это алгоритм, который используется для упорядочивания вершин в ориентированном ациклическом графе (DAG).
		Основная идея заключается в том, чтобы начать с вершин, у которых нет входящих ребер, и постепенно удалять их из графа,
		уменьшая количество входящих ребер для смежных вершин. Если в процессе сортировки мы можем посетить все вершины,
		то граф является ациклическим, и можно завершить все курсы. Если же мы не можем посетить все вершины,
		то в графе есть цикл, и завершить все курсы невозможно.

		TIME COMPLEXITY: O(V + E), где V — количество вершин (курсов), E — количество ребер (зависимостей).
		Это связано с тем, что мы посещаем каждую вершину и каждое ребро ровно один раз.

		SPACE COMPLEXITY: O(V + E), где V — количество вершин, E — количество ребер.
		Это связано с тем, что мы храним граф в виде списка смежности и массив для отслеживания количества входящих ребер.
	*/
	// Создаем граф в виде списка смежности
	graph := make([][]int, numCourses)
	// Массив для хранения количества входящих ребер (входящих зависимостей)
	inDegree := make([]int, numCourses)

	// Заполняем граф и массив входящих ребер
	for _, pre := range prerequisites {
		graph[pre[1]] = append(graph[pre[1]], pre[0])
		inDegree[pre[0]]++
	}

	// Очередь для хранения вершин без входящих ребер
	queue := []int{}
	for i := 0; i < numCourses; i++ {
		if inDegree[i] == 0 {
			queue = append(queue, i)
		}
	}

	// Количество посещенных вершин
	visitedCount := 0

	// Обрабатываем вершины в очереди
	for len(queue) > 0 {
		// Извлекаем вершину из очереди
		node := queue[0]
		queue = queue[1:]
		visitedCount++

		// Уменьшаем количество входящих ребер для всех смежных вершин
		for _, neighbor := range graph[node] {
			inDegree[neighbor]--
			// Если у смежной вершины нет входящих ребер, добавляем ее в очередь
			if inDegree[neighbor] == 0 {
				queue = append(queue, neighbor)
			}
		}
	}

	// Если количество посещенных вершин равно количеству курсов, то можно завершить все курсы
	return visitedCount == numCourses
}
