package main

import (
	"strings"
)

// Функция lengthLongestPath принимает строку input, представляющую иерархию файлов и директорий,
// и возвращает длину самого длинного абсолютного пути к файлу.
func lengthLongestPath(input string) int {
	/*
		METHOD: Map
		Я использую мапу для эффективного хранения и обновления длин путей до каждого уровня вложенности.
		Этот подход позволяет быстро вычислять длину пути для каждого файла и обновлять максимальную длину при необходимости.
		Использование мапы позволяет нам избежать повторных вычислений и упрощает логику обновления путей.

		TIME COMPLEXITY: O(n), где n — длина входной строки. Это связано с тем, что мы проходим по каждому символу входной строки не более одного раза.

		SPACE COMPLEXITY: O(m + d), где m — количество строк после разделения, а d — максимальный уровень вложенности.
		Это связано с тем, что мы храним массив строк и мапу для длин путей.
	*/
	// Разделяем входную строку по символу новой строки '\n'
	lines := strings.Split(input, "\n")

	// Создаем мапу для хранения длины пути до каждого уровня вложенности
	pathLengths := make(map[int]int)

	// Инициализируем переменную для хранения максимальной длины пути
	maxLength := 0

	// Проходим по каждой строке
	for _, line := range lines {
		// Убираем символы табуляции для получения имени директории или файла
		name := strings.TrimLeft(line, "\t")

		// Определяем уровень вложенности по количеству символов табуляции
		depth := len(line) - len(name)

		// Если имя содержит точку, значит это файл
		if strings.Contains(name, ".") {
			// Вычисляем длину текущего пути до файла
			currentLength := pathLengths[depth] + len(name)
			// Обновляем максимальную длину, если текущая длина больше
			if currentLength > maxLength {
				maxLength = currentLength
			}
		} else {
			// Если это директория, обновляем длину пути до следующего уровня
			// Добавляем 1 для символа '/' между директориями
			pathLengths[depth+1] = pathLengths[depth] + len(name) + 1
		}
	}

	return maxLength
}
