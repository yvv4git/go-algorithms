package main

func subarraysDivByK(A []int, K int) int {
	/*
		METHOD: Prefix sum
		Метод решения заключается в подсчете количества подмассивов, сумма элементов которых делится на K без остатка.
		Для этого мы используем префиксные суммы и словарь для хранения количества подмассивов с определенной суммой.

		TIME COMPLEXITY: O(n), где n - количество элементов в массиве A, потому что мы проходим по всем элементам массива ровно один раз.

		SPACE COMPLEXITY: O(k), где k - заданное число, потому что в худшем случае мы можем хранить k разных остатков в словаре count.
	*/
	// Инициализируем словарь для хранения количества подмассивов с определенной суммой
	count := make(map[int]int)
	// Инициализируем переменную для подсчета количества подмассивов
	result := 0
	// Инициализируем переменную для подсчета суммы элементов подмассива
	sum := 0
	// Инициализируем счетчик для нулевой суммы (т.е. пустого подмассива)
	count[0] = 1

	// Проходим по всем элементам массива
	for _, a := range A {
		// Добавляем текущий элемент к сумме
		sum += a
		// Вычисляем остаток от деления суммы на K
		remainder := sum % K
		// Если остаток отрицательный, приводим его к положительному значению
		if remainder < 0 {
			remainder += K
		}
		// Добавляем количество подмассивов с текущей суммой к результату
		result += count[remainder]
		// Увеличиваем счетчик подмассивов с текущей суммой
		count[remainder]++
	}

	// Возвращаем количество подмассивов, сумма элементов которых делится на K без остатка
	return result
}
