//go:build ignore

package main

import "fmt"

func longestValidParentheses(s string) int {
	/*
		METHOD: Stack
		Преимущества подхода с использованием стека:
		1. Простота реализации: Использование стека позволяет легко отслеживать индексы скобок и вычислять длину правильных подстрок.
		2. Эффективность: Временная сложность O(n) делает этот подход достаточно быстрым для большинства практических задач.

		Недостатки:
		1. Использование дополнительной памяти: Пространственная сложность O(n) может быть недостатком для очень больших строк,
		так как требуется дополнительная память для хранения индексов в стеке.
		2. Ограничения на входные данные: Этот подход предполагает, что входная строка состоит только из символов '(' и ')',
		и не может быть легко адаптирован для других типов скобок или символов.

		TIME COMPLEXITY: O(n), где n — длина строки. Мы проходим по строке один раз.

		SPACE COMPLEXITY: O(n), так как в худшем случае (когда строка состоит только из открывающих скобок) все индексы будут храниться в стеке.

	*/
	maxLength := 0     // Переменная для хранения максимальной длины правильной подстроки
	stack := []int{-1} // Инициализируем стек с начальным индексом -1, чтобы корректно обрабатывать первую правильную подстроку

	for i, char := range s {
		if char == '(' {
			// Если текущий символ - открывающая скобка, добавляем её индекс в стек
			stack = append(stack, i)
		} else {
			// Если текущий символ - закрывающая скобка, удаляем последний индекс из стека
			stack = stack[:len(stack)-1]
			if len(stack) == 0 {
				// Если стек стал пустым, добавляем текущий индекс в стек, чтобы обозначить начало новой потенциальной правильной подстроки
				stack = append(stack, i)
			} else {
				// Вычисляем длину текущей правильной подстроки и обновляем максимальную длину
				maxLength = max(maxLength, i-stack[len(stack)-1])
			}
		}
	}

	return maxLength
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	fmt.Println(longestValidParentheses("(()"))    // Вывод: 2
	fmt.Println(longestValidParentheses(")()())")) // Вывод: 4
	fmt.Println(longestValidParentheses(""))       // Вывод: 0
}
