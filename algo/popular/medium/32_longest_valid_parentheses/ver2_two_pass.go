//go:build ignore

package main

import "fmt"

func longestValidParenthesesV2(s string) int {
	/*
		METHOD: Two pass
		Суть подхода "Двух проходов" заключается в том, чтобы проанализировать строку сначала слева направо,
		а затем справа налево, чтобы найти самую длинную подстроку с правильно расставленными скобками.
		Этот метод позволяет учесть все возможные конфигурации скобок, которые могут быть пропущены при однократном проходе.

		Преимущества:
		1. Эффективность по памяти: Использование постоянного объема памяти (O(1)) делает этот подход очень эффективным по памяти.
		2. Простота реализации: Подход двух проходов легко понять и реализовать.

		Недостатки:
		1. Два прохода: Необходимость проходить по строке дважды может быть недостатком в некоторых случаях,
		хотя временная сложность остается линейной.
		2. Ограничения на входные данные: Как и в предыдущем подходе, этот метод предполагает,
		что входная строка состоит только из символов '(' и ')', и не может быть легко адаптирован для других типов скобок или символов.

		TIME COMPLEXITY: O(n), где n — длина строки. Мы проходим по строке дважды, но каждый проход линейный.

		SPACE COMPLEXITY: O(1), так как мы используем только несколько переменных для хранения счетчиков и максимальной длины.
	*/
	maxLength := 0 // Переменная для хранения максимальной длины правильной подстроки

	// Первый проход слева направо
	left, right := 0, 0 // Инициализация счетчиков для открывающих и закрывающих скобок
	for i := 0; i < len(s); i++ {
		if s[i] == '(' {
			left++ // Увеличиваем счетчик открывающих скобок
		} else {
			right++ // Увеличиваем счетчик закрывающих скобок
		}
		if left == right {
			maxLength = max(maxLength, 2*right) // Если количество открывающих и закрывающих скобок равно, обновляем максимальную длину
		} else if right > left {
			left, right = 0, 0 // Если количество закрывающих скобок превышает количество открывающих, сбрасываем счетчики
		}
	}

	// Второй проход справа налево
	left, right = 0, 0 // Сбрасываем счетчики для второго прохода
	for i := len(s) - 1; i >= 0; i-- {
		if s[i] == '(' {
			left++ // Увеличиваем счетчик открывающих скобок
		} else {
			right++ // Увеличиваем счетчик закрывающих скобок
		}
		if left == right {
			maxLength = max(maxLength, 2*left) // Если количество открывающих и закрывающих скобок равно, обновляем максимальную длину
		} else if left > right {
			left, right = 0, 0 // Если количество открывающих скобок превышает количество закрывающих, сбрасываем счетчики
		}
	}

	return maxLength // Возвращаем максимальную длину правильной подстроки
}

//func max(a, b int) int {
//	if a > b {
//		return a
//	}
//	return b
//}

func main() {
	fmt.Println(longestValidParenthesesV2("(()"))    // Вывод: 2
	fmt.Println(longestValidParenthesesV2(")()())")) // Вывод: 4
	fmt.Println(longestValidParenthesesV2(""))       // Вывод: 0
}
