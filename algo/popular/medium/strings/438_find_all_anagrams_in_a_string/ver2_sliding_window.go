package main

// Функция для поиска всех анаграмм в строке
func findAnagramsV2(s string, p string) []int {
	/*
		METHOD: Sliding window
		TIME COMPLEXITY: O(n), где n - длина строки s. Это обусловлено тем, что мы проходим по строке s только один раз,
		и для каждого символа выполняем постоянное количество операций (добавление и удаление из словаря).
		SPACE COMPLEXITY: O(1), так как используются фиксированные размеры массивов (два массива длиной 26 для счетчиков символов), независимо от размера входных данных.
	*/
	// Результирующий срез для хранения индексов начала анаграмм
	res := []int{}

	// Если длина строки s меньше длины строки p, то анаграммы не могут существовать, поэтому возвращаем пустой срез
	if len(s) < len(p) {
		return res
	}

	// Инициализируем два словаря для отслеживания количества символов в строке p и в текущем окне s
	pDict := make([]int, 26)
	sDict := make([]int, 26)

	// Заполняем словарь для строки p и первого окна s
	for i := 0; i < len(p); i++ {
		pDict[p[i]-'a']++
		sDict[s[i]-'a']++
	}

	// Начинаем следить за текущим окном, начиная с индекса 0
	start := 0
	// Если словари равны, то добавляем индекс начала окна в результат
	if isEqual(pDict, sDict) {
		res = append(res, start)
	}

	// Проходим по строке s, начиная с индекса len(p)
	for end := len(p); end < len(s); end++ {
		// Добавляем новый символ в текущее окно
		sDict[s[end]-'a']++
		// Удаляем первый символ из предыдущего окна
		sDict[s[start]-'a']--
		// Сдвигаем начало окна вправо
		start++
		// Если словари равны, то добавляем индекс начала окна в результат
		if isEqual(pDict, sDict) {
			res = append(res, start)
		}
	}

	// Возвращаем срез индексов, где начинаются все анаграммы
	return res
}

// Функция для сравнения двух словарей
func isEqual(pDict, sDict []int) bool {
	// Проходим по всем элементам словарей и сравниваем их
	for i := 0; i < 26; i++ {
		// Если хотя бы один элемент не совпадает, словари не равны
		if pDict[i] != sDict[i] {
			return false
		}
	}
	// Если все элементы совпадают, словари равны
	return true
}
