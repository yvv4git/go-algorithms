package main

// Функция isInterleaveV2 проверяет, можно ли получить строку s3 путем взаимного объединения строк s1 и s2.
// Версия функции, использующая оптимизированный подход с использованием битовых операций для уменьшения использования памяти.
func isInterleaveV2(s1 string, s2 string, s3 string) bool {
	/*
		METHOD: Dynamic programming
		TIME COMPLEXITY: O(m * n), где m и n - длины строк s1 и s2 соответственно.
		SPACE COMPLEXITY: O(m * n), так как мы используем дополнительный двумерный массив dp размером (m + 1) * (n + 1).
	*/
	// Получаем длины строк s1, s2 и s3.
	m, n, k := len(s1), len(s2), len(s3)

	// Если суммарная длина s1 и s2 не равна длине s3, то s3 не может быть получена путем взаимного объединения s1 и s2.
	if m+n != k {
		return false
	}

	// Инициализируем переменную dp1 для хранения состояния для предыдущего символа s2.
	// Используем битовую маску, где бит i равен 1, если подстрока s3, которая заканчивается на символе s2 с индексом i,
	// может быть получена путем взаимного объединения подстрок s1 и s2.
	dp1 := 1
	for i := 1; i <= n; i++ {
		// Если текущий символ s2 совпадает с символом s3 и предыдущий символ s2 может быть объединен с предыдущим символом s3,
		// то устанавливаем i-й бит в dp1.
		if s2[i-1] == s3[i-1] && dp1&1 == 1 {
			dp1 = (dp1 << 1) + 1
		} else {
			dp1 = dp1 << 1
		}
	}

	// Проходим по символам s1.
	for j := 1; j <= m; j++ {
		// Инициализируем переменную dp2 для хранения состояния для текущего символа s1.
		dp2 := 0
		// Если текущий символ s1 совпадает с символом s3 и предыдущий символ s2 может быть объединен с предыдущим символом s3,
		// то устанавливаем последний бит в dp2.
		if s1[j-1] == s3[j-1] && dp1&(1<<n) != 0 {
			dp2 = 1
		}
		// Проходим по символам s2.
		for i := 1; i <= n; i++ {
			// Если текущий символ s1 совпадает с символом s3 и предыдущий символ s1 может быть объединен с предыдущим символом s3,
			// или если текущий символ s2 совпадает с символом s3 и предыдущий символ s2 может быть объединен с предыдущим символом s3,
			// то устанавливаем i-й бит в dp2.
			if (s1[j-1] == s3[j+i-1] && dp1&(1<<(n-i)) != 0) ||
				(s2[i-1] == s3[j+i-1] && dp2&1 == 1) {
				dp2 = (dp2 << 1) + 1
			} else {
				dp2 = dp2 << 1
			}
		}
		// Обновляем dp1 для следующей итерации.
		dp1 = dp2
	}

	// Возвращаем true, если последний символ s3 может быть получен путем взаимного объединения s1 и s2, иначе false.
	return dp1&1 == 1
}
