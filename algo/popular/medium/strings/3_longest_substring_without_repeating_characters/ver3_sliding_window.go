package __longest_substring_without_repeating_characters

func lengthOfLongestSubstringV3(s string) int {
	/*
		METHOD: Sliding window
		TIME COMPLEXITY: O(n)
		Space complexity: O(min(n, m)), где m - размер алфавита, а n - количество символов в окне.

		Текущий подход в функции lengthOfLongestSubstringV3 использует карту для хранения уникальных символов и их позиций.
		Преимущество этого подхода по сравнению с использованием простой карты заключается в следующем:
		1. Удаление символов из карты позволяет оптимизировать пространственное использование памяти,
		так как мы храним только уникальные символы и их позиции, а не все символы строки.
		2. Уменьшение счетчика символа на начало подстроки позволяет нам эффективно обновлять карту
		и находить следующую позицию для начала подстроки без повторений.

		Этот подход позволяет улучшить время выполнения функции и снизить потребление памяти.
	*/
	if len(s) == 0 { // Если строка пуста, возвращаем 0
		return 0
	}

	res := -1 << 63 // Минимальное значение int64

	l := 0                  // Индекс начала подстроки
	m := make(map[byte]int) // Карта для хранения уникальных символов и их позиций
	m[s[0]]++               // Добавляем первый символ в карту

	for i := 1; i < len(s); i++ { // Проходим по строке
		m[s[i]]++ // Увеличиваем счетчик символа в карте

		for m[s[i]] > 1 { // Если символ повторяется
			m[s[l]]-- // Уменьшаем счетчик символа на начало подстроки

			if m[s[l]] <= 0 { // Если счетчик символа меньше или равен 0
				delete(m, s[l]) // Удаляем символ из карты
			}

			l++ // Переходим к следующему символу
		}

		if len(m) > res { // Если текущая длина подстроки без повторений больше максимальной
			res = len(m) // Обновляем максимальную длину
		}
	}

	if len(m) > res { // Если текущая длина подстроки без повторений больше максимальной
		res = len(m) // Обновляем максимальную длину
	}

	return res // Возвращаем максимальную длину подстроки без повторений
}
