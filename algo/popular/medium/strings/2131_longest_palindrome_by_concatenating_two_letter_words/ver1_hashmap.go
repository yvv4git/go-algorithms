package main

func longestPalindromeV1(words []string) int {
	/*
		METHOD: Hashmap
		TIME COMPLEXITY: O(n), это связано с тем, что мы проходим по всем словам в массиве ровно один раз.
		Space complexity: O(n), это связано с тем, что в хэш-таблице мы храним все слова из массива.

		Для решения задачи используется алгоритм, основанный на подсчете вхождений каждого слова в списке.
		Если первый и последний символы слова одинаковы, то оно может быть использовано в палиндроме дважды.
		Если первый и последний символы слова не одинаковы, то оно может быть использовано в палиндроме,
		если его перевернутая версия также есть в списке.

		Работа функции основана на следующем алгоритме:
		1. Создается пустой словарь m для подсчета количества вхождений каждого слова.
		2. Инициализируется переменная res, которая будет хранить длину самого длинного палиндрома.
		3. Для каждого слова из списка words выполняется следующий алгоритм:
		3.1. Если первый и последний символы слова одинаковы, то проверяется, было ли это слово уже встречено.
		Если да, то добавляется 4 к res (так как палиндром может состоять из двух одинаковых слов) и уменьшается счетчик вхождений этого слова в словаре.
		3.2. Если слово не было встречено, то добавляется в словарь.
		3.3. Если первый и последний символы слова не одинаковы, то проверяется, было ли это слово уже встречено.
		Если да, то добавляется 4 к res и уменьшается счетчик вхождений этого слова в словаре.
		3.4. Если слово не было встречено, то оно переворачивается и добавляется в словарь.
		4. После того, как все слова обработаны, проверяется словарь на наличие слов,
		у которых первый и последний символы одинаковы и которые встречались более одного раза.
		Если такое слово найдено, то добавляется 2 к res (так как палиндром может состоять из одного слова, которое повторяется).
		5. В конце функция возвращает длину самого длинного палиндрома, который можно построить из заданных слов.
	*/

	m := make(map[string]int)
	res := 0
	for _, word := range words {
		if word[0] == word[1] {
			if m[word] > 0 {
				res += 4
				m[word]--
			} else {
				m[word]++
			}
		} else {
			if m[word] > 0 {
				res += 4
				m[word]--
			} else {
				m[reverse(word)]++
			}
		}
	}

	for word, count := range m {
		if word[0] == word[1] && count > 0 {
			res += 2
			break
		}
	}

	return res
}

func reverse(s string) string {
	runes := []rune(s)

	for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}

	return string(runes)
}
