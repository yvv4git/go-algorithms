package _400_construct_k_palindrome_strings

// Функция canConstruct проверяет, можно ли составить из строки s ровно k палиндромов.
// Входные данные: строка s и целое число k.
// Выходные данные: true, если можно составить ровно k палиндромов, false в противном случае.
func canConstructV1(s string, k int) bool {
	/*
		METHOD: Counting
		Time complexity: O(n)
		Space complexity: O(1)

		Time complexity
		Временная сложность этого алгоритма составляет O(n), где n - длина строки s,
		так как мы проходим по всем символам строки s дважды: один раз для подсчета вхождений символов,
		а второй раз для подсчета нечетных символов.

		Space complexity
		Пространственная сложность этого алгоритма составляет O(1),
		так как мы используем фиксированное количество памяти для подсчета вхождений символов,
		независимо от размера входной строки s.

		В этом решении мы подсчитываем количество вхождений каждого символа в строке s.
		Затем мы подсчитываем количество символов, которые встречаются нечетное количество раз.
		Если это количество не превышает k, то мы можем составить ровно k палиндромов из строки s.

		Этот подход является оптимальным, так как он имеет линейную сложность O(n), где n - длина строки s.
	*/
	// Если длина строки s меньше k, то невозможно составить k палиндромов.
	if len(s) < k {
		return false
	}

	// Создаем срез для подсчета вхождений каждого символа в строке s.
	count := make([]int, 26)

	// Проходим по всем символам строки s и увеличиваем соответствующий элемент счетчика.
	for _, c := range s {
		count[c-'a']++
	}

	// Инициализируем счетчик нечетных символов.
	odd := 0

	// Проходим по всем элементам счетчика и увеличиваем счетчик нечетных символов.
	for _, c := range count {
		if c%2 == 1 {
			odd++
		}
	}

	// Если количество нечетных символов меньше или равно k, то можно составить ровно k палиндромов.
	return odd <= k
}
