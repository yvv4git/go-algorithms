package main

import (
	"fmt"
)

// Функция для поиска минимального количества мутаций
func minMutation(startGene string, endGene string, bank []string) int {
	/*
		METHOD: BFS
		TIME COMPLEXITY: O(N * M), где N - количество генов в начальной и конечной последовательностях, а M - количество мутаций в банке.
		Это связано с тем, что для каждой мутации мы проверяем, является ли она допустимой, что занимает O(N) времени,
		и мы проверяем каждую мутацию для каждой последовательности в очереди, что дает общее время O(N * M).
		SPACE COMPLEXITY: O(N * M), так как в худшем случае мы можем поместить в очередь все последовательности генов из банка, если все они разные.
		Это происходит, когда каждая мутация уникальна и может быть добавлена в очередь.
		Однако, в среднем мы можем уменьшить это количество, если некоторые мутации не являются допустимыми или уже посещались.

		METHOD
		Использование поиска в ширину (BFS) в этой задаче обусловлено тем, что мы ищем минимальное количество шагов,
		необходимых для преобразования одной последовательности генов в другую. BFS хорошо подходит для таких задач,
		потому что он позволяет нам просматривать граф в ширину, то есть последовательно посещая все вершины,
		находящиеся на одном расстоянии от начальной вершины, прежде чем переходить к следующему уровню.

		В нашем случае, каждая вершина в графе представляет собой последовательность генов, а ребра соединяют последовательности,
		которые отличаются ровно одним генами. BFS позволяет нам найти кратчайший путь от начальной последовательности генов к конечной,
		учитывая только допустимые мутации.

		Таким образом, BFS позволяет нам решать задачу эффективно, просматривая все возможные мутации последовательно,
		пока не найдем конечную последовательность или не исчерпаем все варианты. Это гарантирует,
		что мы найдем минимальное количество мутаций, так как BFS обходит граф по уровням, начиная с начальной вершины и далее.
	*/
	// Создаем множество для банка генов
	bankSet := make(map[string]bool)
	for _, gene := range bank {
		bankSet[gene] = true
	}

	// Если конечная последовательность не в банке, то преобразование невозможно
	if !bankSet[endGene] {
		return -1
	}

	// Инициализируем очередь и добавляем начальную последовательность
	queue := []string{startGene}
	mutations := 0

	// Пока очередь не пуста
	for len(queue) > 0 {
		// Для каждого элемента в очереди
		size := len(queue)
		for i := 0; i < size; i++ {
			// Если текущая последовательность совпадает с конечной, то преобразование уже достигнуто
			if queue[i] == endGene {
				return mutations
			}

			// Для каждого возможного гена
			for j := 0; j < len(queue[i]); j++ {
				// Для каждого возможного мутирования
				for _, c := range []byte{'A', 'C', 'G', 'T'} {
					// Формируем новую последовательность
					next := queue[i][:j] + string(c) + queue[i][j+1:]
					// Если мутация допустима и еще не посещалась
					if isValidMutation(queue[i], next, bankSet) {
						// Добавляем в очередь и удаляем из банка, чтобы не посещать повторно
						queue = append(queue, next)
						delete(bankSet, next)
					}
				}
			}
		}
		// Удаляем обработанные элементы из очереди
		queue = queue[size:]
		// Увеличиваем количество мутаций
		mutations++
	}

	// Если не удалось достичь конечной последовательности, то преобразование невозможно
	return -1
}

// Функция для проверки, является ли мутация допустимой
func isValidMutation(current, next string, bank map[string]bool) bool {
	diff := 0
	for i := 0; i < len(current); i++ {
		if current[i] != next[i] {
			diff++
		}
		if diff > 1 {
			return false
		}
	}
	return diff == 1 && bank[next]
}

func main() {
	start := "AACCGGTT"
	end := "AACCGGTA"
	bank := []string{"AACCGGTA"}
	fmt.Println(minMutation(start, end, bank)) // Выводит: 1
}
