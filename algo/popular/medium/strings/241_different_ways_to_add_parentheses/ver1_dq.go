package main

import (
	"fmt"
	"strconv"
)

func diffWaysToCompute(expression string) []int {
	/*
		Method: Divide and Conquer
		Time complexity: O(4^n / sqrt(n)), где n - количество операторов в выражении.
		Это связано с тем, что для каждого оператора мы делаем 4 рекурсивных вызова (два для левой и правой части выражения),
		и таких вызовов будет n (количество операторов).
		Space complexity: O(4^n / sqrt(n)), так как в худшем случае мы можем получить 4^n результатов для каждого оператора.

		Для решения задачи используется подход, известный как "Разделяй и властвуй" (Divide and Conquer).
		Этот подход основан на рекурсивном разбиении задачи на более мелкие подзадачи, которые решаются независимо друг от друга,
		и последующем объединении решений подзадач для получения решения исходной задачи.

		В данном случае, мы рекурсивно разбиваем выражение на две части, вычисляем все возможные способы добавления скобок для каждой части,
		и затем объединяем эти способы, используя различные комбинации результатов для левой и правой частей выражения.

		Такой подход позволяет нам решать задачу, где вычисление каждого подзадания независимо от других, и объединение решений происходит просто.
		Однако, как уже было сказано, этот подход может привести к повторяющимся вычислениям, если не применять оптимизации, такие как мемоизация.
	*/
	// Создаем пустой срез для хранения результатов
	result := make([]int, 0)

	// Проходим по каждому символу в строке
	for i := 0; i < len(expression); i++ {
		// Проверяем, является ли символ оператором (+, -, *)
		if expression[i] == '+' || expression[i] == '-' || expression[i] == '*' {
			// Разбиваем выражение на две части и рекурсивно вызываем diffWaysToCompute для каждой части
			left := diffWaysToCompute(expression[:i])
			right := diffWaysToCompute(expression[i+1:])

			// Выполняем операцию между каждым результатом из левой части и каждым результатом из правой части
			for _, l := range left {
				for _, r := range right {
					switch expression[i] {
					case '+':
						// Добавляем результат сложения в срез результатов
						result = append(result, l+r)
					case '-':
						// Добавляем результат вычитания в срез результатов
						result = append(result, l-r)
					case '*':
						// Добавляем результат умножения в срез результатов
						result = append(result, l*r)
					}
				}
			}
		}
	}

	// Если в срезе результатов нет элементов, то преобразуем строку в число и добавляем его в срез результатов
	if len(result) == 0 {
		num, _ := strconv.Atoi(expression)
		result = append(result, num)
	}

	return result
}

func main() {
	fmt.Println(diffWaysToCompute("2-1-1"))   // Вывод: [0 2]
	fmt.Println(diffWaysToCompute("2*3-4*5")) // Вывод: [-34, -14, -10, -10, 10]
}
