//go:build ignore

package main

import (
	"fmt"
	"sort"
)

// Функция largestDivisibleSubset принимает массив целых чисел и возвращает наибольшее делимое подмножество.
// Временная сложность: O(n^2), где n - длина массива nums.
// Пространственная сложность: O(n), где n - длина массива nums.
func largestDivisibleSubset(nums []int) []int {
	/*
		METHOD: Dynamic programming
		Динамическое программирование выбрано из-за его эффективности в задачах, где требуется найти оптимальное подмножество с определенными свойствами.
		Этот подход позволяет избежать перебора всех возможных подмножеств, сокращая временную сложность до квадратичной относительно размера входного массива.

		TIME COMPLEXITY: O(n^2), где n - длина массива nums.
		- Сортировка массива занимает O(n log n) времени.
		- Двойной цикл for занимает O(n^2) времени, так как для каждого элемента мы проверяем все предыдущие элементы.
		- Общая временная сложность составляет O(n log n) + O(n^2), что асимптотически эквивалентно O(n^2).

		SPACE COMPLEXITY: O(n), где n - длина массива nums.
		- Мы используем два дополнительных массива dp и prev, каждый из которых имеет длину n.
		- Таким образом, общая пространственная сложность составляет O(n).
	*/
	// Если входной массив пуст, возвращаем пустой массив.
	if len(nums) == 0 {
		return []int{}
	}

	// Сортируем массив, чтобы упростить проверку делимости.
	sort.Ints(nums)

	// dp[i] будет хранить размер наибольшего делимого подмножества, заканчивающегося на nums[i].
	dp := make([]int, len(nums))
	// prev[i] будет хранить индекс предыдущего элемента в наибольшем делимом подмножестве, заканчивающемся на nums[i].
	prev := make([]int, len(nums))

	// Инициализируем dp и prev.
	for i := range dp {
		dp[i] = 1
		prev[i] = -1
	}

	// Максимальный размер подмножества и индекс его последнего элемента.
	maxSize := 1
	maxIndex := 0

	// Заполняем dp и prev.
	for i := 1; i < len(nums); i++ {
		for j := 0; j < i; j++ {
			// Если nums[i] делится на nums[j] и это увеличивает размер подмножества, обновляем dp и prev.
			if nums[i]%nums[j] == 0 && dp[i] < dp[j]+1 {
				dp[i] = dp[j] + 1
				prev[i] = j
			}
		}
		// Обновляем максимальный размер подмножества и индекс его последнего элемента.
		if dp[i] > maxSize {
			maxSize = dp[i]
			maxIndex = i
		}
	}

	// Восстанавливаем наибольшее делимое подмножество.
	result := []int{}
	for maxIndex != -1 {
		result = append(result, nums[maxIndex])
		maxIndex = prev[maxIndex]
	}

	return result
}

func main() {
	nums := []int{1, 2, 3, 4, 8}
	fmt.Println(largestDivisibleSubset(nums)) // Вывод: [1, 2, 4, 8]
}
