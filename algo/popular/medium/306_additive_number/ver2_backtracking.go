package main

import "strconv"

// Функция isAdditiveNumberV2 проверяет, является ли число additive.
// Временная сложность: O(n^3), где n - длина строки num.
// Пространственная сложность: O(n), где n - длина строки num.
func isAdditiveNumberV2(num string) bool {
	/*
		METHOD: Backtracking
		TIME COMPLEXITY: O(n^3)
		SPACE COMPLEXITY: O(n)
	*/
	// Если длина строки меньше 3, то число не является additive.
	if len(num) < 3 {
		return false
	}

	// Цикл по всем возможным началах первого числа.
	for i := 1; i < len(num)-1; i++ {
		// Если первый символ - '0' и длина первого числа больше 1, то переходим к следующему символу.
		if num[0] == '0' && len(num[:i]) > 1 {
			break
		}

		// Преобразование первого числа из строки в число.
		a, _ := strconv.Atoi(num[:i])

		// Цикл по всем возможным началах второго числа.
		for j := i + 1; j < len(num); j++ {
			// Если второй символ - '0' и длина второго числа больше 1, то переходим к следующему символу.
			if num[i] == '0' && len(num[i:j]) > 1 {
				break
			}

			// Преобразование второго числа из строки в число.
			b, _ := strconv.Atoi(num[i:j])

			// Рекурсивный вызов функции dfs для проверки оставшейся части строки.
			if dfs(a, b, num[j:]) {
				// Если число является additive, возвращаем true.
				return true
			}
		}
	}

	// Если число не является additive, возвращаем false.
	return false
}

// Функция dfs проверяет, является ли оставшаяся часть строки additive.
// Временная сложность: O(n^2), где n - длина строки s.
// Пространственная сложность: O(n), где n - длина строки s.
func dfs(a, b int, s string) bool {
	// Если строка s пуста, то число является additive.
	if len(s) == 0 {
		return true
	}

	// Вычисление ожидаемой суммы двух последних чисел.
	target := a + b

	// Цикл по всем возможным началах следующего числа.
	for i := 1; i <= len(s); i++ {
		// Если первый символ - '0' и длина следующего числа больше 1, то переходим к следующему символу.
		if s[0] == '0' && len(s[:i]) > 1 {
			break
		}

		// Преобразование следующего числа из строки в число.
		c, _ := strconv.Atoi(s[:i])

		// Если следующее число равно ожидаемой сумме, то рекурсивно проверяем оставшуюся часть строки.
		if c == target {
			if dfs(b, c, s[i:]) {
				return true
			}
		}
	}

	// Если число не является additive, возвращаем false.
	return false
}
