package main

import (
	"fmt"
	"strconv"
)

func isAdditiveNumber(num string) bool {
	/*
		METHOD: Bruteforce
		TIME COMPLEXITY: O(n^2), где n - количество цифр в числе.
		Это связано с тем, что мы проверяем каждый возможный раздел числа, и для каждого раздела мы можем проверить все предыдущие разделы.
		SPACE COMPLEXITY: O(n), так как мы храним только входную строку и не используем дополнительное пространство, зависящее от размера входных данных.

	*/
	// Проходим по всем возможным разделениям числа.
	// Разделение происходит на два числа, поэтому мы проверяем все возможные индексы,
	// где может начинаться второе число.
	for i := 1; i <= len(num)/2; i++ {
		// Если первый символ строки - '0', то первое число должно быть '0',
		// иначе это не будет допустимым разделением.
		if num[0] == '0' && i > 1 {
			break
		}
		// Проходим по всем возможным индексам, где может начинаться третье число.
		for j := i + 1; max(i, j-i) <= len(num)-j; j++ {
			// Если второй символ строки - '0', то второе число должно быть '0',
			// иначе это не будет допустимым разделением.
			if num[i] == '0' && j-i > 1 {
				break
			}
			// Если текущее разделение является допустимым, то число является "добативным".
			if isValid(num, 0, i, j) { // Вызываем рекурсивную функцию
				return true
			}
		}
	}
	// Если мы прошли все возможные разделения и не нашли "добативного" числа,
	// то число не является "добативным".
	return false
}

func isValid(num string, i, j, k int) bool {
	/*
		TIME COMPLEXITY: O(n), где n - количество цифр в числе.
		Это связано с тем, что функция вызывается рекурсивно для каждого числа в последовательности, и каждый вызов функции требует некоторого времени для выполнения.
		SPACE COMPLEXITY: O(n), так как в худшем случае (когда все числа в последовательности являются "добативными") функция будет вызываться рекурсивно для каждого числа в последовательности,
		что приведет к использованию стека вызовов размером n. Однако, в реальности этот промежуток времени будет меньше, так как не все числа в последовательности будут "добативными".
	*/
	if k == len(num) {
		return true
	}
	// Проверяем, является ли следующее число суммой двух предыдущих
	num1, _ := strconv.Atoi(num[i:j])
	num2, _ := strconv.Atoi(num[j:k])
	sum := strconv.Itoa(num1 + num2)
	if k+len(sum) > len(num) || num[k:k+len(sum)] != sum {
		return false
	}
	// Рекурсивно проверяем следующее число
	return isValid(num, j, k, k+len(sum))
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	fmt.Println(isAdditiveNumber("112358"))    // true
	fmt.Println(isAdditiveNumber("199100199")) // true
	fmt.Println(isAdditiveNumber("123"))       // true
	fmt.Println(isAdditiveNumber("1023"))      // false
}
