package main

import (
	"sort"
)

// Функция для поиска тройки чисел, сумма которых ближе всего к заданному числу
func threeSumClosestV3(nums []int, target int) int {
	/*
		METHOD: Two pointers
		TIME COMPLEXITY: O(n^2), где n - количество элементов в массиве.
		Это обусловлено тем, что для каждого элемента мы проходим по оставшейся части массива с помощью двух указателей,
		что дает квадратичное время.
		SPACE COMPLEXITY: O(1), так как мы используем только несколько переменных для хранения промежуточных результатов,
		не зависящих от размера входных данных.
	*/
	// Сортируем массив
	sort.Ints(nums)

	// Инициализируем переменные для ответа и минимальной разницы
	ans := 0
	dist := int(^uint(0) >> 1) // dist = infinity

	// Итерируемся по массиву
	for i := 0; i < len(nums); i++ {
		// Инициализируем два указателя - один на следующий элемент, второй на конец массива
		l := i + 1
		r := len(nums) - 1

		// Итерируемся до тех пор, пока левый указатель не станет больше правого
		for l < r {
			// Вычисляем сумму текущей тройки чисел
			sum := nums[i] + nums[l] + nums[r]

			// Если сумма равна целевому значению, возвращаем ее
			if sum == target {
				return sum
			}

			// Если сумма меньше целевого значения, двигаем левый указатель вправо
			if sum < target {
				l = l + 1
				// Если разница между суммой и целевым значением меньше текущей минимальной разницы,
				// обновляем минимальную разницу и ответ
				if target-sum < dist {
					dist = target - sum
					ans = sum
				}
			} else {
				// Если сумма больше целевого значения, двигаем правый указатель влево
				r = r - 1
				// Если разница между суммой и целевым значением меньше текущей минимальной разницы,
				// обновляем минимальную разницу и ответ
				if sum-target < dist {
					dist = sum - target
					ans = sum
				}
			}
		}
	}

	// Возвращаем ближайшую к заданному числу сумму
	return ans
}

//func main() {
//	nums := []int{-1, 2, 1, -4}
//	target := 1
//	fmt.Println(threeSumClosestV3(nums, target)) // Выводит: 2
//}
