package main

// lowestCommonAncestor находит наименьшего общего предка двух узлов в бинарном дереве
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
	/*
		METHOD: Recursion
		- Если оба рекурсивных вызова (left и right) возвращают непустые узлы, это означает, что узлы p и q находятся по разные стороны от текущего узла.
		Следовательно, текущий узел является наименьшим общим предком.

		- Если только один из рекурсивных вызовов возвращает непустой узел, это означает, что узлы p и q находятся на одной стороне от текущего узла.
		В этом случае возвращаем непустой узел, так как он является кандидат.

		Этот подход эффективно использует свойства бинарного дерева и рекурсию для обхода узлов, позволяя нам определить наименьшего общего предка двух узлов.

		TIME COMPLEXITY: O(n), где n — количество узлов в дереве.
		Это происходит потому, что в худшем случае алгоритм должен обойти все узлы дерева.
		Каждый узел посещается один раз, поэтому временная сложность линейна относительно количества узлов.

		SPACE COMPLEXITY: (h), где h — высота дерева.
		Это связано с тем, что в худшем случае рекурсия может достичь глубины, равной высоте дерева.
		Каждая рекурсивная вызов добавляет новый уровень в стек вызовов, поэтому пространственная сложность зависит от высоты дерева.
		В случае сбалансированного дерева это будет O(log n), а в случае несбалансированного (например, списка) — O(n).
	*/
	// Базовый случай: если корень равен nil или совпадает с p или q, возвращаем корень
	if root == nil || root == p || root == q {
		return root
	}

	// Рекурсивно ищем LCA в левом поддереве
	left := lowestCommonAncestor(root.Left, p, q)
	// Рекурсивно ищем LCA в правом поддереве
	right := lowestCommonAncestor(root.Right, p, q)

	// Если оба left и right не равны nil, это означает, что p и q находятся по разные стороны от текущего узла
	// Следовательно, текущий узел является LCA
	if left != nil && right != nil {
		return root
	}

	// Если только один из left или right не равен nil, возвращаем этот непустой узел
	if left != nil {
		return left
	}

	return right
}
