package main

func findTargetSumWays(nums []int, target int) int {
	/*
		МЕТОД: Динамическое программирование
		ОПИСАНИЕ:
		- Используем динамическое программирование для решения задачи.
		- Создаем массив DP, где dp[i] представляет количество способов достичь суммы i - totalSum.
		- Проходим по каждому числу в массиве и обновляем массив DP, чтобы отразить возможные суммы, которые можно достичь, добавляя или вычитая текущее число.
		- В конце возвращаем значение dp[totalSum + target], которое представляет количество способов достичь целевой суммы target.

		TIME COMPLEXITY: O(n * sum), где n — количество элементов в массиве, а sum — максимально возможная сумма.
		Мы проходим по каждому элементу массива и для каждого элемента потенциально обновляем все записи в массиве DP.

		SPACE COMPLEXITY: O(sum), где sum — максимально возможная сумма.
		Используем массив размером 2 * totalSum + 1 для хранения количества способов достичь каждой возможной суммы.
	*/
	// Находим сумму всех элементов массива
	totalSum := 0
	for _, num := range nums {
		totalSum += num
	}

	// Если целевая сумма больше общей суммы или меньше отрицательной общей суммы,
	// то невозможно достичь целевой суммы
	if target > totalSum || target < -totalSum {
		return 0
	}

	// Создаем массив dp размером 2 * totalSum + 1
	// dp[i] будет представлять количество способов получить сумму i - totalSum
	// Допустим, totalSum равно 5. Тогда массив dp будет иметь размер 11:
	// Индекс:  0  1  2  3  4  5  6  7  8  9  10
	// Сумма:  -5 -4 -3 -2 -1  0  1  2  3  4  5
	dp := make([]int, 2*totalSum+1)

	// Инициализируем dp[totalSum] как 1, так как есть 1 способ получить сумму 0.
	// Посмотри выше, там totalSum := 0.
	dp[totalSum] = 1

	// Проходим по каждому элементу массива
	for _, num := range nums {
		// Создаем новый массив nextDp для обновления состояний
		nextDp := make([]int, 2*totalSum+1)
		for i := 0; i < len(dp); i++ {
			if dp[i] > 0 {
				// Обновляем nextDp с учетом текущего элемента num
				nextDp[i+num] += dp[i]
				nextDp[i-num] += dp[i]
			}
		}
		// Обновляем dp
		dp = nextDp
	}

	// Возвращаем количество способов получить целевую сумму target
	return dp[totalSum+target]
}
