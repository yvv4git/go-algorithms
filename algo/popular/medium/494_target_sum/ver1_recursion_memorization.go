package main

func findTargetSumWaysV2(nums []int, target int) int {
	/*
		МЕТОД: Рекурсия с возвратом & Memorization
		ОПИСАНИЕ:
		- Используем рекурсивный подход для решения задачи.
		- Для каждого элемента массива nums мы решаем две подзадачи:
		  - Добавляем текущий элемент к текущей сумме.
		  - Вычитаем текущий элемент из текущей суммы.
		- Рекурсивно вызываем функцию для следующего элемента массива.
		- Если мы достигли конца массива и текущая сумма равна целевой сумме, возвращаем 1, иначе 0.

		TIME COMPLEXITY: O(2^n), где n — количество элементов в массиве.
		- Каждый вызов функции порождает два новых вызова, что приводит к экспоненциальному росту количества операций.

		SPACE COMPLEXITY: O(n)
		- Глубина рекурсии может достигать n, что приводит к использованию стека вызовов глубиной n.
	*/
	var recursion func([]int, int, int) int
	recursion = func(nums []int, target int, currentIndex int) int {
		// Базовый случай: если текущий индекс выходит за пределы массива
		if currentIndex > len(nums)-1 {
			// Если текущая сумма равна целевой сумме, возвращаем 1, иначе 0
			if target == 0 {
				return 1
			}

			return 0
		}

		// Рекурсивный случай: вызываем функцию для двух подзадач
		// 1. Добавляем текущий элемент к текущей сумме
		// 2. Вычитаем текущий элемент из текущей суммы
		return recursion(nums, target-nums[currentIndex], currentIndex+1) + recursion(nums, target+nums[currentIndex], currentIndex+1)
	}

	// Запускаем рекурсивную функцию с начальными параметрами
	return recursion(nums, target, 0)
}
