package main

import "fmt"

// Функция rangeBitwiseAnd вычисляет побитовое И для всех чисел в диапазоне от m до n.
// Алгоритм основан на побитовом сдвиге и подсчете количества сдвигов.
func rangeBitwiseAnd(left int, right int) int {
	/*
		METHOD: Bitwise
		TIME COMPLEXITY: O(log right) операций, где right - наибольшее число в диапазоне.
		Это происходит потому, что внутри цикла выполняется побитовый сдвиг на 1 бит,
		который происходит log2(right) раз, так как каждый сдвиг уменьшает число вдвое.
		SPACE COMPLEXITY: O(1), так как используется фиксированное количество переменных, не зависящих от размера входных данных.

		Чтобы найти общие биты для всех чисел в диапазоне, нам нужно найти наибольший общий префикс для всех чисел в этом диапазоне.
		Это можно сделать, сдвигая биты чисел вправо до тех пор, пока они не станут равными.
		Количество сдвигов будет определять, насколько далеко справа находится наибольший общий префикс.

		Таким образом, алгоритм работает следующим образом:
		1. Инициализируем счетчик сдвигов (shift) равным 0.
		2. Пока m не равно n, выполняем цикл:
		2.1. Сдвигаем m и n вправо на 1 бит (эквивалентно делению на 2).
		2.2. Увеличиваем счетчик сдвигов на 1.
		3. Когда m становится равным n, это означает, что наибольший общий префикс для всех чисел в диапазоне найден.
		4. Возвращаем m, сдвинутое влево на количество сдвигов (эквивалентно умножению на 2 в степени shift).

		Таким образом, результатом будет число, которое содержит общие биты для всех чисел в заданном диапазоне,
		и все биты справа от наибольшего общего префикса будут установлены в ноль.
	*/
	// Инициализация счетчика сдвигов
	shift := 0

	// Пока left и right не равны, выполняем цикл
	for left != right {
		// Побитовый сдвиг left и right вправо на 1 бит
		left >>= 1
		right >>= 1

		// Увеличиваем счетчик сдвигов
		shift++
	}

	// Возвращаем результат побитового И, сдвинутого на shift разрядов влево
	return left << shift
}

func main() {
	m := 5
	n := 7
	result := rangeBitwiseAnd(m, n)
	fmt.Println(result) // Вывод: 4
}
