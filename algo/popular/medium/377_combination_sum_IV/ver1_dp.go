package main

import "fmt"

// combinationSum4 вычисляет количество комбинаций чисел из nums, которые в сумме дают target.
func combinationSum4(nums []int, target int) int {
	/*
		METHOD: Dynamic Programming
		Суть данного подхода заключается в использовании метода динамического программирования (Dynamic Programming, DP).
		Этот метод позволяет эффективно решать задачи, которые можно разбить на подзадачи, и результаты которых можно использовать для решения более сложных задач.

		TIME COMPLEXITY: O(target * n), где n — количество элементов в массиве nums.
		Мы проходим по всем значениям от 1 до target и для каждого значения проходим по всем числам в массиве nums.

		SPACE COMPLEXITY: O(target), так как мы используем массив dp размером target + 1 для хранения промежуточных результатов.
	*/
	// Создаем массив dp размером target + 1 и инициализируем его нулями&
	// Массив dp используется для хранения количества комбинаций, которые в сумме дают каждое целое число от 0 до target.
	// Это означает, что нам нужно место для хранения результатов для всех сумм от 0 до target, включая саму target.
	dp := make([]int, target+1)
	// Инициализируем dp[0] = 1, так как существует только одна комбинация (пустая), которая в сумме дает 0
	dp[0] = 1

	// Проходим по всем значениям от 1 до target
	for i := 1; i <= target; i++ {
		// Для каждого числа в массиве nums
		for _, num := range nums {
			// Если i - num >= 0, то добавляем dp[i - num] к dp[i]
			if i-num >= 0 {
				dp[i] += dp[i-num]
			}
		}
		fmt.Printf("[%d] dp=%v\n", i, dp)
	}

	// Возвращаем dp[target], которое содержит количество комбинаций, которые в сумме дают target
	return dp[target]
}

// Пример использования
func main() {
	nums := []int{1, 2, 3}
	target := 4
	result := combinationSum4(nums, target)
	println(result) // Вывод: 7
}
