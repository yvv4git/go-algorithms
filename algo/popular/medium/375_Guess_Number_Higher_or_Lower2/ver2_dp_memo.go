//go:build ignore

package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	in := bufio.NewReader(os.Stdin)

	// Читаем n из ввода.
	var n int
	fmt.Fscan(in, &n)

	// Инициализируем мемо-таблицу
	memo := make([][]int, n+2)
	for i := range memo {
		memo[i] = make([]int, n+2)
	}

	result := getMoneyAmountMemo(n, memo)
	fmt.Println(result)
}

func getMoneyAmountMemo(n int, memo [][]int) int {
	/*
		INTUITION:
		Нужно найти минимальную сумму денег, которая гарантирует победу
		в игре угадывания числа от 1 до n.

		Идея мемоизации: используем рекурсию с кэшированием результатов.
		Для каждого диапазона [i, j] вычисляем минимальную стоимость
		только один раз и сохраняем в мемо-таблице.

		APPROACH: Memoization (Top-Down DP)
		dp(i, j) — минимальная стоимость для гарантированной победы
		в диапазоне чисел от i до j (включительно).

		БАЗА:
		- dp(i, i) = 0 (если только одно число, его можно угадать бесплатно)
		- dp(i, i+1) = i (меньшее из двух чисел — оптимальная первая попытка)

		Переход:
		- Если результат уже в мемо-таблице — возвращаем его
		- Иначе вычисляем: для диапазона [i, j] пробуем каждое число k
		- Стоимость = k + max(dp(i, k-1), dp(k+1, j))
		- Выбираем минимум и сохраняем в мемо-таблице

		ПОЧЕМУ ТАК:
		- Если угадываем k и ошибаемся, платим k
		- Затем диапазон сужается до [i, k-1] или [k+1, j]
		- Нужно гарантировать победу в худшем случае,
		  поэтому берём максимум из двух ветвей

		TIME COMPLEXITY: O(n^3) — для каждого из O(n^2) состояний
		               перебираем O(n) возможных первых попыток
		SPACE COMPLEXITY: O(n^2) для мемо-таблицы + O(n) для стека вызовов
	*/

	// Рекурсивная функция с мемоизацией
	var dp func(i, j int) int
	dp = func(i, j int) int {
		// Базовый случай: диапазон пуст или одно число
		if i >= j {
			return 0
		}

		// Если уже вычисляли — м возвращаем иземо
		if memo[i][j] != 0 {
			return memo[i][j]
		}

		// Вычисляем минимальную стоимость для диапазона [i, j]
		minCost := int(^uint(0) >> 1) // максимальное int

		for k := i; k <= j; k++ {
			// Стоимость: платим k + стоимость худшего случая
			// (максимум из левой и правой части)
			cost := k + max(dp(i, k-1), dp(k+1, j))
			if cost < minCost {
				minCost = cost
			}
		}

		// Сохраняем в мемо-таблицу
		memo[i][j] = minCost
		return minCost
	}

	return dp(1, n)
}

// Вспомогательная функция: максимум двух чисел
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
