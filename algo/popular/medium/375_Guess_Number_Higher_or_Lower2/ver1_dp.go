//go:build ignore

package main

import (
	"bufio"
	"fmt"
	"math"
	"os"
)

func main() {
	in := bufio.NewReader(os.Stdin)

	// Читаем n из ввода.
	var n int
	fmt.Fscan(in, &n)

	result := getMoneyAmount(n)
	fmt.Println(result)
}

// n - верхняя граница диапазона чисел.
// Если n = 10, то надо угадать число от 1 до 10.
func getMoneyAmount(n int) int {
	/*
		INTUITION:
		Нужно найти минимальную сумму денег, которая гарантирует победу
		в игре угадывания числа от 1 до n.

		Идея DP: для каждого диапазона [i, j] находим минимальную стоимость,
		которая гарантирует победу в этом диапазоне.

		APPROACH: Dynamic Programming (двумерный массив)
		dp[i][j] — минимальная стоимость для гарантированной победы
		в диапазоне чисел от i до j (включительно).

		БАЗА:
		- dp[i][i] = 0 (если только одно число, его можно угадать бесплатно)
		- dp[i][i+1] = i (меньшее из двух чисел — оптимальная первая попытка)

		Переход:
		- Для диапазона [i, j] пробуем каждое число k как первую попытку
		- Стоимость = k + max(dp[i][k-1], dp[k+1][j])
		- Выбираем минимум среди всех k

		ПОЧЕМУ ТАК:
		- Если угадываем k и ошибаемся, платим k
		- Затем диапазон сужается до [i, k-1] или [k+1, j]
		- Нужно гарантировать победу в худшем случае,
		  поэтому берём максимум из двух ветвей

		TIME COMPLEXITY: O(n^3) — три вложенных цикла
		SPACE COMPLEXITY: O(n^2) для хранения dp-таблицы
	*/

	// Создаём двумерный массив dp размером (n+2) x (n+1)
	// Используем n+2 для удобства обработки граничных случаев
	dp := make([][]int, n+2)
	for i := range dp {
		dp[i] = make([]int, n+2)
	}

	// Заполняем таблицу для диапазонов возрастающей длины
	// length — длина текущего диапазона
	for length := 2; length <= n; length++ {
		// i — начало диапазона
		for i := 1; i <= n-length+1; i++ {
			// j — конец диапазона
			j := i + length - 1

			// Инициализируем как бесконечность
			dp[i][j] = math.MaxInt64

			// Пробуем каждое число k как первую попытку
			for k := i; k <= j; k++ {
				// Стоимость: платим k + стоимость худшего случая
				// (максимум из левой и правой части)
				cost := k + max(getOrZero(dp, i, k-1), getOrZero(dp, k+1, j))
				dp[i][j] = min(dp[i][j], cost)
			}
		}
	}

	// Ответ — минимальная стоимость для диапазона [1, n]
	return dp[1][n]
}

// Вспомогательная функция: возвращает 0 для недопустимых диапазонов
func getOrZero(dp [][]int, i, j int) int {
	if i > j {
		return 0
	}
	return dp[i][j]
}

// Вспомогательная функция: минимум двух чисел
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// Вспомогательная функция: максимум двух чисел
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
