package main

import "fmt"

// Функция для возведения числа в степень по модулю 1337
func superPow(a int, b []int) int {
	/*
		METHOD: Bitwise

		TIME COMPLEXITY: O(n), где n - количество элементов в массиве b, так как мы проходим по каждому элементу массива.

		SPACE COMPLEXITY: O(1), так как мы используем некоторые переменные для хранения промежуточных результатов,
		но не используем дополнительную память, зависящую от размера входных данных.
	*/
	// Базовый случай, когда степень равна 0
	if len(b) == 0 {
		return 1
	}

	// Извлекаем последнюю цифру из массива b
	lastDigit := b[len(b)-1]
	b = b[:len(b)-1] // Удаляем последнюю цифру из массива

	// Возводим число a в степень последней цифры и делим по модулю 1337
	part1 := powMod(a, lastDigit, 1337)

	// Возводим число a в степень 10 и делим по модулю 1337
	part2 := powMod(superPow(a, b), 10, 1337)

	// Возвращаем результат, взяв остаток от деления произведения part1 и part2 на 1337
	return (part1 * part2) % 1337
}

// Функция для возведения числа a в степень b по модулю mod
func powMod(a, b, mod int) int {
	// Инициализируем результат в 1
	result := 1
	// Приводим a к диапазону [0, mod), т.е. число будет неотрицательным и меньше mod.
	// Это нужно, чтобы избежать переполнения при умножении больших чисел.
	// Это также позволяет нам использовать более быстрый алгоритм быстрого возведения в степень,
	// так как мы уже работаем с меньшими числами.
	a %= mod

	// Пока степень b не равна 0
	for b != 0 {
		// Если последняя цифра в двоичном представлении b равна 1
		if b&1 != 0 {
			// Умножаем результат на a и взятие по модулю mod
			result = (result * a) % mod
		}
		// Возводим a в квадрат и взятие по модулю mod
		a = (a * a) % mod
		// Сдвигаем b вправо на 1 бит, эквивалентно делению на 2
		b >>= 1
	}

	return result
}
func main() {
	fmt.Println(superPow(2, []int{3}))    // должно вывести 8
	fmt.Println(superPow(2, []int{1, 0})) // должно вывести 1024
}
