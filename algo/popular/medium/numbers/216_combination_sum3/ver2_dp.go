package main

func combinationSum3V2(k int, n int) [][]int {
	/*
		METHOD: Dynamic programming

		TIME COMPLEXITY: O(n * k * 9^k), где n - заданная сумма, k - количество чисел в комбинации.
		Это обусловлено тем, что для каждой уникальной пары (сумма, количество чисел) мы проходим по всем возможным числам от 1 до 9,
		и для каждого числа мы можем вызвать рекурсивно combinationSum3V2, пока не достигнем базового случая.

		SPACE COMPLEXITY: O(n * k * x), где x - среднее количество комбинаций, которые мы можем получить для данной пары (сумма, количество чисел).
		Это обусловлено тем, что для каждой уникальной пары (сумма, количество чисел) мы сохраняем все возможные комбинации в матрице dp.
		Обратите внимание, что в худшем случае, когда мы можем получить все возможные комбинации (например, когда k = 9 и n = 45),
		временная и пространственная сложности могут стать очень высокими.
		Однако в среднем и в лучшем случае эти сложности будут меньше, чем в предыдущем алгоритме.
	*/
	dp := make([][][][]int, n+1)
	for i := range dp {
		dp[i] = make([][][]int, k+1)
	}
	dp[0][0] = [][]int{[]int{}} // Инициализация пустого срезе

	for i := 1; i <= n; i++ {
		for j := 1; j <= k; j++ {
			dp[i][j] = make([][]int, 0)
			for m := 1; m <= 9; m++ {
				if i-m >= 0 && len(dp[i-m][j-1]) > 0 {
					for _, comb := range dp[i-m][j-1] {
						if len(comb) > 0 && comb[len(comb)-1] >= m {
							continue
						}
						newComb := append([]int{}, comb...)
						newComb = append(newComb, m)
						dp[i][j] = append(dp[i][j], newComb)
					}
				}
			}
		}
	}

	return dp[n][k]
}

//
//func main() {
//	fmt.Println(combinationSum3(3, 7)) // Вывод: [[1 2 4]]
//}
