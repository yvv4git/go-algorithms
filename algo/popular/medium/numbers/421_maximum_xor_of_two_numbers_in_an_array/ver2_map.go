package _21_maximum_xor_of_two_numbers_in_an_array

func findMaximumXORV2(nums []int) int {
	/*
		METHOD: Map
		TIME COMPLEXITY: O(n) - так как для каждого бита мы проходим по всем числам.
		SPACE COMPLEXITY: O(n) - так как в хэш-таблице мы храним все числа из массива

		Алгоритм основан на идее, что для получения максимального XOR, надо поставить наиболее значимые биты в результат XOR.
	*/
	// Инициализируем переменную xor равной 0.
	xor := 0
	// Проходим по каждому биту числа от старшего бита (MSB) до младшего бита (LSB).
	for i := 31; i >= 0; i-- {
		// Создаем хэш-таблицу hash, в которой хранятся все числа из массива nums, где младшие биты равны текущему биту.
		hash := map[int]bool{}
		for _, v := range nums {
			// Устанавливаем младшие биты равными 0.
			hash[v>>i<<i] = true
		}
		// Пытаемся установить i-тый бит в 1.
		tryXOR := xor + 1<<i
		// Проверяем, существует ли число, XOR которого с tryXOR дает k.
		for k := range hash {
			if hash[k^tryXOR] {
				// Если такое число существует, то устанавливаем i-тый бит в 1 и переходим к следующему биту.
				xor = tryXOR
				break
			}
		}
	}

	// Возвращаем xor, который является максимальным XOR двух чисел в массиве.
	return xor
}
