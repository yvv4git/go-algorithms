package main

import "fmt"

// Функция countPrimes принимает целое число n и возвращает количество простых чисел, которые меньше n.
func countPrimes(n int) int {
	/*
		METHOD: Math / решето Эратосфена / the sieve of Eratosthenes

		TIME COMPLEXITY: O(n log n), где n - входное число. Это результат использования решета Эратосфена, который имеет сложность O(n log log n).

		SPACE COMPLEXITY: O(n), так как мы используем дополнительный булевый массив размера n для хранения информации о простых числах.
	*/
	// Если n меньше 2, то простых чисел нет.
	if n < 2 {
		return 0
	}

	// Создаем булевый массив длиной n, который будет использоваться для отметки чисел как простые или составные.
	// По умолчанию все числа считаются простыми.
	isPrime := make([]bool, n)
	for i := 2; i < n; i++ {
		isPrime[i] = true
	}

	// Проходим по всем числам от 2 до sqrt(n), т.к. все составные числа могут быть представлены в виде произведения двух простых чисел,
	// причём одно из них должно быть меньше или равно sqrt(n).
	for i := 2; i*i < n; i++ {
		// Если текущее число ещё не отмечено как составное, то отмечаем все его кратные.
		if isPrime[i] {
			for j := i * i; j < n; j += i {
				isPrime[j] = false
			}
		}
	}

	// Подсчитываем количество простых чисел.
	count := 0
	for i := 2; i < n; i++ {
		if isPrime[i] {
			count++
		}
	}

	return count
}

func main() {
	n := 10
	fmt.Println(countPrimes(n)) // Выводит: 4
}
