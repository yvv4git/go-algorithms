package _2_reverse_linked_list_II

func reverseBetweenV1(head *ListNode, left int, right int) *ListNode {
	/*
		METHOD: Two pointers.
		Time complexity: O(n).
		Space complexity: O(1).

		В начале функции мы проходим по всему списку до узла left, что занимает O(n) времени.
		Затем мы проходим по всему списку от узла left до узла right, меняя указатели next, что также занимает O(n) времени.

		Таким образом, в худшем случае, когда left и right близки к концу списка,
		время выполнения алгоритма будет пропорционально количеству узлов в списке.

		Обратите внимание, что этот алгоритм можно оптимизировать, если известно, что left и right близки к началу списка,
		поскольку в этом случае время выполнения будет меньше, чем O(n). Однако, в общем случае, сложность остается O(n).
	*/

	// Из условия задачи, надо найти такие left <= right.
	if head == nil || left == right {
		return head
	}

	// Cоздадим фиктивный узел, который используется для упрощения алгоритма.
	// Фиктивный узел всегда находится перед узлом, который нужно начать реверсирование.
	dummy := &ListNode{0, head}
	prev := dummy // Установим указатель на фиктивный узел.

	// Это цикл, который перемещает указатель prev на узел, который предшествует узлу, который нужно начать реверсирование.
	for i := 0; i < left-1; i++ {
		prev = prev.Next
	}
	//fmt.Printf("PREV: %v \n", prev.Val)

	current := prev.Next

	// В этом цикле мы переставляем узлы в подсписке так, чтобы они были в обратном порядке.
	for i := 0; i < right-left; i++ {
		nextNode := current.Next
		current.Next = nextNode.Next
		nextNode.Next = prev.Next
		prev.Next = nextNode
	}

	// В конце функции мы возвращаем узел, следующий за фиктивным узлом.
	// Это связное начало списка, так как фиктивный узел всегда находится перед первым узлом списка.
	return dummy.Next
}
