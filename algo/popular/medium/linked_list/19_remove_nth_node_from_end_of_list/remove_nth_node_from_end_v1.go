package main

func removeNthFromEndV1(head *ListNode, n int) *ListNode {
	/*
		Method: Two pointer / "Два прохода"
		Time complexity: O(n), где n - число узлов
		Space complexity: O(1)

		В этом алгоритме мы используем два указателя, которые начинают с одного узла.
		Затем мы перемещаем первый указатель на n+1 шагов вперед. Это делает разрыв между первым и вторым указателем равным n узлам.
		Затем мы перемещаем оба указателя вместе до тех пор, пока первый указатель не достигнет конца списка.
		В этот момент второй указатель будет на узле перед узлом, который мы хотим удалить.
		Затем мы просто изменяем указатель Next второго узла, чтобы он пропускал узел, который находится на n-м месте с конца списка.
		Этот алгоритм работает, потому что он создает разрыв между первым и вторым указателем, который равен n узлам.
		Когда первый указатель достигает конца списка, второй указатель находится на узле перед узлом, который мы хотим удалить.
		Изменяя указатель Next второго узла, мы удаляем узел, который находится на n-м месте с конца списка.

		Этот метод используется для решения задач, когда нужно найти элемент в связном списке,
		который находится на определенной позиции от конца списка.

		В данном алгоритме два указателя first и second используются для создания "отступа" между ними, равного n узлам.
		Начальное положение обоих указателей - фиктивный узел dummy.

		1. Первый указатель first перемещается на n+1 узлов вперед.
		Это делается для того, чтобы создать "отступ" между first и second, равный n узлам.

		2. Затем оба указателя перемещаются одновременно до тех пор, пока первый указатель не достигнет конца списка.
		Это гарантирует, что когда первый указатель достигнет конца списка, второй указатель будет на n узлах от конца списка.

		3. После того, как оба указателя достигнут нужной позиции, второй указатель используется для удаления узла,
		следующего за ним.

		Наконец, возвращается голова списка.
		Таким образом, этот алгоритм позволяет удалить n-й узел с конца списка за один проход.
	*/
	dummy := &ListNode{0, head}
	first := dummy
	second := dummy

	// Move first in front so that the gap between first and second is n nodes apart
	for i := 1; i <= n+1; i++ {
		first = first.Next
	}

	// Move first to the end, maintaining the gap
	for first != nil {
		first = first.Next
		second = second.Next
	}

	second.Next = second.Next.Next

	return dummy.Next
}
