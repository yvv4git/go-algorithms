package main

import "fmt"

func validUtf8(data []int) bool {
	/*
		METHOD: Bitwise
		Используется побитовый анализ для определения типа символа UTF-8 и проверки корректности последовательности байтов.
		Проходим по каждому байту и определяем, является ли он началом нового символа или продолжающим байтом.

		TIME COMPLEXITY:
		O(n), где n — количество байтов в массиве data. Мы проходим по каждому байту ровно один раз.

		SPACE COMPLEXITY:
		O(1), так как используется только константное количество дополнительной памяти (переменная remainingBytes).
	*/
	// Количество оставшихся байтов для текущего символа UTF-8
	remainingBytes := 0

	// Проходим по каждому байту в массиве
	for _, byteValue := range data {
		if remainingBytes == 0 {
			// Определяем количество байтов для текущего символа UTF-8
			if byteValue&0b10000000 == 0 {
				// Одно-байтовый символ
				remainingBytes = 0
			} else if byteValue&0b11100000 == 0b11000000 {
				// Двух-байтовый символ
				remainingBytes = 1
			} else if byteValue&0b11110000 == 0b11100000 {
				// Трех-байтовый символ
				remainingBytes = 2
			} else if byteValue&0b11111000 == 0b11110000 {
				// Четырех-байтовый символ
				remainingBytes = 3
			} else {
				// Некорректный первый байт
				return false
			}
		} else {
			// Проверяем, что текущий байт является продолжающим байтом
			if byteValue&0b11000000 != 0b10000000 {
				return false
			}
			// Уменьшаем количество оставшихся байтов
			remainingBytes--
		}
	}

	// Если remainingBytes == 0, значит все символы корректны
	return remainingBytes == 0
}

func main() {
	// Примеры данных для проверки
	//testCases := []struct {
	//	data []int
	//	desc string
	//}{
	//	{[]int{0b00000000}, "Одно-байтовый символ"},
	//	{[]int{0b11000000, 0b10000000}, "Двух-байтовый символ"},
	//	{[]int{0b11100000, 0b10000000, 0b10000000}, "Трех-байтовый символ"},
	//	{[]int{0b11110000, 0b10000000, 0b10000000, 0b10000000}, "Четырех-байтовый символ"},
	//	{[]int{0b10000000}, "Некорректный одно-байтовый символ"},
	//	{[]int{0b11100000, 0b10000000, 0b00000000}, "Некорректный трех-байтовый символ"},
	//	{[]int{0b11110000, 0b10000000, 0b10000000, 0b11000000}, "Некорректный четырех-байтовый символ"},
	//}

	testCases := []struct {
		data []int
		desc string
	}{
		{[]int{0x00}, "Одно-байтовый символ: NUL"},
		{[]int{0xC2, 0xA9}, "Двух-байтовый символ: ©"},
		{[]int{0xE2, 0x82, 0xAC}, "Трех-байтовый символ: €"},
		{[]int{0xF0, 0x9F, 0x98, 0x81}, "Четырех-байтовый символ: 😁"},
		{[]int{0x80}, "Некорректный одно-байтовый символ"},
		{[]int{0xE0, 0x80, 0x80}, "Некорректный трех-байтовый символ"},
		{[]int{0xF0, 0x80, 0x80, 0x80}, "Некорректный четырех-байтовый символ"},
	}

	for _, tc := range testCases {
		result := validUtf8(tc.data)
		fmt.Printf("%s: %v -> %t\n", tc.desc, tc.data, result)
	}
}
