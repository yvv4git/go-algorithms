package _5_3sum

import "sort"

func threeSumV4(nums []int) [][]int {
	/*
		Method: Sort & two pointer.
		Time complexity: O(n^2) ??? Я думаю, что O(n log n)
		Space complexity: O(1)

		Этот код сортирует массив, а затем использует два указателя (l, r) для нахождения троек, сумма которых равна нулю.
		Если сумма меньше нуля, то увеличиваем левый указатель, если сумма больше нуля, то уменьшаем правый указатель.
		Если сумма равна нулю, то мы нашли одну из троек.

		Сложность алгоритма для этой задачи составляет O(n^2), где n - количество элементов в массиве.

		Почему O(n^2)?
		1. Сортировка массива занимает O(n log n) времени.
		2. Для каждого элемента в массиве мы используем два указателя, что дает O(n) операций.
		3. Внутри этих операций мы используем бинарный поиск, что также дает O(n log n) времени.
		4. Таким образом, мы получаем O(n log n) + O(n) * O(n log n) = O(n^2).

		Обратите внимание, что это не учитывает дополнительную память, которую использует алгоритм для хранения результатов.
		Этот алгоритм использует O(n) дополнительной памяти для хранения результатов.
	*/
	sort.Ints(nums) // O(n log n)
	result := [][]int{}
	for i := 0; i < len(nums)-2; i++ {
		if i > 0 && nums[i] == nums[i-1] { // Проверяем, что нет повторяющихся элементов
			continue
		}

		l, r := i+1, len(nums)-1 // O(n) используем 2 указателя
		for l < r {
			s := nums[i] + nums[l] + nums[r]
			if s < 0 {
				l++
			} else if s > 0 {
				r--
			} else {
				result = append(result, []int{nums[i], nums[l], nums[r]})
				for l < r && nums[l] == nums[l+1] {
					l++
				}
				for l < r && nums[r] == nums[r-1] {
					r--
				}
				l++
				r--
			}
		}
	}
	return result
}
