package _09_minimum_size_subarray_sum

// Функция minSubArrayLen использует два указателя для нахождения минимальной длины подмассива, сумма элементов которого не меньше target.
// Если такой подмассив найден, функция возвращает его длину.
// Если такого подмассива не найдено, функция возвращает 0.
func minSubArrayLenV1(target int, nums []int) int {
	/*
		METHOD: Two pointers
		TIME COMPLEXITY: O(n)
		Space complexity: O(1)

		Time complexity
		Временная сложность этого решения составляет O(n), где n - количество элементов в массиве.
		Это связано с тем, что мы проходим по всем элементам в массиве только один раз.

		Space complexity
		Пространственная сложность составляет O(1), поскольку мы используем только несколько переменных для хранения индексов,
		суммы и минимальной длины подмассива.
	*/
	// Инициализируем переменные для хранения минимальной длины подмассива и текущей суммы.
	minLen := len(nums) + 1
	curSum := 0

	// Инициализируем два указателя: start и end.
	start, end := 0, 0

	// Проходим по всем элементам в массиве.
	for end < len(nums) {
		// Добавляем текущий элемент к текущей сумме.
		curSum += nums[end]

		// Если текущая сумма не меньше target, то мы можем уменьшить подмассив,
		// увеличив start.
		for curSum >= target {
			// Обновляем минимальную длину подмассива.
			minLen = min(minLen, end-start+1)

			// Уменьшаем текущую сумму на nums[start].
			curSum -= nums[start]

			// Увеличиваем start.
			start++
		}

		// Увеличиваем end.
		end++
	}

	// Если минимальная длина подмассива не изменилась, то такого подмассива не существует,
	// поэтому мы возвращаем 0.
	if minLen == len(nums)+1 {
		return 0
	}

	// Возвращаем минимальную длину подмассива.
	return minLen
}

// Функция min возвращает меньшее из двух чисел.
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
