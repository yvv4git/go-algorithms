package main

import (
	"sort"
)

func removeDuplicatesV3(nums []int) int {
	/*
		METHOD: Sorting
		Обратите внимание, что этот подход изменяет исходный массив, так как мы сортируем его.
		Если необходимо сохранить исходный порядок, то нужно будет создать копию массива перед сортировкой или использовать другой подход,
		который не изменяет исходный массив.

		TIME COMPLEXITY: O(n log n) из-за сортировки, где n - количество элементов в массиве.

		SPACE COMPLEXITY: O(1) или O(n), так как мы можем использовать дополнительную память для сортировки или модифицировать массив на месте,
		если используется сортировка без дополнительной памяти.
	*/
	n := len(nums)
	if n <= 2 {
		return n
	}

	// Сортируем массив
	sort.Ints(nums)

	// Инициализируем два указателя: i - для прохода по массиву, j - для отслеживания позиции, куда можно поместить следующий уникальный элемент
	i, j := 2, 2

	// Проходим по массиву, начиная со второго элемента
	for i < n {
		// Если текущий элемент не равен предыдущему элементу, который мы уже поместили в массив (два элемента назад)
		if nums[i] != nums[j-2] {
			// Помещаем текущий элемент в позицию j и увеличиваем оба указателя
			nums[j] = nums[i]
			j++
		}
		i++
	}

	// Возвращаем новую длину массива
	return j
}

//func main() {
//	nums := []int{1, 1, 1, 2, 2, 3}
//	newLength := removeDuplicates(nums)
//	fmt.Println("Новая длина массива:", newLength)
//	fmt.Println("Массив после удаления дубликатов:", nums[:newLength])
//}
