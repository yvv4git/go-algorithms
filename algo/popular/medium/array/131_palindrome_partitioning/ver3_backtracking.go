package _31_palindrome_partitioning

func partitionV3(s string) [][]string {
	/*
		METHOD: Backtracking
		Time complexity: O(n * 2^n)
		Space complexity: O(n * 2^n)

		Time complexity
		Временная сложность этого алгоритма составляет O(n * 2^n), где n - длина входной строки.
		Это связано с тем, что для каждого символа в строке мы можем делить ее на две части, и для каждой такой деления мы можем делать рекурсивный вызов.

		Space complexity
		Пространственная сложность также составляет O(n * 2^n), так как в худшем случае мы можем иметь 2^n разбиений строки,
		и для каждого разбиения мы можем иметь n элементов в стеке вызовов.

		Backtracking - это алгоритмический подход, который используется для решения задач, которые могут быть разделены на несколько подзадач.
		В этом подходе мы пытаемся построить решение, проверяя каждый шаг на правильность.
		Если мы обнаружим, что текущий шаг не ведет к решению, мы откатываемся (backtrack) и пытаемся другой вариант.

		Backtracking используется в различных алгоритмах, таких как поиск в глубину (DFS), поиск в ширину (BFS), динамическое программирование, и других.

		В вашем случае, backtracking используется для разделения входной строки на палиндромы.
		Мы проверяем каждый префикс строки на палиндромность, и если он палиндром, то мы продолжаем с остатком строки.
		Если мы обнаружим, что текущий префикс не может быть разбит на палиндромы, мы откатываемся и пробуем другой префикс.
	*/
	// result - результирующий список, в котором хранятся все возможные разбиения на палиндромы.
	result := [][]string{}

	// dfs - вспомогательная функция, которая рекурсивно проходит по всем возможным разбиениям.
	var dfsFoo func(state []string, s string)
	dfsFoo = func(state []string, s string) {
		// Если строка пуста, то мы нашли одно из возможных разбиений.
		if s == "" {
			// Создаем копию текущего состояния, чтобы не изменять исходное состояние.
			cpy := make([]string, len(state))
			copy(cpy, state)
			result = append(result, cpy)
			return
		}

		// Проходим по всем возможным подстрокам, начиная с первого символа.
		for i := 0; i < len(s); i++ {
			// Если подстрока является палиндромом, то добавляем ее в текущее состояние.
			if substr := s[:i+1]; checkPalindrome(substr, 0, len(substr)-1) {
				state = append(state, substr)
				// Рекурсивно продолжаем поиск с оставшейся строкой.
				dfsFoo(state, s[i+1:])
				// Возвращаем состояние назад, чтобы продолжить поиск других возможных разбиений.
				state = state[:len(state)-1]
			}
		}

	}
	dfsFoo([]string{}, s)

	return result
}

// Функция checkPalindrome проверяет, является ли строка палиндромом.
func checkPalindrome(s string, l, r int) bool {
	for l < r {
		// Если символы не равны, то строка не является палиндромом.
		if s[l] != s[r] {
			return false
		}

		// Переходим к следующим символам.
		l += 1
		r -= 1
	}
	// Если мы дошли до этой точки, то строка является палиндромом.
	return true
}
