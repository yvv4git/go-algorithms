package main

func rob(nums []int) int {
	/*
		METHOD: Dynamic programming
		TIME COMPLEXITY: O(n), где n - количество домов, так как мы проходим по каждому дому только один раз.
		Space complexity: O(n), так как мы используем дополнительный массив dp размера n.
	*/
	n := len(nums)

	// Если нет домов, то мы не можем взять ни одного дома
	if n == 0 {
		return 0
	}

	// Если только один дом, то мы можем взять его
	if n == 1 {
		return nums[0]
	}

	// Создаем массив dp и инициализируем первые два значения
	dp := make([]int, n)
	dp[0] = nums[0]
	dp[1] = max(nums[0], nums[1])

	// Заполняем dp
	for i := 2; i < n; i++ {
		// Максимальная сумма для текущего дома - это максимум между:
		// 1. Максимальная сумма для предыдущего дома (не взяли текущий)
		// 2. Сумма текущего дома и максимальная сумма для дома перед предыдущим (взяли текущий)
		dp[i] = max(dp[i-1], nums[i]+dp[i-2])
	}

	// Максимальная сумма - это последний элемент в dp
	return dp[n-1]
}

// Функция для нахождения максимума из двух чисел
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
