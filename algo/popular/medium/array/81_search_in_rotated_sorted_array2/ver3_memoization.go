package main

import "sort"

// Функция для поиска элемента в массиве с помощью бинарного поиска
// nums - входной массив целых чисел
// target - цель, которую нужно найти в массиве
// Функция возвращает true, если цель найдена, и false в противном случае
func searchV3(nums []int, target int) bool {
	/*
		METHOD: Memoization

		TIME COMPLEXITY: O(n log n) в худшем случае, когда мы сортируем массив, и O(log n) в лучшем случае, когда цель находится на первой попытке.

		SPACE COMPLEXITY: O(n) для хранения отсортированного массива и O(1) для переменных, не зависящих от размера входных данных.
	*/
	// Создаем копию входного массива и сортируем его
	ordered := append([]int{}, nums...)
	sort.Ints(ordered)

	// Инициализируем начальный и конечный индексы для бинарного поиска
	init := 0
	end := len(ordered) - 1

	// Создаем карту для отслеживания посещенных элементов
	memo := make(map[int]int)

	// Запускаем бесконечный цикл бинарного поиска
	for {
		// Вычисляем середину текущего диапазона
		mid := (end + init) / 2

		// Проверяем, был ли этот индекс уже посещен
		if _, ok := memo[mid]; ok {
			// Если индекс уже посещен, возвращаем false
			return false
		} else {
			// Если индекс еще не посещался, добавляем его в карту
			memo[mid] = 0
		}

		// Проверяем, равен ли элемент по середине цели
		if ordered[mid] == target {
			// Если цель найдена, возвращаем true
			return true
		} else if ordered[mid] < target {
			// Если элемент по середине меньше цели, ищем в правой половине
			init = mid + 1
		} else {
			// Если элемент по середине больше цели, ищем в левой половине
			end = mid - 1
		}
	}
}
