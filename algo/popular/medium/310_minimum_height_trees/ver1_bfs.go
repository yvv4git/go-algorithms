package main

import "fmt"

// Функция для поиска корней минимальных высотных деревьев.
// В задаче нужно реализовать функцию, которая находит корни минимальных высотных деревьев в графе.
// Минимальное высотное дерево - это дерево, в котором все листья находятся на одном уровне, а высота дерева минимальна.
// Функция должна принимать два параметра:
// n - количество вершин в графе.
// edges - список ребер в графе, представленный в виде двумерного массива, где каждый элемент представляет собой пару вершин, соединенных ребром.
// Функция должна возвращать список корней минимальных высотных деревьев.
// Если в графе только одна вершина, то она является корнем и функция должна вернуть ее.
func findMinHeightTrees(n int, edges [][]int) []int {
	/*
		METHOD: BFS
		Для решения задачи на Go мы будем использовать подход, основанный на поиске в ширину (BFS).
		В этом подходе мы будем удалять листья (вершины, имеющие только одно ребро) по одному, пока не останется менее двух вершин.
		Оставшиеся вершины будут корнями минимальных высотных деревьев.
		В этом коде мы сначала создаем список смежности для каждой вершины на основе входных ребер.
		Затем мы находим все листья в графе и удаляем их, пока не останется менее двух вершин.
		Оставшиеся вершины являются корнями минимальных высотных деревьев.

		TIME COMPLEXITY: O(n), где n - количество вершин в графе, так как мы проходим по всем вершинам не более двух раз:
		при первом проходе находим все листья, а при втором - корни минимальных высотных деревьев.

		SPACE COMPLEXITY: O(n), так как мы храним список смежности для каждой вершины и список вершин, которые являются листьями.
	*/
	// Если в графе только одна вершина, она является корнем
	if n == 1 {
		return []int{0}
	}

	// Создаем список смежности для каждой вершины
	adjList := make([][]int, n)
	for _, edge := range edges {
		adjList[edge[0]] = append(adjList[edge[0]], edge[1])
		adjList[edge[1]] = append(adjList[edge[1]], edge[0])
	}

	// Инициализируем список вершин, которые являются листьями
	leaves := make([]int, 0)
	for i := 0; i < n; i++ {
		if len(adjList[i]) == 1 {
			leaves = append(leaves, i)
		}
	}

	// Пока в графе больше двух вершин
	for n > 2 {
		newLeaves := make([]int, 0)
		// Удаляем каждую листовую вершину и добавляем в список новых листьев
		// те вершины, которые стали листовыми после удаления предыдущих листьев
		for _, leaf := range leaves {
			neighbor := adjList[leaf][0]
			// Удаляем листовую вершину из списка смежности соседа
			for i, node := range adjList[neighbor] {
				if node == leaf {
					adjList[neighbor] = append(adjList[neighbor][:i], adjList[neighbor][i+1:]...)
					break
				}
			}
			// Если сосед стал листовой вершиной после удаления, добавляем его в список новых листьев
			if len(adjList[neighbor]) == 1 {
				newLeaves = append(newLeaves, neighbor)
			}
			n--
		}
		leaves = newLeaves
	}

	// Оставшиеся вершины в списке листьев являются корнями минимальных высотных деревьев
	return leaves
}

func main() {
	n := 6
	edges := [][]int{{3, 0}, {3, 1}, {3, 2}, {3, 4}, {5, 4}}
	fmt.Println(findMinHeightTrees(n, edges)) // Вывод: [3 4]
}
