package main

import (
	"fmt"
	"math"
)

func numSquares(n int) int {
	/*
		METHOD: Dynamic programming
		Подход, которым решена задача, называется динамическое программирование.
		Этот метод заключается в разбиении сложной задачи на более простые подзадачи и решении каждой из них только один раз,
		сохраняя результаты для дальнейшего использования. В данном случае,
		мы использовали массив dp для хранения минимального количества полных квадратов,
		необходимых для получения каждого числа от 1 до n, что позволило нам эффективно решить задачу.

		TIME COMPLEXITY: O(n * sqrt(n))
		- Внешний цикл выполняется n раз.
		- Внутренний цикл выполняется sqrt(i) раз для каждого i.
		В итоге, временная сложность составляет O(n * sqrt(i)).

		SPACE COMPLEXITY: O(n)
		- Мы используем массив dp размером n + 1.
		В итоге, пространственная сложность составляет O(n).
	*/
	// Создаем массив dp, где dp[i] будет хранить минимальное количество полных квадратов, необходимых для получения числа i
	dp := make([]int, n+1)

	// Инициализируем dp[0] как 0, так как для получения числа 0 не требуется ни одного квадрата
	dp[0] = 0

	// Заполняем массив dp для всех чисел от 1 до n
	for i := 1; i <= n; i++ {
		// Инициализируем dp[i] максимальным значением, так как мы будем искать минимум
		dp[i] = math.MaxInt32

		// Проверяем все полные квадраты, которые меньше или равны i
		for j := 1; j*j <= i; j++ {
			// Обновляем dp[i] как минимум из текущего значения dp[i] и dp[i - j*j] + 1
			dp[i] = min(dp[i], dp[i-j*j]+1)
		}
	}

	// Возвращаем dp[n], которое содержит минимальное количество полных квадратов, необходимых для получения числа n
	return dp[n]
}

// Вспомогательная функция для нахождения минимума двух чисел
func min(a, b int) int {
	if a < b {
		return a
	}

	return b
}

func main() {
	n := 12
	fmt.Println(numSquares(n)) // Вывод: 3

	n = 13
	fmt.Println(numSquares(n)) // Вывод: 2
}
