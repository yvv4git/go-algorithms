package main

import (
	"fmt"
)

// Функция для вычисления максимального произведения длин слов
func maxProduct(words []string) int {
	/*
		METHOD: Bit mask
		Использование битовых масок позволяет эффективно проверять наличие общих букв между словами,
		что уменьшает временную сложность по сравнению с прямым сравнением каждой буквы в словах.

		Каждое слово представляется в виде битовой маски, где каждый бит соответствует наличию определенной буквы в слове.
		Например, если слово содержит букву 'a', то первый бит будет установлен в 1.
		Для проверки, что два слова не имеют общих букв, используется побитовое И между их битовыми масками.
		Если результат равен 0, то слова не имеют общих букв.
		Если слова не имеют общих букв, вычисляется произведение их длин и обновляется максимальное значение,
		если текущее произведение больше.

		TIME COMPLEXITY: O(n^2 * L), где n — количество слов, а L — средняя длина слова.
		Это связано с тем, что мы перебираем все пары слов и для каждой пары проверяем наличие общих букв.

		SPACE COMPLEXITY: O(n), где n — количество слов.
		Это связано с тем, что мы храним массив битовых масок для каждого слова.
	*/
	n := len(words)
	// Создаем массив битовых масок для каждого слова
	bitmasks := make([]int, n)

	// Заполняем массив битовых масок
	for i, word := range words {
		for _, char := range word {
			bitmasks[i] |= 1 << (char - 'a')
		}
	}

	maxProd := 0
	// Перебираем все пары слов
	for i := 0; i < n; i++ {
		for j := i + 1; j < n; j++ {
			// Проверяем, что слова не имеют общих букв
			if bitmasks[i]&bitmasks[j] == 0 {
				// Вычисляем произведение длин слов
				prod := len(words[i]) * len(words[j])
				if prod > maxProd {
					maxProd = prod
				}
			}
		}
	}

	return maxProd
}

func main() {
	words := []string{"abcw", "baz", "foo", "bar", "xtfn", "abcdef"}
	fmt.Println(maxProduct(words)) // Output: 16
}
