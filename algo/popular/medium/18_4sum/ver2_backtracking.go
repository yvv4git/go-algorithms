package main

import (
	"sort"
)

// Функция fourSumV2 решает задачу "4Sum" с помощью рекурсивного подхода с отсечениями.
func fourSumV2(nums []int, target int) [][]int {
	// Сортируем массив, чтобы упростить поиск.
	sort.Ints(nums)
	// Вызываем функцию kSum, которая рекурсивно решает задачу для k чисел.
	return kSum(nums, target, 0, 4)
}

// Функция kSum рекурсивно решает задачу для k чисел.
func kSum(nums []int, target, start, k int) [][]int {
	// Создаем пустой срез для хранения результатов.
	res := make([][]int, 0)
	// Базовые случаи:
	// 1. Если начальный индекс равен длине массива, то возвращаем пустой срез.
	// 2. Если произведение текущего числа на k больше целевого значения,
	//    или целевое значение больше, чем произведение последнего числа на k,
	//    то возвращаем пустой срез.
	if start == len(nums) || nums[start]*k > target || target > nums[len(nums)-1]*k {
		return res
	}
	// Если k равно 2, то решаем задачу двух сумм.
	if k == 2 {
		return twoSum(nums, target, start)
	}
	// Проходим по всем числам, начиная с start.
	for i := start; i < len(nums); i++ {
		// Пропускаем повторяющиеся элементы.
		if i == start || nums[i-1] != nums[i] {
			// Рекурсивно вызываем kSum для оставшихся чисел.
			for _, set := range kSum(nums, target-nums[i], i+1, k-1) {
				// Добавляем текущее число к каждому найденному набору.
				temp := []int{nums[i]}
				res = append(res, append(temp, set...))
			}
		}
	}
	// Возвращаем срез всех найденных наборов.
	return res
}

// Функция twoSum решает задачу двух сумм.
func twoSum(nums []int, target, start int) [][]int {
	// Создаем пустой срез для хранения результатов.
	res := make([][]int, 0)
	// Инициализируем два указателя: lo и hi.
	lo, hi := start, len(nums)-1
	// Пока lo меньше hi, двигаем указатели.
	for lo < hi {
		// Вычисляем сумму двух чисел по текущим указателям.
		sum := nums[lo] + nums[hi]
		// Если сумма меньше целевого значения, двигаем lo вправо.
		// Пропускаем повторяющиеся элементы.
		if sum < target || (lo > start && nums[lo] == nums[lo-1]) {
			lo++
		} else if sum > target || (hi < len(nums)-1 && nums[hi] == nums[hi+1]) {
			// Если сумма больше целевого значения, двигаем hi влево.
			// Пропускаем повторяющиеся элементы.
			hi--
		} else {
			// Если сумма равна целевому значению, добавляем пару в результат.
			res = append(res, []int{nums[lo], nums[hi]})
			// Двигаем оба указателя.
			lo++
			hi--
		}
	}
	// Возвращаем срез всех найденных пар.
	return res
}

//func main() {
//	nums := []int{1, 0, -1, 0, -2, 2}
//	target := 0
//	fmt.Println(fourSum(nums, target)) // Вывод: [[-2 -1 1 2] [-2 0 0 2] [-1 0 0 1]]
//}
