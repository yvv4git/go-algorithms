package main

import (
	"fmt"
)

// TASK: Дан массив положительных целых чисел nums. Определить, можно ли разделить массив на два подмножества
// с равной суммой элементов.
func canPartition(nums []int) bool {
	/*
	   APPROACH: Dynamic Programming (0/1 Knapsack)
	   1. Вычисляем сумму всех элементов массива. Если сумма нечетная, разделение невозможно.
	   2. Цель — найти подмножество с суммой, равной половине общей суммы (target = sum/2).
	   3. Используем динамическое программирование с булевым массивом dp, где dp[i] означает,
	      можно ли составить сумму i из элементов массива.
	   4. Для каждого числа nums[j] обновляем dp[i] для всех i от target до nums[j].
	   5. Если dp[target] равно true, разделение возможно.

	   TIME COMPLEXITY: O(n * target)
	   - n — длина массива nums.
	   - target — половина суммы элементов массива.
	   - Для каждого числа проходим по суммам от target до nums[j], обновляя dp.
	   - Итоговая сложность O(n * target).

	   SPACE COMPLEXITY: O(target)
	   - Используем массив dp размером target+1 для хранения промежуточных результатов.
	   - Остальные переменные занимают O(1) памяти.
	   - Итоговая сложность O(target).
	*/

	// Вычисляем сумму всех элементов
	sum := 0
	for _, num := range nums {
		sum += num
	}

	// Если сумма нечетная, разделение невозможно
	if sum%2 != 0 {
		return false
	}

	// Целевая сумма для одного подмножества
	target := sum / 2

	// Создаем массив dp для хранения возможности составления сумм
	dp := make([]bool, target+1)
	dp[0] = true // Сумма 0 всегда достижима (пустое подмножество)

	// Проходим по каждому числу в массиве
	for _, num := range nums {
		// Обновляем dp в обратном порядке, чтобы избежать повторного использования текущего числа
		for i := target; i >= num; i-- {
			dp[i] = dp[i] || dp[i-num]
		}
	}

	// Возвращаем, можно ли составить сумму target
	return dp[target]
}

func main() {
	// Тестовые случаи
	testCases := []struct {
		nums     []int
		expected bool
	}{
		{[]int{1, 5, 11, 5}, true}, // Можно разделить на [1,5,5] и [11], сумма = 11
		{[]int{1, 2, 3, 5}, false}, // Нельзя разделить на подмножества с равной суммой
		{[]int{2, 2, 3, 5}, false}, // Нельзя разделить на подмножества с равной суммой
		{[]int{1, 1}, true},        // Можно разделить на [1] и [1], сумма = 1
		{[]int{100}, false},        // Нельзя разделить одно число
	}

	// Запускаем тесты
	for i, tc := range testCases {
		result := canPartition(tc.nums)
		fmt.Printf("Тест %d: nums=%v, Ожидаемый результат=%v, Полученный результат=%v\n",
			i+1, tc.nums, tc.expected, result)
		if result == tc.expected {
			fmt.Println("Тест пройден успешно!")
		} else {
			fmt.Println("Тест не пройден!")
		}
	}
}
