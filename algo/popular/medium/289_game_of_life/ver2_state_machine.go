package main

func gameOfLifeV2(board [][]int) {
	/*
		METHOD: State machine
		Используется метод "внутреннего состояния", где каждая клетка может иметь дополнительные состояния для обозначения изменений.
		Состояния:
		0: "0->0" - мертвая клетка остается мертвой
		1: "1->1" - живая клетка остается живой
		2: "0->1" - мертвая клетка становится живой
		3: "1->0" - живая клетка становится мертвой

		TIME COMPLEXITY:
		O(N*M), где N — количество строк, M — количество столбцов в сетке.
		Мы обходим каждую клетку сетки дважды: один раз для определения следующего состояния и второй раз для обновления состояния.

		SPACE COMPLEXITY:
		O(1), так как мы используем только постоянное количество дополнительной памяти (map для состояний).
	*/
	if len(board) == 0 {
		return
	}

	// Map для хранения состояний клеток
	stateMap := map[int]int{
		0: 0, // "0->0" - мертвая клетка остается мертвой
		1: 1, // "1->1" - живая клетка остается живой
		2: 1, // "0->1" - мертвая клетка становится живой
		3: 0, // "1->0" - живая клетка становится мертвой
	}

	// Обходим каждую клетку сетки
	for i := 0; i < len(board); i++ {
		for j := 0; j < len(board[0]); j++ {
			// Получаем количество живых соседей
			neigh := getLiveNeigh(board, i, j)
			// Применяем правила игры жизни
			if board[i][j] == 1 && (neigh < 2 || neigh > 3) {
				// Живая клетка с менее чем двумя или более чем тремя живыми соседями умирает
				board[i][j] = 3
			} else if board[i][j] == 0 && neigh == 3 {
				// Мертвая клетка с ровно тремя живыми соседями становится живой
				board[i][j] = 2
			}
		}
	}

	// Обновляем состояние клеток на основе stateMap
	for i := 0; i < len(board); i++ {
		for j := 0; j < len(board[0]); j++ {
			board[i][j] = stateMap[board[i][j]]
		}
	}

	return
}

// Функция для подсчета живых соседей клетки
func getLiveNeigh(board [][]int, rowIdx, colIdx int) int {
	// Возможные направления для обхода соседей
	traverse := [][]int{{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {-1, -1}, {1, 1}, {-1, 1}, {1, -1}}
	liveNeigh := 0

	// Обходим всех соседей
	for _, cord := range traverse {
		newX := rowIdx + cord[0]
		newY := colIdx + cord[1]

		// Проверяем, что координаты находятся в пределах сетки
		if newX < 0 || newX >= len(board) || newY < 0 || newY >= len(board[0]) {
			continue
		}

		// Если сосед жив или должен стать мертвым, увеличиваем счетчик живых соседей
		if board[newX][newY] == 1 || board[newX][newY] == 3 {
			liveNeigh++
		}
	}

	return liveNeigh
}
