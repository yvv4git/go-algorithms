package main

func numTreesV1(n int) int {
	/*
		METHOD: Dynamic programming
		TIME COMPLEXITY: O(n)
		SPACE COMPLEXITY: O(n)

		Time complexity
		Временная сложность этого алгоритма - O(n^2), потому что мы используем два вложенных цикла,
		где внешний цикл проходит по всем узлам от 2 до n, а внутренний цикл проходит по всем узлам от 0 до i.

		Space complexity
		Пространственная сложность - O(n), потому что мы используем дополнительный массив dp, размер которого равен n+1.

		Алгоритм:
		1. Создаем массив dp, где dp[i] будет хранить количество уникальных BST с i узлами.
		2. Заполняем массив dp.
		3. Возвращаем количество уникальных BST с n узлами.

		Двоичное дерево поиска (BST) - это дерево, в котором все узлы, лежащие в левом поддереве, меньше корня,
		а все узлы, лежащие в правом поддереве, больше корня.

		Массив dp используется для решения задачи динамическим программированием,
		где мы используем предыдущие результаты для вычисления текущего результата.
		В данном случае, мы используем предыдущие результаты для вычисления текущего количества уникальных двоичных деревьев поиска.
	*/
	// Создаем массив dp, где dp[i] будет хранить количество уникальных BST с i узлами
	dp := make([]int, n+1)
	dp[0], dp[1] = 1, 1

	// Заполняем массив dp с промежуточными результатами.
	// Массив dp инициализируется с длиной n+1, где n - это количество узлов в дереве.
	// Каждый элемент массива dp представляет собой количество уникальных двоичных деревьев поиска, которые можно построить с заданным количеством узлов.
	// Например, если n = 3, то dp[3] будет содержать количество уникальных двоичных деревьев поиска, которые можно построить с 3 узлами.
	for i := 2; i <= n; i++ {
		for j := 0; j < i; j++ {
			// dp[i] += dp[j] * dp[i-j-1]
			dp[i] += dp[j] * dp[i-j-1]
		}
	}

	return dp[n]
}
