package main

// Функция isValidBST проверяет, является ли дерево бинарным деревом поиска.
func isValidBSTV5(root *TreeNode) bool {
	/*
		METHOD: DFS
		TIME COMPLEXITY: O(n)
		SPACE COMPLEXITY: O(n)

		Time complexity
		Временная сложность алгоритма DFS для проверки, является ли дерево бинарным деревом поиска, составляет O(n),
		где n - количество узлов в дереве. Это связано с тем, что мы посещаем каждый узел только один раз.

		Space complexity
		Пространственная сложность также составляет O(n) в худшем случае,
		когда дерево является сбалансированным и высота дерева равна количеству узлов.
		В этом случае, мы будем хранить все узлы в стеке.

		Однако, если дерево не является сбалансированным, то пространственная сложность может быть меньше,
		поскольку стек будет содержать только узлы, которые находятся на одной глубине.
		В этом случае, пространственная сложность будет O(h), где h - высота дерева.
	*/
	// Создаем стек для хранения узлов, которые нужно посетить.
	var stack []*TreeNode
	// Переменная prev будет хранить предыдущий посещенный узел.
	var prev *TreeNode

	// Пока есть узлы для посещения или стек не пуст,
	// мы продолжаем обход дерева.
	for root != nil || len(stack) > 0 {
		// Пока есть узлы в левом поддереве, мы идем вниз по левой ветви.
		for root != nil {
			// Добавляем текущий узел в стек.
			stack = append(stack, root)
			// Переходим влево.
			root = root.Left
		}

		// Берем последний узел из стека.
		root = stack[len(stack)-1]
		// Удаляем его из стека.
		stack = stack[:len(stack)-1]

		// Если предыдущий узел существует и его значение больше,
		// чем значение текущего узла, то дерево не является BST.
		if prev != nil && root.Val <= prev.Val {
			return false
		}

		// Обновляем предыдущий узел.
		prev = root
		// Переходим вправо.
		root = root.Right
	}

	// Если мы дошли до этой точки, то дерево является BST.
	return true
}
