package main

// Функция для вычисления факториала
func factorial(n int) int {
	result := 1
	for i := 2; i <= n; i++ {
		result *= i
	}
	return result
}

// Функция для вычисления сочетаний
func combinations(n int, k int) int {
	// Вычисляем факториал n
	factN := factorial(n)
	// Вычисляем факториал k
	factK := factorial(k)
	// Вычисляем факториал n - k
	factNMinusK := factorial(n - k)

	// Вычисляем сочетания
	return factN / (factK * factNMinusK)
}

// Функция для нахождения количества уникальных путей
func uniquePathsV3(m int, n int) int {
	/*
		METHOD: Combinatorics
		Метод комбинаторики - это ветвь математики, которая занимается изучением объектов, которые можно составить из других объектов.
		В контексте решения задач на программировании, метод комбинаторики используется для вычисления количества возможных комбинаций элементов, без учета порядка.
		Формула для вычисления сочетаний выглядит следующим образом: C(n, k) = n! / [k!(n - k)!],
		где n! обозначает факториал числа n, который вычисляется как произведение всех натуральных чисел от 1 до n.

		В задаче нахождения количества уникальных путей в сетке, мы можем рассматривать сетку как сетку из блоков,
		где каждый блок - это клетка сетки. Чтобы добраться от левого верхнего угла до правого нижнего,
		нам нужно сделать m + n - 2 шагов (m - 1 шагов вниз и n - 1 шагов вправо).
		Мы должны выбрать, сколько из этих шагов будут сделаны вниз (или вправо), что соответствует выбору m - 1 шагов из m + n - 2 возможных.
		Таким образом, количество уникальных путей в сетке равно сочетанию из m + n - 2 по m - 1.

		Этот подход является эффективным, однако он может быть неэффективным для больших значений m и n,
		поскольку факториалы могут быть очень большими числами, и вычисление факториала может быть медленным.
		Для больших значений m и n лучше использовать подход динамического программирования.

		TIME COMPLEXITY: O(m + n), так как мы вычисляем факториалы для m + n - 2 и m - 1, что требует O(m + n) операций.
		Однако, поскольку факториалы вычисляются очень быстро, их вычисление не влияет на общее время выполнения функции.

		SPACE COMPLEXITY: O(1), так как мы используем лишь несколько переменных для хранения промежуточных результатов,
		и не выделяем дополнительную память, которая была бы пропорциональна размеру входных данных.
	*/
	// Количество шагов, которые нужно совершить, равно m + n - 2
	totalSteps := m + n - 2
	// Количество уникальных путей равно сочетанию из totalSteps по m - 1
	return combinations(totalSteps, m-1)
}

//func main() {
//	m := 3
//	n := 7
//	fmt.Println(uniquePaths(m, n)) // Выводит: 28
//}
