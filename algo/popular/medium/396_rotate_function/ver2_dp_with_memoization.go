package main

func maxRotateFunctionV2(A []int) int {
	/*
		METHOD:
		Используется итеративный подход с оптимизацией на основе предыдущего состояния.
		Мы вычисляем начальное значение функции F(0) и затем итеративно обновляем его для каждого поворота массива,
		используя формулу, которая позволяет избежать повторных вычислений.
		Этот подход можно также рассматривать как динамическое программирование с использованием мемоизации,
		где мы запоминаем результат предыдущей итерации для оптимизации вычислений.

		TIME COMPLEXITY:
		Временная сложность алгоритма составляет O(n), где n — длина массива A.
		Это связано с тем, что мы выполняем один проход по массиву для вычисления начального значения F(0) и суммы элементов,
		а затем еще один проход для вычисления значений F(k) для всех k от 1 до n-1.

		SPACE COMPLEXITY:
		Пространственная сложность алгоритма составляет O(1),
		так как мы используем фиксированное количество дополнительной памяти (переменные max, digitSum, curMax
		и несколько временных переменных) независимо от размера входного массива.
	*/
	if len(A) == 0 {
		return 0
	}

	// Инициализация переменных
	max := 0
	digitSum := 0

	// Вычисление начального значения функции F(0) и суммы всех элементов массива
	for i, num := range A {
		max += i * num
		digitSum += num
	}

	// Текущее максимальное значение функции F(k)
	curMax := max

	// Если длина массива больше 1, вычисляем значения F(k) для всех k от 1 до n-1
	if len(A) > 1 {
		for i := len(A) - 1; i >= 1; i-- {
			// Вычисление нового значения функции F(k) на основе предыдущего значения F(k-1)
			// Это и есть пример динамического программирования с использованием мемоизации
			newMax := curMax - (len(A)-1)*A[i] + (digitSum - A[i])
			if newMax > max {
				max = newMax
			}
			curMax = newMax
		}
	}

	// Возвращаем максимальное значение функции F(k)
	return max
}
