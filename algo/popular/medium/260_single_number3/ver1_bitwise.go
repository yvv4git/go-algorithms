package main

func singleNumber(nums []int) []int {
	/*
		METHOD: Bitwise
		Алгоритм основан на том, что если мы сложим все числа в массиве, то каждое число, которое встречается дважды,
		будет умножено на 2, а числа, встречающиеся один раз, не будут влиять на сумму.
		Разница между суммой всех чисел и суммой уникальных чисел будет равна XOR двух одиноковых чисел.

		Описание подхода:
		1. Находим XOR всех чисел в массиве. Это даст нам XOR двух одиноковых чисел,
		так как каждое число, которое встречается дважды, будет умножено на 2, а числа,
		встречающиеся один раз, не будут влиять на сумму.

		2. Находим любой бит в полученном XOR, который равен 1. Этот бит должен быть установлен в одном из одиноковых чисел, но не в обоих.

		3. Разделяем числа на два группы: одну, в которой этот бит установлен, и другую, в которой он не установлен.

		4. XOR чисел в каждой группе, чтобы получить одиноковые числа.

		TIME COMPLEXITY: O(n), где n - количество элементов в массиве, потому что мы проходим по массиву дважды:
		один раз для вычисления XOR всех чисел и еще раз для разделения чисел на группы.

		SPACE COMPLEXITY: O(1), потому что мы используем фиксированное количество переменных, не зависящих от размера входных данных.
	*/
	// Шаг 1: Находим XOR всех чисел в массиве
	xor := 0
	for _, num := range nums {
		xor ^= num
	}

	// Шаг 2: Находим любой бит, который равен 1 в полученном XOR
	// Этот бит должен быть установлен в одном из одиноковых чисел, но не в обоих
	bit := xor & -xor

	// Шаг 3: Разделяем числа на два группы: одну, в которой этот бит установлен,
	// и другую, в которой он не установлен
	result := []int{0, 0}
	for _, num := range nums {
		if num&bit == 0 {
			result[0] ^= num
		} else {
			result[1] ^= num
		}
	}

	// Шаг 4: XOR чисел в каждой группе, чтобы получить одиноковые числа
	return result
}
