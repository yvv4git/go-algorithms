package main

import (
	"math/rand"
	"time"
)

// Solution реализует оптимизированную версию алгоритма Фишера-Йетса для больших матриц
// Основные идеи:
// 1. Вместо хранения всех позиций используем математическое отображение
// 2. Храним только перевернутые позиции для экономии памяти
// 3. Поддерживаем равномерное распределение вероятностей
type Solution struct {
	m, n      int          // Размеры матрицы (строки, столбцы)
	total     int          // Общее количество элементов (m * n)
	remaining int          // Количество оставшихся нулевых элементов
	flipped   map[int]bool // Хранит только перевернутые позиции (ключ - линейный индекс)
	rng       *rand.Rand   // Генератор случайных чисел
}

// Constructor инициализирует объект Solution
// Временная сложность: O(1) - только инициализация полей
// Пространственная сложность: O(1) - не аллоцируем массив всех позиций
// Оптимизация: вместо O(m*n) памяти используем O(k), где k - число flip()
func Constructor(m int, n int) Solution {
	source := rand.NewSource(time.Now().UnixNano())
	return Solution{
		m:         m,
		n:         n,
		total:     m * n,
		remaining: m * n,
		flipped:   make(map[int]bool),
		rng:       rand.New(source),
	}
}

// Flip возвращает случайную позицию [i,j] с нулевым значением и переключает ее в 1
// Алгоритм:
// 1. Генерируем случайный индекс в диапазоне [0, remaining)
// 2. Находим фактическую позицию, пропуская перевернутые
// 3. Сохраняем позицию как перевернутую
// 4. Преобразуем линейный индекс в координаты матрицы
// Временная сложность: O(1) в среднем случае (амортизированная)
// Пространственная сложность: O(k), где k - число flip()
// Гарантии: равномерное распределение, так как выбираем из remaining элементов
func (this *Solution) Flip() []int {
	if this.remaining == 0 {
		return nil // Все элементы уже перевернуты
	}

	// Генерируем случайную позицию в диапазоне [0, remaining)
	randomPos := this.rng.Intn(this.remaining)

	// Ищем фактическую позицию, пропуская уже перевернутые
	actualPos := randomPos
	for this.flipped[actualPos] {
		actualPos++
	}

	// Добавляем позицию в перевернутые
	this.flipped[actualPos] = true
	this.remaining--

	// Конвертируем линейную позицию в координаты матрицы
	i := actualPos / this.n
	j := actualPos % this.n

	return []int{i, j}
}

// Reset возвращает все элементы матрицы в состояние 0
// Оптимизация: просто очищаем карту и восстанавливаем счетчик
// Временная сложность: O(1) - очистка карты в Go занимает O(1)
// Пространственная сложность: O(1) - память освобождается сборщиком мусора
// Примечание: не требуется физическое обнуление матрицы
func (this *Solution) Reset() {
	// Очищаем карту перевернутых позиций
	this.flipped = make(map[int]bool)
	this.remaining = this.total
}

/**
 * Your Solution object will be instantiated and called as such:
 * obj := Constructor(m, n);
 * param_1 := obj.Flip();
 * obj.Reset();
 */
