# 519. Random Flip Matrix


## Level - medium


## Task
There is an m x n binary grid matrix with all the values set 0 initially. 
Design an algorithm to randomly pick an index (i, j) where matrix[i][j] == 0 and flips it to 1. All the indices (i, j) where matrix[i][j] == 0 should be equally likely to be returned.

Optimize your algorithm to minimize the number of calls made to the built-in random function of your language and optimize the time and space complexity.

Implement the Solution class:

Solution(int m, int n) Initializes the object with the size of the binary matrix m and n.
int[] flip() Returns a random index [i, j] of the matrix where matrix[i][j] == 0 and flips it to 1.
void reset() Resets all the values of the matrix to be 0.


## Объяснение
Задача требует реализовать алгоритм для работы с бинарной матрицей размером m×n, где все элементы изначально установлены в 0. Алгоритм должен:

1. **Случайный выбор элемента**: 
   - При вызове метода flip() должен возвращаться случайный индекс (i,j) элемента матрицы, который равен 0
   - После выбора элемент переключается в 1
   - Все нулевые элементы должны иметь равную вероятность выбора

2. **Оптимизация**:
   - Минимизировать количество вызовов встроенной random функции
   - Оптимизировать временную и пространственную сложность

3. **Сброс состояния**:
   - Метод reset() должен возвращать все элементы матрицы в состояние 0

**Ключевые аспекты реализации**:
- Использование хеш-таблицы или массива для отслеживания свободных позиций
- Алгоритм должен эффективно работать при многократных вызовах flip()
- При сбросе (reset) не требуется физически обнулять всю матрицу - можно использовать логический сброс

**Пример работы**:
1. Инициализация: matrix = [[0,0],[0,0]] (все элементы 0)
2. Первый flip(): возвращает случайный индекс, например [0,1], матрица становится [[0,1],[0,0]]
3. Второй flip(): возвращает один из оставшихся нулей ([0,0], [1,0] или [1,1]) с равной вероятностью
4. Reset(): все элементы снова становятся доступными для выбора
### Постановка задачи:
Требуется реализовать алгоритм для работы с бинарной матрицей размером m×n, где все элементы изначально равны 0. Алгоритм должен:
1. Случайным образом выбирать позицию (i,j) с нулевым значением
2. Изменять выбранный элемент на 1
3. Гарантировать равномерное распределение вероятностей выбора
4. Поддерживать операцию сброса матрицы в исходное состояние

### Ключевые аспекты:
1. **Равномерное распределение**: Все нулевые элементы должны иметь одинаковую вероятность выбора
2. **Оптимизация**: Минимизация вызовов random() и оптимизация по памяти/времени
3. **Инварианты**: После каждого flip() количество нулей уменьшается на 1
4. **Сброс состояния**: reset() должен восстанавливать исходную матрицу

### Подходы к реализации:

#### 1. Наивный подход (O(k) на операцию flip)
- Хранить список всех нулевых позиций
- При flip() выбирать случайный элемент из списка и удалять его
- При reset() восстанавливать полный список
- **Недостатки**: Высокие затраты памяти O(mn), медленный reset()

#### 2. Оптимизированный подход с хеш-мапой (O(1) на операцию flip в среднем)
- Использовать хеш-таблицу для отображения выбранных позиций
- При flip():
  * Генерировать случайную позицию
  * Если позиция уже занята (есть в хеш-таблице), искать следующую свободную
- При reset() очищать хеш-таблицу
- **Преимущества**: Экономия памяти, быстрый сброс
- **Недостатки**: В худшем случае O(k) на операцию flip

#### 3. Алгоритм Фишера-Йетса (O(1) на операцию flip)
- Хранить массив доступных позиций в компактной форме
- При flip() выбирать случайный элемент и заменять его последним
- Уменьшать диапазон случайного выбора
- **Преимущества**: Константное время операций, минимальные затраты памяти
- **Сложность реализации**: Требуется аккуратная работа с индексами


## Example 1:
```
Input
["Solution", "flip", "flip", "flip", "reset", "flip"]
[[3, 1], [], [], [], [], []]
Output
[null, [1, 0], [2, 0], [0, 0], null, [2, 0]]

Explanation
Solution solution = new Solution(3, 1);
solution.flip();  // return [1, 0], [0,0], [1,0], and [2,0] should be equally likely to be returned.
solution.flip();  // return [2, 0], Since [1,0] was returned, [2,0] and [0,0]
solution.flip();  // return [0, 0], Based on the previously returned indices, only [0,0] can be returned.
solution.reset(); // All the values are reset to 0 and can be returned.
solution.flip();  // return [2, 0], [0,0], [1,0], and [2,0] should be equally likely to be returned.
```


## Constraints:
- 1 <= m, n <= 104
- There will be at least one free cell for each call to flip.
- At most 1000 calls will be made to flip and reset.