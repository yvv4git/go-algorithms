package main

import (
	"container/heap"
	"fmt"
)

// Pairs - структура для хранения суммы пары чисел и их индексов
type Pairs struct {
	sum int // Сумма чисел пары
	i   int // Индекс числа из первого массива
	j   int // Индекс числа из второго массива
}

// PairsHeap - приоритетная очередь для хранения пар
type PairsHeap []Pairs

// Len возвращает длину кучи
func (h PairsHeap) Len() int { return len(h) }

// Less определяет, какая из двух пар имеет меньшую сумму
func (h PairsHeap) Less(i, j int) bool { return h[i].sum < h[j].sum }

// Swap меняет местами две пары в куче
func (h PairsHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }

// Empty проверяет, пуста ли куча
func (h *PairsHeap) Empty() bool { return len(*h) == 0 }

// Push добавляет элемент в кучу
func (h *PairsHeap) Push(x interface{}) {
	*h = append(*h, x.(Pairs))
}

// Pop удаляет и возвращает элемент с наибольшим приоритетом (наименьшая сумма)
func (h *PairsHeap) Pop() interface{} {
	old := *h
	n := len(old)
	x := old[n-1]
	*h = old[0 : n-1]
	return x
}

// kSmallestPairs - функция для поиска k наименьших пар.
// Обрати внимание, что nums1 и nums2 отсортированы по возрастанию.
func kSmallestPairs(nums1 []int, nums2 []int, k int) [][]int {
	/*
		Метод: Heap sort
		В Go для решения этой задачи можно использовать приёмы, связанные с алгоритмами сортировки и поиска.
		Одним из таких подходов является использование приоритетной очереди (heap).
		В Go для реализации приоритетной очереди можно использовать пакет container/heap.

		Временная сложность: O(k log k), где k - количество пар, которые нужно найти.
		Это связано с тем, что мы добавляем и удаляем элементы из приоритетной очереди,
		и каждое такое действие выполняется за логарифмическое время.

		Пространственная сложность: O(k), так как в худшем случае мы храним k элементов в приоритетной очереди.
	*/
	// Создаем пустой срез для хранения результатов
	result := make([][]int, 0)

	// Инициализируем кучу для отслеживания наименьших пар
	minHeap := &PairsHeap{}
	heap.Init(minHeap)

	// Добавляем первые элементы из каждого массива в кучу.
	// Этот цикл инициализирует кучу minHeap первыми парами чисел из nums1 и nums2.
	// Каждая пара состоит из одного числа из nums1 и первого числа из nums2, сумма которых вместе с индексами добавляется в кучу.
	//
	// Цель этого инициализационного цикла заключается в том, чтобы начать процесс поиска наименьших пар.
	// Каждая пара представляет собой возможный начальный элемент для нашего поиска,
	// и мы добавляем их все в кучу, чтобы начать процесс поиска наименьших пар.
	//
	// После инициализации кучи, начинается основной цикл, где мы извлекаем наименьшие пары из кучи,
	// добавляем их в результат и, при необходимости, добавляем новые пары в кучу для дальнейшего поиска.
	for i, v1 := range nums1 {
		heap.Push(minHeap, Pairs{sum: v1 + nums2[0], i: i, j: 0}) // nums2 отсортирован по возрастанию
	}

	// Пока куча не пуста и мы не нашли k пар
	for !minHeap.Empty() && k > 0 {
		// Извлекаем из кучи пару с наименьшей суммой
		currentMin := heap.Pop(minHeap).(Pairs)
		i, j := currentMin.i, currentMin.j

		// Добавляем пару в результирующий срез
		result = append(result, []int{nums1[i], nums2[j]})

		// Вычисляем индекс следующего элемента второго массива
		nextElement := j + 1

		// Если следующий элемент существует, добавляем его в кучу
		if nextElement < len(nums2) {
			heap.Push(minHeap, Pairs{sum: nums1[i] + nums2[nextElement], i: i, j: nextElement})
		}

		// Уменьшаем счетчик k на 1
		k--
	}

	return result
}

func main() {
	nums1 := []int{1, 7, 11}
	nums2 := []int{2, 4, 6}
	k := 3

	pairs := kSmallestPairs(nums1, nums2, k)
	fmt.Println(pairs) // Вывод: [[1, 2], [1, 4], [1, 6]]
}
