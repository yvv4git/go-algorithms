package main

import "fmt"

// Функция для проверки, является ли строка перестановкой другой строки
func checkInclusion(s1 string, s2 string) bool {
	/*
		METHOD: Sliding Window || Two pointers
		TIME COMPLEXITY: O(n), где n - длина строки s2. Это обусловлено тем, что мы проходим по строке s2 только один раз,
		и для каждого символа выполняем постоянное количество операций (обновление частотного массива и проверку условия).
		SPACE COMPLEXITY: O(1), так как независимо от размера входных данных (s1 и s2) мы используем фиксированное количество памяти для хранения частотного массива,
		который всегда состоит из 26 элементов (по одному для каждой буквы английского алфавита).

		Этот подход основан на использовании двух указателей (или "окон") для прохода по массиву или списку данных,
		чтобы эффективно решать задачи, связанные с поиском подстрок или подпоследовательностей.

		В данном случае, мы используем два указателя, чтобы отслеживать текущую подстроку в s2, которая имеет ту же длину, что и s1.
		Мы двигаем один указатель вперед, увеличивая размер подстроки, и двигаем второй указатель вперед,
		уменьшая размер подстроки, пока не найдем подстроку, которая является перестановкой s1.

		Такой подход позволяет нам эффективно проверять все подстроки длины len(s1) в s2, не проверяя каждую подстроку отдельно.
		Это оптимизирует решение, позволяя нам избежать линейного по времени перебора всех возможных подстрок.
	*/
	// Создаем два массива для хранения частоты символов в s1 и s2
	var s1Count [26]int
	var s2Count [26]int

	// Заполняем массивы частот для s1
	for _, ch := range s1 {
		s1Count[ch-'a']++
	}

	// Проходим по s2, обновляя массив частот и проверяя, является ли текущая подстрока перестановкой s1
	for i := range s2 {
		// Обновляем массив частот для s2
		s2Count[s2[i]-'a']++
		// Если длина текущей подстроки больше длины s1, удаляем первый символ из подстроки
		if i >= len(s1) {
			s2Count[s2[i-len(s1)]-'a']--
		}
		// Если текущая подстрока имеет ту же длину, что и s1, проверяем, является ли она перестановкой s1
		if i >= len(s1)-1 && matches(s1Count, s2Count) {
			return true
		}
	}

	return false
}

// Функция для проверки, совпадают ли два массива частот
func matches(s1Count [26]int, s2Count [26]int) bool {
	for i := range s1Count {
		if s1Count[i] != s2Count[i] {
			return false
		}
	}
	return true
}

func main() {
	s1 := "ab"
	s2 := "eidbaooo"
	fmt.Println(checkInclusion(s1, s2)) // Вывод: true
}
