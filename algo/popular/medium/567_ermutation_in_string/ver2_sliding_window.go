package main

func checkInclusionV2(s1 string, s2 string) bool {
	/*
		METHOD: Sliding Window || Two pointers
		TIME COMPLEXITY: O(n), где n - длина строки s2. Это обусловлено тем, что мы проходим по строке s2 только один раз,
		и для каждого символа выполняем постоянное количество операций (обновление частотного массива и проверку условия).
		SPACE COMPLEXITY: O(1), так как независимо от размера входных данных (s1 и s2) мы используем фиксированное количество памяти для хранения частотного массива,
		который всегда состоит из 26 элементов (по одному для каждой буквы английского алфавита).
	*/

	// Создаем два массива для хранения частоты символов в s1 и s2
	s1Hashmap := [26]int{}
	s2Hashmap := [26]int{}

	// Если длина s2 меньше длины s1, то s1 не может быть перестановкой s2
	if len(s2) < len(s1) {
		return false
	}

	// Заполняем массивы частот для s1
	for i := 0; i < len(s1); i++ {
		s1Hashmap[s1[i]-'a']++
	}

	// Инициализируем два указателя l и r для окна размера len(s1) в s2
	l := 0
	r := len(s1) - 1

	// Заполняем массив частот для первого окна размера len(s1) в s2
	for i := 0; i < len(s1); i++ {
		s2Hashmap[s2[i]-'a']++
	}

	// Проходим по s2 с помощью окна размера len(s1)
	for r < len(s2)-1 {
		// Если частотные массивы для текущего окна в s2 совпадают с частотным массивом s1,
		// то s1 является перестановкой подстроки s2
		if s1Hashmap == s2Hashmap {
			return true
		} else {
			// Сдвигаем окно вправо, уменьшая частоту символа на позиции l и увеличивая частоту символа на позиции r+1
			s2Hashmap[s2[l]-'a']--
			l++
			r++
			s2Hashmap[s2[r]-'a']++
		}
	}

	// Проверяем частотный массив для последнего окна в s2
	return s1Hashmap == s2Hashmap
}
