package main

import (
	"fmt"
	"strconv"
)

func freqAlphabets(s string) string {
	/*
		METHOD: Iteration
		Мы проходим по строке `s` с конца к началу, чтобы легко обрабатывать символы `#`.
		Если встречаем символ `#`, то рассматриваем две предыдущие цифры как число, которое соответствует букве.
		Если символ `#` не встречается, то рассматриваем текущую цифру как число, которое соответствует букве.
		Результат собирается в обратном порядке, поэтому в конце мы переворачиваем список и объединяем его в строку.

		TIME COMPLEXITY: O(n)
		Временная сложность алгоритма составляет O(n), где n — длина строки `s`.
		Мы проходим по строке один раз с конца к началу, и каждая операция (проверка символа, преобразование числа в букву) выполняется за постоянное время.

		SPACE COMPLEXITY: O(n)
		Пространственная сложность алгоритма составляет O(n), где n — длина строки `s`.
		Мы используем дополнительный срез байтов `result` для хранения расшифрованных букв, который может содержать до n элементов.
	*/

	result := []byte{}
	i := len(s) - 1

	// Проходим по строке с конца к началу
	for i >= 0 {
		if s[i] == '#' {
			// Если встретился символ '#', то рассматриваем две предыдущие цифры
			num, _ := strconv.Atoi(s[i-2 : i])
			result = append(result, byte(num+96)) // 96 - это смещение для получения буквы из числа
			i -= 3
		} else {
			// Иначе рассматриваем текущую цифру
			num, _ := strconv.Atoi(string(s[i]))
			result = append(result, byte(num+96))
			i -= 1
		}
	}

	// Результат нужно перевернуть, так как мы добавляли буквы с конца
	for i, j := 0, len(result)-1; i < j; i, j = i+1, j-1 {
		result[i], result[j] = result[j], result[i]
	}

	return string(result)
}

func main() {
	// Пример использования
	s := "10#11#12"
	fmt.Println(freqAlphabets(s)) // Вывод: "jkab"
}
