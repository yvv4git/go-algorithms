package main

import (
	"fmt"
)

func fairCandySwap(aliceSizes []int, bobSizes []int) []int {
	/*
		METHOD: Hash Set Lookup
		1. Вычисляем сумму конфет у Алисы и Боба.
		2. Находим разницу между этими суммами, которую нужно уравновесить обменом одной конфеты.
		3. Создаем множество для быстрого поиска элементов из массива конфет Боба.
		4. Проходим по каждому элементу в массиве конфет Алисы и проверяем, есть ли в множестве элемент, равный текущему элементу плюс разница.
		5. Если такой элемент найден, возвращаем пару конфет, которые нужно обменять.

		TIME COMPLEXITY: O(n + m) - сумма длин двух массивов, потому что мы проходим по каждому элементу в массиве A (O(n))
		также и используем множество для поиска элементов в массиве B (O(m)), где n - длина массива A, а m - длина массива B.

		SPACE COMPLEXITY: O(m) - множество для поиска элементов в массиве B, где m - длина массива B.
	*/
	// Вычисляем сумму конфет у Алисы и Боба
	sumA := 0
	sumB := 0
	for _, a := range aliceSizes {
		sumA += a
	}
	for _, b := range bobSizes {
		sumB += b
	}

	// Вычисляем разницу между суммами, которую нужно уравновесить
	diff := (sumB - sumA) / 2

	// Создаем множество для быстрого поиска элементов из массива B
	setB := make(map[int]bool)
	for _, b := range bobSizes {
		setB[b] = true
	}

	// Проходим по каждому элементу в массиве A
	for _, a := range aliceSizes {
		// Проверяем, есть ли в множестве setB элемент, равный a + diff
		if _, exists := setB[a+diff]; exists {
			// Если такой элемент найден, возвращаем пару [a, a + diff]
			return []int{a, a + diff}
		}
	}

	// Если подходящая пара не найдена, возвращаем пустой массив (хотя это не должно произойти по условию задачи)
	return []int{}
}

func main() {
	// Пример использования
	A := []int{1, 1}
	B := []int{2, 2}
	result := fairCandySwap(A, B)
	fmt.Println(result) // Вывод: [1 2]
}
