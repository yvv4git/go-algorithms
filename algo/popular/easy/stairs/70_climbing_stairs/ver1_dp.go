package main

// climbStairs возвращает количество способов подняться на лестницу из n ступеней.
func climbStairs(n int) int {
	/*
		METHOD: Dynamic programming
		Time complexity: O(n)
		Space complexity: O(1)

		Time complexity
		Временная сложность этого алгоритма составляет O(n), где n - количество ступеней в лестнице,
		потому что мы проходим по каждой ступени ровно один раз.

		Space complexity
		Пространственная сложность составляет O(1), так как мы используем фиксированное количество переменных для хранения промежуточных результатов,
		независимо от размера входных данных.

		Решение этой задачи может быть решено с помощью динамического программирования, используя метод "снижения степени".
		Метод "снижения степени" основан на идее того, что количество способов достижения ступени i зависит от количества способов достижения предыдущих ступеней.


		Пошаговое объяснение кода:
		1. Сначала проверяются базовые случаи. Если n равно 1, то есть только один способ подняться на одну ступеньку.
		Если n равно 2, то есть два способа подняться - сначала шагнуть на одну ступеньку, а затем на вторую, или сразу шагнуть на две ступеньки.

		2. Затем инициализируются два начальных значения: oneStepBefore равно 2 (для случая, когда n равно 3),
		и twoStepsBefore равно 1 (для случая, когда n равно 2).
		Также инициализируется переменная ways, которая будет хранить количество способов подняться на n-ую ступеньку.

		3. Далее происходит итерация от 3 до n, в которой для каждой ступени вычисляется количество способов подняться до нее,
		как сумму способов подняться на две предыдущие ступени.

		4. После каждой итерации обновляются значения twoStepsBefore и oneStepBefore для следующей итерации.

		5. В конце функция возвращает количество способов подняться на n-ую ступеньку.

	*/
	// Базовый случай: если n равно 1, то есть только один способ подняться.
	if n == 1 {
		return 1
	}

	// Базовый случай: если n равно 2, то есть два способа подняться.
	if n == 2 {
		return 2
	}

	// Инициализируем первые два значения.
	oneStepBefore := 2
	twoStepsBefore := 1
	ways := 0

	// Проходим по каждой ступени, начиная со второй.
	for i := 3; i <= n; i++ {
		// Количество способов достижения текущей ступени - это сумма способов достижения
		// двух предыдущих ступеней.
		ways = oneStepBefore + twoStepsBefore
		// Обновляем значения для следующей итерации.
		twoStepsBefore = oneStepBefore
		oneStepBefore = ways
	}

	return ways
}
