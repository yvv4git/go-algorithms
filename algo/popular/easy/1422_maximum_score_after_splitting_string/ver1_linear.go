package main

import (
	"fmt"
	"strings"
)

// Функция для вычисления максимального score после разделения строки
func maxScore(s string) int {
	/*
		APPROACH: Linear Scan with Prefix Count
		1. Сначала вычисляем общее количество единиц (`totalOnes`) в строке, так как оно понадобится для расчета единиц в правой части.
		2. Проходим по строке от первого до предпоследнего символа (чтобы разделение было корректным и обе части были непустыми).
		3. Для каждого символа:
		   - Если символ '0', увеличиваем счетчик `leftZeros` (количество нулей в левой части).
		   - Если символ '1', увеличиваем счетчик `leftOnes` (количество единиц в левой части).
		4. На каждом шаге вычисляем текущий score:
		   - `leftZeros` (количество нулей слева) + (`totalOnes - leftOnes`) (количество единиц справа).
		5. Обновляем максимальный score (`maxScore`), если текущий score больше предыдущего максимума.
		6. Возвращаем `maxScore`.

		Этот подход эффективен, потому что:
		- Мы заранее знаем общее количество единиц (`totalOnes`), что позволяет вычислять количество единиц справа за O(1) на каждом шаге.
		- Требуется только один проход по строке после подсчета `totalOnes`.

		TIME COMPLEXITY: O(n)
		- Подсчет общего количества единиц (`strings.Count`) занимает O(n).
		- Основной цикл проходит по строке один раз (O(n)).
		- Итоговая сложность: O(n) + O(n) = O(n).

		SPACE COMPLEXITY: O(1)
		- Используются только константные переменные (`totalOnes`, `leftZeros`, `leftOnes`, `maxScore`), не зависящие от размера строки.
		- Дополнительная память не требуется.
	*/
	// Считаем общее количество '1' в строке
	totalOnes := strings.Count(s, "1")
	leftZeros := 0 // Количество '0' в левой части
	leftOnes := 0  // Количество '1' в левой части
	maxScore := 0  // Максимальный score

	// Проходим по строке до предпоследнего символа (чтобы разделение было корректным)
	for i := 0; i < len(s)-1; i++ {
		if s[i] == '0' {
			leftZeros++ // Увеличиваем счетчик '0' слева
		} else {
			leftOnes++ // Увеличиваем счетчик '1' слева
		}

		// Вычисляем текущий score:
		// score = количество '0' слева + количество '1' справа
		// Количество '1' справа = общее количество '1' - '1' слева
		currentScore := leftZeros + (totalOnes - leftOnes)

		// Обновляем максимальный score, если текущий больше
		if currentScore > maxScore {
			maxScore = currentScore
		}
	}

	return maxScore
}

func main() {
	// Примеры входных данных
	fmt.Println(maxScore("011101")) // Ожидаемый результат: 5
	fmt.Println(maxScore("00111"))  // Ожидаемый результат: 5
	fmt.Println(maxScore("1111"))   // Ожидаемый результат: 3
	fmt.Println(maxScore("00"))     // Ожидаемый результат: 1
}
