package main

import (
	"fmt"
)

func shiftGrid(grid [][]int, k int) [][]int {
	/*
		APPROACH: Cyclic 1D Index Mapping
		Этот подход использует преобразование двумерного массива в одномерный индекс и циклический сдвиг элементов.
		Мы находим новый индекс для каждого элемента и затем заносим его в новый массив.

		1. Определяем размеры матрицы.
		2. Определяем общее количество элементов в матрице.
		3. Оптимизируем количество сдвигов (если k > total).
		4. Создаем новый массив для результата.
		5. Перебираем все элементы старой матрицы.
		6. Вычисляем новый индекс в 1D массиве.
		7. Конвертируем новый индекс обратно в 2D координаты.
		8. Заполняем новый массив.

		TIME COMPLEXITY: O(m * n)
		Мы перебираем каждый элемент ровно один раз, выполняя константное количество операций, что дает сложность O(m * n).

		SPACE COMPLEXITY: O(m * n)
		Создается новый массив такого же размера, что и входная матрица, поэтому используем O(m * n) дополнительной памяти.
	*/
	m, n := len(grid), len(grid[0]) // Определяем размеры матрицы
	total := m * n                  // Общее количество элементов в матрице
	k = k % total                   // Оптимизируем количество сдвигов (если k > total)

	// Создаем новый массив для результата
	newGrid := make([][]int, m)
	for i := range newGrid {
		newGrid[i] = make([]int, n)
	}

	// Перебираем все элементы старой матрицы
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			// Вычисляем новый индекс в 1D массиве
			oldIndex := i*n + j
			newIndex := (oldIndex + k) % total

			// Конвертируем новый индекс обратно в 2D координаты
			newRow := newIndex / n
			newCol := newIndex % n

			// Заполняем новый массив
			newGrid[newRow][newCol] = grid[i][j]
		}
	}

	return newGrid
}

func main() {
	grid := [][]int{
		{1, 2, 3},
		{4, 5, 6},
		{7, 8, 9},
	}
	k := 1

	result := shiftGrid(grid, k)
	for _, row := range result {
		fmt.Println(row)
	}
}
