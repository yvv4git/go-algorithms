package main

import "fmt"

func checkIfExist(arr []int) bool {
	/*
	   Approach: Hash Table
	   Используем хэш-таблицу для отслеживания ранее встреченных элементов.
	   Для каждого элемента x выполняем две проверки:
	   1. Существует ли в таблице элемент 2*x (x = 0.5 * y, где y уже был)
	   2. Если x четный, существует ли x/2 (x = 2 * y, где y уже был)
	   Таким образом покрываем оба возможных сценария:
	   - текущий элемент может быть удвоенным от предыдущего
	   - предыдущий элемент может быть удвоенным от текущего

	   Time Complexity: O(n)
	   - Один проход по массиву (n элементов)
	   - Каждая операция с хэш-таблицей (вставка/поиск) занимает O(1) в среднем случае

	   Space Complexity: O(n)
	   - В худшем случае храним все элементы массива в хэш-таблице
	   - Дополнительная память растет линейно с размером входных данных

	   Особые случаи:
	   - Корректная обработка нуля (0 = 2*0)
	   - Проверка четности перед делением на 2
	*/
	// Создаем множество для отслеживания пройденных элементов
	seen := make(map[int]bool)
	for _, x := range arr {
		// Проверяем, есть ли в множестве элемент, равный 2*x (текущий элемент в два раза больше существующего)
		if seen[2*x] {
			return true
		}
		// Проверяем, является ли текущий элемент четным, и есть ли в множестве элемент, равный x/2 (текущий элемент в два раза меньше существующего)
		if x%2 == 0 && seen[x/2] {
			return true
		}
		// Добавляем текущий элемент в множество
		seen[x] = true
	}

	// Если ни одной пары не найдено, возвращаем false
	return false
}

func main() {
	// Тестовые случаи для проверки
	testCases := []struct {
		arr      []int
		expected bool
	}{
		{[]int{10, 2, 5, 3}, true},  // 10 = 2*5
		{[]int{3, 1, 7, 11}, false}, // Нет подходящих пар
		{[]int{0, 0}, true},         // 0 = 2*0
		{[]int{0}, false},           // Только один элемент
		{[]int{7, 1, 14, 11}, true}, // 14 = 2*7
	}

	// Проверяем каждый тестовый случай
	for _, tc := range testCases {
		result := checkIfExist(tc.arr)
		fmt.Printf("Массив: %v\nРезультат: %t\nОжидалось: %t\n\n", tc.arr, result, tc.expected)
	}
}
