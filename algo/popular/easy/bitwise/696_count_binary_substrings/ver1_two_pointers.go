package main

import "fmt"

// Функция для подсчета бинарных подстрок
func countBinarySubstrings(s string) int {
	/*
		METHOD: Two pointers
		В этом случае, мы используем два указателя: prevRun и currRun. prevRun отслеживает длину предыдущей группы одинаковых символов,
		а currRun отслеживает длину текущей группы одинаковых символов. Когда мы находим разные символы, мы обновляем count,
		используя минимальную длину между prevRun и currRun, так как минимальная длина определяет количество возможных бинарных подстрок.
		Затем мы сбрасываем prevRun на currRun и начинаем новый currRun с текущего символа.

		TIME COMPLEXITY: O(n), где n - длина входной строки, потому что мы проходим по строке только один раз.

		SPACE COMPLEXITY: O(1), так как мы используем фиксированное количество переменных, независимо от размера входной строки.
	*/
	// Инициализируем переменные для подсчета предыдущего и текущего символа
	prevRun, currRun := 0, 1
	// Инициализируем переменную для подсчета бинарных подстрок
	count := 0

	// Проходим по строке с 1 индекса
	for i := 1; i < len(s); i++ {
		// Если текущий символ равен предыдущему, увеличиваем текущий запуск
		if s[i] == s[i-1] {
			currRun++
		} else {
			// Иначе, обновляем предыдущий запуск и сбрасываем текущий
			count += min(prevRun, currRun)
			prevRun = currRun
			currRun = 1
		}
	}

	// Добавляем оставшиеся бинарные подстроки
	count += min(prevRun, currRun)

	// Возвращаем общее количество бинарных подстрок
	return count
}

// Функция для нахождения минимального значения из двух чисел
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func main() {
	// Пример использования
	s := "00110011"
	fmt.Println(countBinarySubstrings(s)) // Вывод: 6
}
