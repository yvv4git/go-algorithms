package main

import "fmt"

// Функция для вычисления периметра острова
func islandPerimeter(grid [][]int) int {
	/*
		METHOD:
		В данном случае, мы используем идею, что периметр острова определяется количеством границ между землей и водой.
		Мы просто подсчитываем границы, проверяя каждую ячейку и ее соседей.
		Это похоже на подход, используемый в алгоритмах обхода графа, таких как DFS или BFS,
		но здесь мы не используем рекурсию или очередь для обхода сетки.

		TIME COMPLEXITY: O(n*m), где n - количество строк в сетке, m - количество столбцов.
		Это связано с тем, что мы проходим по каждой ячейке сетки ровно один раз.

		SPACE COMPLEXITY: O(1), так как мы используем некоторые переменные для хранения результата,
		но не используем дополнительную память, зависящую от размера входных данных.
	*/
	// Проверка на пустую сетку
	if len(grid) == 0 || len(grid[0]) == 0 {
		return 0
	}

	// Инициализация переменной для хранения периметра
	perimeter := 0

	// Проход по всем ячейкам сетки
	for i := 0; i < len(grid); i++ {
		for j := 0; j < len(grid[0]); j++ {
			// Если ячейка является землей, то проверяем ее соседей
			if grid[i][j] == 1 {
				// Проверка соседа сверху
				if i == 0 || grid[i-1][j] == 0 {
					perimeter++
				}
				// Проверка соседа справа
				if j == len(grid[0])-1 || grid[i][j+1] == 0 {
					perimeter++
				}
				// Проверка соседа снизу
				if i == len(grid)-1 || grid[i+1][j] == 0 {
					perimeter++
				}
				// Проверка соседа слева
				if j == 0 || grid[i][j-1] == 0 {
					perimeter++
				}
			}
		}
	}

	return perimeter
}

func main() {
	// Пример использования функции
	grid := [][]int{
		{0, 1, 0, 0},
		{1, 1, 1, 0},
		{0, 1, 0, 0},
		{1, 1, 0, 0},
	}
	fmt.Println(islandPerimeter(grid)) // Вывод: 16
}
