package main

// Функция для дублирования нулей в массиве
func duplicateZerosV2(arr []int) {
	/*
		METHOD: Two pointers
		Используемый подход в этом коде - это двухуказательный подход,
		где мы используем два указателя i и j для прохода по исходному массиву и новому массиву соответственно.
		Указатель i используется для прохода по исходному массиву, а указатель j используется для записи изменений в новый массив.

		Этот код корректно дублирует нули в массиве, сохраняя длину массива неизменной.
		Он использует дополнительную память для создания копии исходного массива, чтобы не изменять его на месте.
		Затем он проходит по копии и использует два указателя i и j для записи изменений в исходный массив.
		Если текущий элемент не равен 0, то он просто копируется в новое место.
		Если текущий элемент равен 0, то он дублируется в новом массиве.

		TIME COMPLEXITY: O(n), где n - количество элементов в массиве, потому что мы проходим по массиву всего один раз.

		SPACE COMPLEXITY: O(n), так как мы создаем дополнительную копию исходного массива, чтобы не изменять его на месте.
	*/
	// Создаем копию исходного массива, чтобы не изменять его на месте
	original := make([]int, len(arr))
	copy(original, arr)

	// Инициализируем два указателя: i для прохода по исходному массиву, j для записи изменений
	i, j := 0, 0
	for i < len(original) && j < len(arr) {
		// Если текущий элемент не равен 0, то просто копируем его в новое место
		if original[i] != 0 {
			arr[j] = original[i]
			i++
			j++
		} else {
			// Если текущий элемент равен 0, то копируем его дважды
			arr[j] = 0
			if j+1 < len(arr) {
				arr[j+1] = 0
			}
			i++
			j += 2
		}
	}
}

//func main() {
//	// Пример использования функции duplicateZeros
//	arr := []int{1, 0, 2, 3, 0, 4, 5, 0}
//	fmt.Println("Original array:", arr)
//	duplicateZeros(arr)
//	fmt.Println("Array after duplicating zeros:", arr)
//}
