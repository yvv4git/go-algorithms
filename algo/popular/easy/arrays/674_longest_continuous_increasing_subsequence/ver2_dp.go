package main

// findLengthOfLCIS динамическим программированием находит длину самой длинной подпоследовательности возрастающих чисел в массиве nums.
func findLengthOfLCISV2(nums []int) int {
	/*
		METHOD: Dynamic programming
		В этом подходе мы создаем массив dp, где dp[i] будет содержать длину самой длинной подпоследовательности, оканчивающейся на i-м элементе.
		Затем мы итерируемся по массиву nums, сравнивая каждый элемент с предыдущим, и обновляем dp в зависимости от результата сравнения.

		TIME COMPLEXITY: O(n), где n - количество элементов в массиве nums, так как мы проходим по массиву всего один раз.

		SPACE COMPLEXITY: O(n), так как мы используем дополнительный массив dp размера n.
	*/
	if len(nums) == 0 {
		return 0
	}

	// Инициализируем массив dp, где dp[i] будет содержать длину подпоследовательности, оканчивающейся на i-м элементе.
	dp := make([]int, len(nums))
	for i := range dp {
		dp[i] = 1 // Каждый элемент является подпоследовательностью длины 1.
	}

	// Итерируемся по массиву nums, начиная со второго элемента.
	for i := 1; i < len(nums); i++ {
		// Если текущий элемент больше предыдущего, то расширяем подпоследовательность.
		if nums[i] > nums[i-1] {
			dp[i] = dp[i-1] + 1
		}
	}

	// Находим максимальную длину подпоследовательности.
	maxLength := 0
	for _, length := range dp {
		if length > maxLength {
			maxLength = length
		}
	}

	return maxLength
}

/*func main() {
	nums := []int{1, 3, 5, 4, 7}
	fmt.Println(findLengthOfLCIS(nums)) // Выведет: 3
}
*/
