package main

import "sort"

func relativeSortArrayV2(arr1 []int, arr2 []int) []int {
	/*
		METHOD: Counting
		Используемый подход в функции relativeSortArray - это подход "сортировки с использованием дополнительной памяти".
		Мы используем словарь (map в Go) для подсчета количества вхождений каждого элемента в arr1,
		что позволяет нам отсортировать элементы в соответствии с порядком, заданным в arr2.
		Затем мы собираем оставшиеся элементы из arr1 в отдельный список и сортируем их, используя встроенную функцию сортировки в Go.
		Наконец, мы объединяем отсортированные элементы из arr2 и отсортированные оставшиеся элементы из arr1 в один список,
		который и возвращается в качестве результата.

		TIME COMPLEXITY: O(n log n), где n - количество элементов в arr1

		SPACE COMPLEXITY: O(n) для хранения словаря и списка
	*/
	// Создаем словарь для хранения количества вхождений элементов из arr1
	count := make(map[int]int)
	for _, num := range arr1 {
		count[num]++
	}

	// Создаем результирующий массив для отсортированных элементов
	result := make([]int, 0, len(arr1))

	// Проходим по arr2 и добавляем элементы в соответствии с их количеством в arr1
	for _, num := range arr2 {
		for i := 0; i < count[num]; i++ {
			result = append(result, num)
		}
		// Удаляем элемент из словаря, чтобы не дублировать их в результирующем массиве
		delete(count, num)
	}

	// Создаем список для хранения оставшихся элементов из arr1
	remaining := make([]int, 0)
	for num, cnt := range count {
		for i := 0; i < cnt; i++ {
			remaining = append(remaining, num)
		}
	}

	// Сортируем оставшиеся элементы
	sort.Ints(remaining)

	// Добавляем отсортированные оставшиеся элементы в конец результирующего массива
	result = append(result, remaining...)

	return result
}
