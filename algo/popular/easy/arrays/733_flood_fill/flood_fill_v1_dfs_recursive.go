package _33_flood_fill

func floodFillV1(image [][]int, sr int, sc int, color int) [][]int {
	/*
		Method: DFS recursive
		Time complexity: O(n)
		Space complexity: O(1)

		Почему O(n)?
		1. Каждый пиксель в изображении будет посещен только один раз.
		2. Каждый пиксель будет посещаться только в том случае, если он еще не был посещен.
		3. Таким образом, алгоритм будет посещать каждый пиксель только один раз, и в худшем случае он будет посещать каждый пиксель.
		4. Поэтому, time complexity этого алгоритма будет O(n), где n - это общее количество пикселей в изображении.

		Вот базовый алгоритм:
		1. Сохраните цвет начального пикселя.
		2. Создайте пустую очередь или стек.
		3. Добавьте начальный пиксель в очередь или стек.
		4. Пока очередь или стек не пуст:
		5. Удалите пиксель из очереди или стека.
		6. Замените его цвет на новый цвет.
		7. Добавьте все соседние пиксели, которые имеют тот же цвет, как и начальный пиксель, в очередь или стек.
		8. Возвращаем измененное изображение.

		Важно обрабатывать случай, когда начальный пиксель уже имеет новый цвет, чтобы избежать бесконечного цикла.
		Этот алгоритм работает для любого изображения, независимо от его размера или формы.
		Он также работает для изображений с любым количеством цветов.
		Вам нужно реализовать этот алгоритм в вашем языке программирования.
	*/
	if image[sr][sc] == color {
		return image
	}
	dfs(image, sr, sc, image[sr][sc], color)

	return image
}

func dfs(image [][]int, i int, j int, startColor, newColor int) {
	// Проверяем, находится ли пиксель в границах изображения.
	// Если нет, то возвращаемся.
	if i < 0 || i >= len(image) || j < 0 || j >= len(image[0]) {
		return
	}

	// Проверяем, имеет ли пиксель тот же цвет, что и начальный пиксель.
	// Если нет, то возвращаемся.
	if image[i][j] != startColor {
		return
	}

	// Заменяем цвет пикселя на новый цвет.
	image[i][j] = newColor

	// Вызываем функцию dfs для всех соседних пикселей.
	// Это делается для всех четырех направлений: вверх, вниз, влево, вправо.
	dfs(image, i+1, j, startColor, newColor)
	dfs(image, i-1, j, startColor, newColor)
	dfs(image, i, j+1, startColor, newColor)
	dfs(image, i, j-1, startColor, newColor)
}
