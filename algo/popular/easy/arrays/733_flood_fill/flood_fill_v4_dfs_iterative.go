package _33_flood_fill

func floodFillV4(image [][]int, sr int, sc int, color int) [][]int {
	/*
		METHOD: DFS iterative.
		TIME COMPLEXITY: O(n)
		Space complexity: O(1)

		Асимптотическая сложность алгоритмов BFS, DFS, итеративного DFS и рекурсивного DFS в этой задаче одинаковая и равна O(n),
		где n - количество пикселей в изображении.
		Это связано с тем, что каждый пиксель в изображении посещается только один раз, и каждое посещение занимает константное время.
		Поэтому, если в изображении n пикселей, то время работы алгоритма будет линейно пропорционально n.

		В этом коде мы используем стек для хранения пикселей, которые нужно покрасить.
		Мы начинаем с начального пикселя и добавляем все его соседей в стек.
		Затем мы извлекаем последний пиксель из стека и проверяем,
		является ли он допустимым (то есть находится в границах изображения и имеет тот же цвет, что и начальный пиксель).
		Если пиксель допустимый, то мы красим его в новый цвет и добавляем все его соседей в стек.
	*/
	startColor := image[sr][sc]

	if startColor != color {
		dfsIterative(image, sr, sc, startColor, color)
	}

	return image
}

func dfsIterative(image [][]int, x int, y int, startColor int, color int) {
	type Point struct {
		x, y int
	}

	stack := []Point{{x, y}}
	for len(stack) > 0 {
		v := stack[len(stack)-1]
		stack = stack[:len(stack)-1]

		/*
			Проверяем является ли текущий пиксель валидным для покраски:
			1. v.x >= 0 && v.x < len(image): Проверяет, что координата x пикселя находится в пределах границ изображения.
			2. v.y >= 0 && v.y < len(image[0]): Проверяет, что координата y пикселя находится в пределах границ изображения.
			3. image[v.x][v.y] == startColor: Проверяет, что цвет пикселя совпадает с цветом, который нужно покрасить.
			Если цвета совпадают, то пиксель готов к покраске.
		*/
		if v.x >= 0 && v.x < len(image) && v.y >= 0 && v.y < len(image[0]) && image[v.x][v.y] == startColor {
			image[v.x][v.y] = color
			stack = append(
				stack,
				Point{v.x - 1, v.y},
				Point{v.x + 1, v.y},
				Point{v.x, v.y - 1},
				Point{v.x, v.y + 1})
		}
	}
}
