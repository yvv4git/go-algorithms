package main

// findShortestSubArrayV2 находит минимальную длину подмассива, который содержит все элементы максимальной частоты.
func findShortestSubArrayV2(nums []int) int {
	/*
		METHOD: Map / Dict

		TIME COMPLEXITY: O(n), где n - количество элементов в массиве.
		В худшем случае функция может пройти по всему массиву дважды: один раз для подсчета частоты элементов
		и второй раз для поиска минимальной длины подмассива.

		SPACE COMPLEXITY: O(n), так как в худшем случае мы можем хранить информацию о каждом элементе в массиве в двух словарях.
	*/
	// Определяем размер массива.
	size := len(nums)

	// Если размер массива меньше 2, то минимальная длина подмассива равна размеру массива.
	if size < 2 {
		return size
	}

	// Создаем два словаря:
	// 1. first для хранения индекса первого вхождения каждого элемента.
	// 2. count для подсчета частоты каждого элемента.
	first := make(map[int]int, size)
	count := make(map[int]int, size)

	// Инициализируем переменную minLen для хранения минимальной длины подмассива.
	// Инициализируем переменную maxCount для хранения максимальной частоты элемента.
	minLen := size
	maxCount := 1

	// Проходим по массиву nums и обновляем словари first и count.
	for i, n := range nums {
		// Увеличиваем счетчик частоты текущего элемента.
		count[n]++

		// Если это первое вхождение элемента, сохраняем его индекс.
		if count[n] == 1 {
			first[n] = i
		} else {
			// Вычисляем длину текущего подмассива, который содержит текущий элемент.
			l := i - first[n] + 1

			// Если текущая частота больше максимальной частоты или если текущая длина меньше minLen
			// и текущая частота равна максимальной частоте, обновляем maxCount и minLen.
			if maxCount < count[n] || (l < minLen && maxCount == count[n]) {
				maxCount = count[n]
				minLen = l
			}
		}
	}

	// Если все элементы в массиве разные, то минимальная длина подмассива равна 1.
	if len(count) == size {
		return 1
	}

	// Возвращаем минимальную длину подмассива.
	return minLen
}
