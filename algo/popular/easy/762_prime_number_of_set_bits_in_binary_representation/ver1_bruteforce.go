package main

import (
	"fmt"
)

// функция для проверки простоты числа
func isPrime(n int) bool {
	// если число меньше 2, оно не простое
	if n < 2 {
		return false
	}
	// проверяем делители от 2 до sqrt(n)
	for i := 2; i*i <= n; i++ {
		// если число делится на i, оно не простое
		if n%i == 0 {
			return false
		}
	}
	// если число не делится ни на одно из делителей, оно простое
	return true
}

// функция для подсчета количества единиц в двоичном представлении числа
func countSetBits(n int) int {
	// Функция countSetBits(i) подсчитывает количество единиц в двоичном представлении числа i.
	// Эта функция работает, используя операцию побитового сдвига, которая позволяет нам проверять каждый бит числа i за константное время.
	//
	// Поскольку число i имеет log n битов (где n - это число, для которого мы подсчитываем количество единиц),
	// функция countSetBits(i) требует log n операций побитового сдвига для проверки каждого бита.

	// Если мы рассмотрим число i = 16 (в двоичном представлении 10000), функция countSetBits(i) будет работать следующим образом:
	// 1. Проверяем первый бит (самый старший): 10000 -> 1 (единичка)
	// 2. Проверяем второй бит: 10000 -> 0 (ноль)
	// 3. Проверяем третий бит: 10000 -> 0 (ноль)
	// 4. Проверяем четвертый бит: 10000 -> 0 (ноль)
	// 5. Проверяем пятый бит: 10000 -> 0 (ноль)

	// используем операцию побитового сдвига для подсчета количества единиц
	count := 0
	for n > 0 {
		// если последний бит равен 1, увеличиваем счетчик
		if n&1 == 1 {
			count++
		}
		// сдвигаем число вправо на один бит
		n >>= 1
	}
	return count
}

func countPrimeSetBits(left int, right int) int {
	/*
		METHOD: Bruteforce
		перебираем числа от left до right, подсчитываем количество единиц в двоичном представлении каждого числа и проверяем, является ли это количество простым числом.

		TIME COMPLEXITY: O(n * √n)
		- перебираем все числа в диапазоне от left до right, что требует временной сложности O(n), где n - это разница между right и left.
		- для каждого числа в диапазоне, мы вызываем функцию countSetBits(i), которая подсчитывает количество единиц в двоичном представлении числа.
		Временная сложность этой функции составляет O(log n), где n - это число, для которого мы подсчитываем количество единиц.
		- также вызываем функцию isPrime(setBits), которая проверяет, является ли количество единиц простым числом.
		Временная сложность этой функции составляет O(√n), где n - это число, для которого мы проверяем простоту.

		SPACE COMPLEXITY: O(1)
	*/
	// инициализируем счетчик
	count := 0
	// проходим по всем числам от left до right
	for i := left; i <= right; i++ {
		// подсчитываем количество единиц в двоичном представлении числа
		setBits := countSetBits(i)
		// проверяем, является ли количество единиц простым числом
		if isPrime(setBits) {
			// если да, увеличиваем счетчик
			count++
		}
	}
	return count
}

func main() {
	// пример использования функции
	left := 6
	right := 10
	fmt.Println(countPrimeSetBits(left, right)) // выводит количество чисел в диапазоне от left до right, у которых количество единиц в двоичном представлении является простым числом
}
