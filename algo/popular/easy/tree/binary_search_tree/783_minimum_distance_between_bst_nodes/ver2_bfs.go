package main

import "math"

// Функция minDiffInBSTV2 находит минимальную разницу между узлами в бинарном дереве поиска.
func minDiffInBSTV2(root *TreeNode) int {
	/*
		Method: BFS
		Time complexity: O(n^2)
		Space complexity: O(n)

		Time complexity
		Временная сложность функции minDiffInBSTV2 в худшем случае составляет O(n^2), где n - количество узлов в дереве.
		Это происходит, потому что для каждого узла мы вызываем функцию minDiffInBST,
		которая в свою очередь вызывает getMaxRight и getMinLeft, которые также имеют линейную сложность O(n).

		Space complexity
		Пространственная сложность функции minDiffInBSTV2 составляет O(n),
		так как в худшем случае мы можем иметь n рекурсивных вызовов функции minDiffInBST,
		где n - количество узлов в дереве. Это происходит, потому что для каждого узла мы вызываем функцию minDiffInBST.

		BFS (Breadth-First Search) - это алгоритм обхода графа или дерева, который использует очередь для хранения узлов, которые нужно посетить.
		В BFS мы посещаем все соседние узлы перед тем, как перейти к следующему уровню узлов.

		Для задачи поиска минимальной разницы между узлами в бинарном дереве поиска (BST), где узлы упорядочены,
		BFS может быть неэффективным, поскольку он не учитывает упорядоченность узлов.
		В BST узлы с меньшими значениями находятся в левом поддереве, а узлы с большими значениями находятся в правом поддереве.
		Если мы используем BFS, мы можем пропустить узлы, которые могут дать меньшую разницу между узлами.

		In-Order Traversal (обход в порядке "слева-корень-справа") - это алгоритм обхода дерева,
		который использует стек для хранения узлов, которые нужно посетить. В этом методе мы сначала посещаем левое поддерево,
		затем корень, и в последствии правое поддерево. Этот метод эффективен для BST, поскольку он учитывает упорядоченность узлов.

		Таким образом, для задачи поиска минимальной разницы между узлами в BST, In-Order Traversal является более эффективным методом, чем BFS.
	*/
	// Если корень равен nil, то возвращаем максимально возможное значение int32.
	if root == nil {
		return math.MaxInt32
	}
	// Если у корня нет левого и правого дочернего узла, то возвращаем максимально возможное значение int32.
	if root.Left == nil && root.Right == nil {
		return math.MaxInt32
	}
	minX := math.MaxInt32
	// Если у корня есть левый дочерний узел, то обновляем minX минимальным значением между minX и разницей между значением корня и максимальным значением в левом поддереве.
	if root.Left != nil {
		minX = min(root.Val-getMaxRight(root.Left), minX)
		minX = min(minX, minDiffInBST(root.Left))
	}
	// Если у корня есть правый дочерний узел, то обновляем minX минимальным значением между minX и разницей между минимальным значением в правом поддереве и значением корня.
	if root.Right != nil {
		minX = min(minX, getMinLeft(root.Right)-root.Val)
		minX = min(minX, minDiffInBST(root.Right))
	}
	// Возвращаем minX.
	return minX
}

func getMaxRight(root *TreeNode) int {
	// Если у правого дочернего узла нет, то возвращаем значение корня.
	if root.Right == nil {
		return root.Val
	}
	// Иначе, возвращаем максимальное значение в правом поддереве.
	return getMaxRight(root.Right)
}

func getMinLeft(root *TreeNode) int {
	// Если у левого дочернего узла нет, то возвращаем значение корня.
	if root.Left == nil {
		return root.Val
	}
	// Иначе, возвращаем минимальное значение в левом поддереве.
	return getMinLeft(root.Left)
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
