package main

import (
	"math"
)

// Функция для вычисления наклона бинарного дерева с использованием BFS.
func findTiltV2(root *TreeNode) int {
	/*
		METHOD: BFS
		Используемый подход - это Breadth-First Search (BFS), где мы обходим дерево уровня за уровнем,
		используя очередь для отслеживания порядка обхода. Для каждого узла мы вычисляем сумму значений в его левом
		и правом поддереве, вычисляем наклон и добавляем его к общему наклону.

		Обратите внимание, что этот подход не эффективен для больших деревьев, так как его временная сложность O(N^2) неэффективна.
		Лучше использовать модифицированный Depth-First Search (DFS) или другой эффективный алгоритм для вычисления наклона бинарного дерева.

		TIME COMPLEXITY: O(n^2) в худшем случае, где n - количество узлов в дереве.
		Это происходит потому, что функция sumValues вызывается для каждого узла дерева,
		что приводит к повторению вычислений суммы значений узлов в поддеревьях.
		В худшем случае, когда дерево является сбалансированным, функция sumValues будет вызываться для каждого узла,
		что дает сложность O(n^2).

		SPACE COMPLEXITY: O(n) в худшем случае, где n - количество узлов в дереве.
		Это происходит потому, что в очереди queue хранятся все узлы дерева на каждом уровне,
		что приводит к использованию дополнительной памяти пропорционально количеству узлов.
	*/
	// Если дерево пустое, наклон равен 0.
	if root == nil {
		return 0
	}

	// Инициализация переменной для накопления общего наклона.
	tilt := 0
	// Инициализация очереди с корнем дерева.
	queue := []*TreeNode{root}

	// Пока очередь не пуста, выполняем обход дерева уровня за уровнем.
	for len(queue) > 0 {
		// Извлекаем первый элемент из очереди.
		node := queue[0]
		queue = queue[1:]

		// Вычисляем сумму значений в левом поддереве.
		leftSum := sumValues(node.Left)
		// Вычисляем сумму значений в правом поддереве.
		rightSum := sumValues(node.Right)
		// Добавляем разницу между суммами в наклон.
		tilt += int(math.Abs(float64(leftSum - rightSum)))

		// Если у узла есть левый потомок, добавляем его в очередь.
		if node.Left != nil {
			queue = append(queue, node.Left)
		}
		// Если у узла есть правый потомок, добавляем его в очередь.
		if node.Right != nil {
			queue = append(queue, node.Right)
		}
	}

	// Возвращаем общую величину наклона.
	return tilt
}

// Функция для вычисления суммы значений узлов в поддереве.
func sumValues(node *TreeNode) int {
	// Если узел пустой, возвращаем 0.
	if node == nil {
		return 0
	}

	// Рекурсивно вычисляем сумму значений узлов в поддереве.
	return node.Val + sumValues(node.Left) + sumValues(node.Right)
}

//func main() {
//	root := &TreeNode{
//		Val: 1,
//		Left: &TreeNode{
//			Val: 2,
//		},
//		Right: &TreeNode{
//			Val: 3,
//		},
//	}
//
//	fmt.Println(findTilt(root)) // Вывод: 1
//}
