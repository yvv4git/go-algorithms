package main

import (
	"fmt"
	"math"
)

// Функция для вычисления наклона бинарного дерева.
func findTilt(root *TreeNode) int {
	/*
		METHOD: DFS recursion
		Для решения этой задачи мы будем использовать подход на основе рекурсии.
		Мы будем рекурсивно обходить каждый узел дерева, вычислять сумму значений в левом и правом поддереве для каждого узла,
		а также накапливать наклон для текущего узла.

		TIME COMPLEXITY: O(n), где n - количество узлов в дереве, так как мы посещаем каждый узел ровно один раз.

		SPACE COMPLEXITY: O(n) в худшем случае, когда дерево является несбалансированным и высота дерева равна количеству узлов.
		В сбалансированном дереве пространственная сложность составляет O(log n), где log n - это глубина рекурсии.
	*/
	tilt := 0 // Начальное значение наклона.

	// Вспомогательная функция для рекурсивного вычисления суммы значений и накапливания наклона.
	var dfs func(*TreeNode) int
	dfs = func(node *TreeNode) int {
		if node == nil {
			return 0 // Базовый случай: если узел пустой, возвращаем 0.
		}

		leftSum := dfs(node.Left)   // Сумма значений в левом поддереве.
		rightSum := dfs(node.Right) // Сумма значений в правом поддереве.

		// Накапливаем наклон для текущего узла.
		tilt += int(math.Abs(float64(leftSum - rightSum)))

		// Возвращаем сумму значений текущего узла и его потомков.
		return node.Val + leftSum + rightSum
	}

	dfs(root) // Запускаем вычисление суммы значений и накапливания наклона.

	return tilt // Возвращаем общую величину наклона.
}

func main() {
	// Пример использования функции findTilt.
	root := &TreeNode{
		Val: 1,
		Left: &TreeNode{
			Val: 2,
		},
		Right: &TreeNode{
			Val: 3,
		},
	}

	fmt.Println(findTilt(root)) // Вывод: 1
}
