package _04_sum_of_left_leaves

func sumOfLeftLeavesV2(root *TreeNode) int {
	/*
		Method: BFS with queue.
		Time complexity: O(n), O(n log n).
		Space complexity: O(n).

		1. В лучшем случае, когда граф является деревом, временная сложность BFS будет O(n),
		где n - это количество узлов в дереве. Это происходит, когда мы посещаем каждый узел только один раз.

		2. В среднем случае, когда граф является сбалансированным деревом, временная сложность BFS будет O(n log n).

		3. В худшем случае, когда граф является списком, временная сложность BFS будет O(n^2),
		где n - это количество узлов в графе. Это происходит, когда мы посещаем каждый узел несколько раз.
		Но это возможно, если граф не является деревом и каждую вершину можно посетить более одного раза.

		Пространственная сложность BFS будет O(n), так как в очереди может быть n узлов.
		Это происходит, когда мы посещаем каждый узел только один раз.

		Однако, если граф не сбалансирован, то временная сложность может быть O(n^2) в худшем случае,
		если граф очень вытянут в одну сторону.

	*/
	if root == nil { // Проверка, вдруг дерево не существует.
		return 0
	}

	sum := 0
	queue := []*TreeNode{root} // Используем очередь.
	for len(queue) > 0 {
		node := queue[0]  // Берем первый элемент
		queue = queue[1:] // Удаляем первый элемент из слайса
		if node.Left != nil {
			// Если у этого узла есть левый потомок, мы проверяем, является ли он листом. Если да, мы добавляем его значение к сумме. Если нет, мы добавляем его в очередь.
			if node.Left.Left == nil && node.Left.Right == nil {
				sum += node.Left.Val
			} else {
				queue = append(queue, node.Left) // Добавляем в очередь
			}
		}

		// Если есть правая нода, то добавляем ее в очередь.
		if node.Right != nil {
			queue = append(queue, node.Right)
		}
	}

	return sum
}
