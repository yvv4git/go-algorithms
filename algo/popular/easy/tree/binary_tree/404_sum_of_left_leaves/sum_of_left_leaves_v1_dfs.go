package _04_sum_of_left_leaves

func sumOfLeftLeavesV1(root *TreeNode) int {
	/*
		METHOD: DFS recursion.
		TIME COMPLEXITY: O(n)
		Space complexity: O(n) - O(n^2)

		Time Complexity:
		В худшем случае, когда дерево является сбалансированным, временная сложность алгоритма будет O(n),
		где n - это общее количество узлов в дереве. Это происходит, когда мы посещаем каждый узел только один раз.

		Space Complexity:
		В худшем случае, когда дерево является сбалансированным, пространственная сложность алгоритма будет O(n),
		так как в стеке вызовов функции может быть n рекурсивных вызовов.
		Это происходит, когда мы посещаем каждый узел только один раз.

		Однако, если дерево не сбалансировано, то временная сложность может быть O(n^2) в худшем случае,
		если дерево очень вытянуто в одну сторону. В этом случае, пространственная сложность будет O(n),
		так как в стеке вызовов функции может быть n рекурсивных вызовов.
	*/
	if root == nil { // Проверяем, является ли корень узлом. Возможно дерево пустое.
		return 0
	}

	sum := 0
	if root.Left != nil && root.Left.Left == nil && root.Left.Right == nil { // Если левое поддерево существует и является листом(т.е. у него нет дочерних узлов), добавляем к sum.
		sum += root.Left.Val
	} else {
		sum += sumOfLeftLeavesV1(root.Left) // Если левое поддерево не является листом, мы вызываем функцию для левого поддерева.
	}

	sum += sumOfLeftLeavesV1(root.Right) // В противном случае ищем левые поддеревья в правом поддереве. Идем на уровень ниже.

	return sum
}
