package main

import (
	"fmt"
	"math"
)

// Функция minTimeToVisitAllPoints принимает слайс точек points, где каждая точка — это массив из двух целых чисел [x, y].
// Возвращает минимальное количество шагов, необходимое для посещения всех точек в заданном порядке.
func minTimeToVisitAllPoints(points [][]int) int {
	/*
		METHOD: Math
		Для решения этой задачи мы можем использовать формулу площади треугольника по трем вершинам.
		Если площадь треугольника не равна нулю, то это бумеранг.

		TIME COMPLEXITY: O(n)
		SPACE COMPLEXITY: O(1)
	*/
	// Инициализируем переменную totalSteps, которая будет хранить общее количество шагов.
	totalSteps := 0

	// Проходим по всем точкам, кроме последней, так как последнюю точку мы не будем сравнивать с следующей.
	for i := 0; i < len(points)-1; i++ {
		// Получаем текущую точку (x1, y1) и следующую точку (x2, y2).
		x1, y1 := points[i][0], points[i][1]
		x2, y2 := points[i+1][0], points[i+1][1]

		// Вычисляем разницу между координатами x и y.
		dx := int(math.Abs(float64(x2 - x1))) // Разница по оси X
		dy := int(math.Abs(float64(y2 - y1))) // Разница по оси Y

		// Минимальное количество шагов между двумя точками — это максимум из разниц по осям X и Y.
		// Это работает, потому что мы можем двигаться по диагонали, что позволяет нам сократить количество шагов.
		steps := int(math.Max(float64(dx), float64(dy)))

		// Добавляем количество шагов для перемещения между текущей и следующей точкой к общему количеству шагов.
		totalSteps += steps
	}

	// Возвращаем общее количество шагов.
	return totalSteps
}

func main() {
	// Пример входных данных.
	points := [][]int{{1, 1}, {3, 4}, {-1, 0}}

	// Вызываем функцию и выводим результат.
	result := minTimeToVisitAllPoints(points)
	fmt.Println("Минимальное время для посещения всех точек:", result)
}
