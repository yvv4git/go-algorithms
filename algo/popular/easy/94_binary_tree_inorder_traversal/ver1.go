package main

import "fmt"

// Определение структуры узла бинарного дерева
type TreeNode struct {
	Val   int
	Left  *TreeNode
	Right *TreeNode
}

// Функция для обхода бинарного дерева по порядку (inorder traversal)
func inorderTraversal(root *TreeNode) []int {
	/*
		METHOD: Рекурсивный обход
		Рекурсивный обход дерева по порядку (inorder traversal) выполняется следующим образом:
		1. Рекурсивно обходим левое поддерево.
		2. Добавляем значение текущего узла в результирующий список.
		3. Рекурсивно обходим правое поддерево.

		TIME COMPLEXITY: O(n)
		Временная сложность составляет O(n), где n — количество узлов в дереве.
		Это связано с тем, что каждый узел посещается ровно один раз.

		SPACE COMPLEXITY: O(n)
		Пространственная сложность также составляет O(n).
		В худшем случае (когда дерево вырождается в связный список), глубина рекурсии будет равна n,
		что приведет к использованию стека вызовов размером O(n).
		Кроме того, результирующий список также будет занимать O(n) памяти.
	*/
	// Результирующий список для хранения значений узлов
	result := []int{}

	// Вспомогательная функция для рекурсивного обхода дерева
	var inorder func(node *TreeNode)
	inorder = func(node *TreeNode) {
		// Если узел равен nil, возвращаемся (базовый случай)
		if node == nil {
			return
		}

		// Рекурсивно обходим левое поддерево
		inorder(node.Left)

		// Добавляем значение текущего узла в результирующий список
		result = append(result, node.Val)

		// Рекурсивно обходим правое поддерево
		inorder(node.Right)
	}

	// Запускаем рекурсивный обход с корневого узла
	inorder(root)

	// Возвращаем результирующий список
	return result
}

func main() {
	// Пример бинарного дерева
	root := &TreeNode{
		Val: 1,
		Left: &TreeNode{
			Val: 2,
			Left: &TreeNode{
				Val: 4,
			},
			Right: &TreeNode{
				Val: 5,
			},
		},
		Right: &TreeNode{
			Val: 3,
		},
	}

	// Вызываем функцию обхода дерева по порядку
	result := inorderTraversal(root)

	// Выводим результат
	fmt.Println(result) // Вывод: [4 2 5 1 3]
}
