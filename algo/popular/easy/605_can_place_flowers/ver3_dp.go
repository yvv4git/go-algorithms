package main

func canPlaceFlowersV3(flowerbed []int, n int) bool {
	/*
		METHOD: Dynamic Programming
		Данная функция использует динамическое программирование для проверки, можно ли посадить n цветов
		на клумбу, представленную массивом flowerbed, соблюдая правило, что цветы не должны расти рядом
		друг с другом. Функция создает массив dp, где dp[i] представляет максимальное количество цветов,
		которое можно посадить до позиции i. Затем она проходит по всем элементам массива flowerbed и
		обновляет значения в массиве dp, учитывая возможность посадки цветка на текущей позиции.
		Если в итоге dp[length] больше или равно n, функция возвращает true, иначе — false.

		TIME COMPLEXITY: O(N)
		Временная сложность данной функции составляет O(N), где N — длина массива flowerbed. Это связано
		с тем, что функция выполняет один проход по всем элементам массива.

		SPACE COMPLEXITY: O(N)
		Пространственная сложность данной функции составляет O(N), так как она использует дополнительный
		массив dp размером N+2 для хранения промежуточных результатов.
	*/
	length := len(flowerbed)    // Получаем длину массива flowerbed
	dp := make([]int, length+2) // Создаем массив dp для хранения максимального количества цветов до каждой позиции

	// Проходим по всем позициям в массиве flowerbed
	for i := 1; i <= length; i++ {
		if flowerbed[i-1] == 0 { // Если текущая позиция пуста
			dp[i] = dp[i-1]                   // Копируем значение из предыдущей позиции
			if i > 1 && flowerbed[i-2] == 0 { // Если предыдущая позиция также пуста
				dp[i] = max(dp[i], dp[i-2]+1) // Обновляем значение, учитывая возможность посадки цветка
			}
		}
	}

	// Возвращаем true, если максимальное количество цветов до последней позиции больше или равно n
	return dp[length] >= n
}

// Функция для нахождения максимума из двух чисел
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
