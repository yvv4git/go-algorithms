package main

import "fmt"

func canPlaceFlowers(flowerbed []int, n int) bool {
	/*
		METHOD: Greedy algorithm / Жадный алгоритм
		Данная функция проверяет, можно ли посадить n цветов на клумбу, представленную массивом flowerbed,
		соблюдая правило, что цветы не должны расти рядом друг с другом. Функция проходит по всем элементам
		массива и проверяет, можно ли посадить цветок на каждой пустой позиции (0). Если можно, то она
		помечает позицию как занятую (меняет 0 на 1) и увеличивает счетчик посаженных цветов. Если количество
		посаженных цветов достигает n, функция возвращает true. Если после прохода по массиву количество
		посаженных цветов меньше n, функция возвращает false.

		TIME COMPLEXITY:
		Временная сложность данной функции составляет O(N), где N — длина массива flowerbed. Это связано с тем,
		что функция выполняет один проход по всем элементам массива. В худшем случае, когда все позиции
		пустые, функция будет проверять каждую позицию на возможность посадки цветка.

		SPACE COMPLEXITY:
		Пространственная сложность данной функции составляет O(1), так как она использует фиксированное
		количество дополнительной памяти (переменные count, leftEmpty, rightEmpty) вне зависимости от
		размера входного массива. Массив flowerbed модифицируется на месте, и дополнительная память для
		хранения данных не выделяется.
	*/
	// Инициализируем счетчик для количества посаженных цветов
	count := 0

	// Проходим по всем позициям в массиве flowerbed
	for i := 0; i < len(flowerbed); i++ {
		// Проверяем, можно ли посадить цветок на текущей позиции
		if flowerbed[i] == 0 {
			// Проверяем, что позиция слева и справа пустая или это крайняя позиция
			leftEmpty := (i == 0) || (flowerbed[i-1] == 0)
			rightEmpty := (i == len(flowerbed)-1) || (flowerbed[i+1] == 0)

			// Если обе позиции слева и справа пустые, то можно посадить цветок
			if leftEmpty && rightEmpty {
				// Помечаем позицию как занятую
				flowerbed[i] = 1
				// Увеличиваем счетчик посаженных цветов
				count++

				// Если количество посаженных цветов равно n, то возвращаем true
				if count >= n {
					return true
				}
			}
		}
	}

	// Если после прохода по массиву количество посаженных цветов меньше n, возвращаем false
	return count >= n
}

func main() {
	// Примеры использования функции
	flowerbed1 := []int{1, 0, 0, 0, 1}
	n1 := 1
	fmt.Println(canPlaceFlowers(flowerbed1, n1)) // true

	flowerbed2 := []int{1, 0, 0, 0, 1}
	n2 := 2
	fmt.Println(canPlaceFlowers(flowerbed2, n2)) // false
}
