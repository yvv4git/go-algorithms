package main

import "fmt"

// Функция для постфиксного обхода n-арного дерева
func postorder(root *Node) []int {
	/*
		METHOD: DFS / Recursive Postorder Traversal
		Для решения задачи на Go мы будем использовать подход на основе рекурсии.
		Мы начнем с корня дерева и будем обходить каждый из его дочерних узлов, пока не достигнем листа дерева.
		Затем мы добавим значение листа в результирующий список и вернемся на уровень выше.

		В этом коде мы определяем структуру Node для представления узлов n-арного дерева.
		Функция postorder принимает корень дерева и возвращает список значений узлов в порядке постфиксного обхода.
		Внутри функции postorder мы определяем вспомогательную рекурсивную функцию traverse,
		которая выполняет обход дерева и добавляет значения узлов в результирующий список.

		Recursive Postorder Traversal, как уже было сказано, является частным случаем DFS.
		Он использует рекурсию для обхода дерева, но в отличие от обычного DFS, он сначала посещает все дочерние узлы узла, а затем сам узел.
		Это делает его частью Postorder Traversal, который посещает узлы в порядке: левое поддерево, правое поддерево, узел.

		Таким образом, Recursive Postorder Traversal - это частный случай DFS,
		который использует рекурсию и посещает узлы в порядке: левое поддерево, правое поддерево, узел.
		Он используется для получения списка значений узлов дерева в порядке постфиксного обхода.

		TIME COMPLEXITY: O(n), где n - количество узлов в дереве, потому что мы посещаем каждый узел ровно один раз.

		SPACE COMPLEXITY: O(n), так как в худшем случае мы можем поместить в стек n узлов при рекурсивном обходе.
	*/
	// Инициализация результирующего списка
	result := []int{}

	// Рекурсивная функция для обхода дерева
	var traverse func(*Node)
	traverse = func(node *Node) {
		// Если узел пустой, то выходим из функции
		if node == nil {
			return
		}

		// Обходим каждого из дочерних узлов
		for _, child := range node.Children {
			traverse(child)
		}

		// Добавляем значение узла в результирующий список
		result = append(result, node.Val)
	}

	// Запускаем обход с корня дерева
	traverse(root)

	// Возвращаем результирующий список
	return result
}

func main() {
	// Создаем дерево для примера
	root := &Node{Val: 1}
	root.Children = []*Node{
		&Node{Val: 3, Children: []*Node{
			&Node{Val: 5},
			&Node{Val: 6},
		}},
		&Node{Val: 2},
		&Node{Val: 4},
	}

	// Выводим результат обхода дерева
	fmt.Println(postorder(root)) // Вывод: [5, 6, 3, 2, 4, 1]
}
