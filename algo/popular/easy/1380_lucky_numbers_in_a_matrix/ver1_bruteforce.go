package main

import (
	"fmt"
)

// Функция для поиска счастливых чисел в матрице
func luckyNumbers(matrix [][]int) []int {
	/*
		METHOD: Brute Force
		Алгоритм работает так: для каждой строки находим минимальное значение и проверяем, является ли оно максимальным в своем столбце.
		Если да, то это число — "счастливое". Например, в матрице [[3, 7, 8], [9, 11, 13], [15, 16, 17]] число 15 — счастливое,
		потому что оно минимальное в своей строке и максимальное в своем столбце.

		TIME COMPLEXITY: O(m * n)
		- В худшем случае алгоритм проходит по всем элементам матрицы, что занимает O(m * n) времени, где m - количество строк, а n - количество столбцов в матрице.

		SPACE COMPLEXITY: O(1) (без учета памяти для результата)
		- Алгоритм использует константную дополнительную память, если не учитывать память для хранения результата (слайс luckyNumbers).
	*/
	// Создаем слайс для хранения счастливых чисел
	var luckyNumbers []int

	// Проходим по каждой строке матрицы
	for _, row := range matrix {
		// Находим минимальное значение в текущей строке
		minVal := row[0]
		minCol := 0
		for col, val := range row {
			if val < minVal {
				minVal = val
				minCol = col
			}
		}

		// Проверяем, является ли минимальное значение максимальным в своем столбце
		isMaxInCol := true
		for _, r := range matrix {
			if r[minCol] > minVal {
				isMaxInCol = false
				break
			}
		}

		// Если условие выполнено, добавляем число в список счастливых чисел
		if isMaxInCol {
			luckyNumbers = append(luckyNumbers, minVal)
		}
	}

	// Возвращаем список счастливых чисел
	return luckyNumbers
}

func main() {
	// Пример матрицы
	matrix := [][]int{
		{3, 7, 8},
		{9, 11, 13},
		{15, 16, 17},
	}

	// Вызов функции и вывод результата
	result := luckyNumbers(matrix)
	fmt.Println(result) // Ожидаемый вывод: [15]
}
