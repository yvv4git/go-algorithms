package main

import (
	"sort"
)

func findLHS(nums []int) int {
	/*
		МЕТОД: Sorting and Frequency Counting / Сортировка и подсчет частот

		ОПИСАНИЕ:
		1. Сортируем массив, чтобы сгруппировать одинаковые числа вместе.
		2. Используем карту для подсчета частоты каждого числа в массиве.
		3. Проходим по отсортированному массиву и для каждого числа проверяем, существует ли следующее число (num+1) в карте.
		4. Если оно существует, вычисляем длину гармоничной подпоследовательности как сумму частот num и num+1.
		5. Обновляем максимальную длину, если текущая подпоследовательность длиннее.

		ВРЕМЕННАЯ СЛОЖНОСТЬ: O(n log n)
		ОПИСАНИЕ:
		- Сортировка массива занимает O(n log n) времени.
		- Проход по массиву и заполнение карты частот занимает O(n) времени.
		- Проход по отсортированному массиву для поиска гармоничных подпоследовательностей также занимает O(n) времени.
		- Таким образом, общая временная сложность составляет O(n log n).

		ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ: O(n)
		ОПИСАНИЕ:
		- Использование карты для хранения частот чисел требует O(n) дополнительной памяти.
		- Сортировка может потребовать дополнительной памяти, но в худшем случае это также будет O(n).
		- Таким образом, общая пространственная сложность составляет O(n).
	*/
	// Сортируем массив
	sort.Ints(nums)

	// Создаем карту для подсчета частоты встречаемости чисел
	countMap := make(map[int]int)

	// Заполняем карту частотами
	for _, num := range nums {
		countMap[num]++
	}

	maxLen := 0

	// Проходим по отсортированному массиву
	for i := 0; i < len(nums); i++ {
		num := nums[i]
		// Проверяем, есть ли в массиве число num+1
		if countMap[num+1] > 0 {
			// Если есть, то считаем длину гармоничной подпоследовательности
			currLen := countMap[num] + countMap[num+1]
			// Обновляем максимальную длину
			if currLen > maxLen {
				maxLen = currLen
			}
		}
	}

	return maxLen
}

// func main() {
// 	nums := []int{1, 3, 2, 2, 5, 2, 3, 7}
// 	fmt.Println(findLHS(nums)) // Вывод: 5
// }
