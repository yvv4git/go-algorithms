package main

// findMinimumOperations находит минимальное количество операций, необходимых для того,
// чтобы сделать строки s1, s2 и s3 одинаковыми. Если это невозможно, возвращает -1.
func findMinimumOperations(s1, s2, s3 string) int {
	/*
		METHOD: Divide and conquer
		Time complexity: O(n)
		Space complexity: O(1) or O(n)

		Time complexity
		Для поиска общего префикса в строках s1, s2 и s3, а второй для вычисления количества операций.
		В худшем случае, когда общего префикса нет, временная сложность составляет O(n), где n - длина самой короткой строки.

		Space complexity
		Пространственная сложность функции также зависит от длины строк.
		В худшем случае, когда общего префикса нет, пространственная сложность составляет O(1),
		так как мы используем лишь несколько переменных для хранения длин строк и индекса.
		В целом, временная и пространственная сложности функции findMinimumOperations в худшем случае составляют O(n),
		где n - длина самой короткой строки.
	*/
	// Находим длины строк s1, s2 и s3
	l1, l2, l3 := len(s1), len(s2), len(s3)

	// Находим минимальную длину из трех строк
	minLen := min(l1, l2, l3)

	// Инициализируем счетчик i
	i := 0

	// Проходим по символам строк s1, s2 и s3 до минимальной длины
	for i < minLen {
		// Если символы в текущих позициях строк s1, s2 и s3 не равны, выходим из цикла
		if !(s1[i] == s2[i] && s2[i] == s3[i]) {
			break
		}
		// Увеличиваем счетчик i
		i++
	}

	// Если счетчик i больше 0, то мы нашли общий префикс для всех строк
	if i > 0 {
		// Возвращаем сумму длин всех строк минус длину общего префикса
		return l1 - i + l2 - i + l3 - i
	}

	// Если общий префикс не найден, возвращаем -1
	return -1
}

// Min возвращает минимальное из трех чисел
func min(a, b, c int) int {
	switch {
	case a <= b && a <= c:
		return a
	case b <= a && b <= c:
		return b
	default:
		return c
	}

}
