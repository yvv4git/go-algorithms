package main

import (
	"fmt"
)

func numEquivDominoPairs(dominoes [][]int) int {
	/*
		METHOD: Counting on hash table
		1. Нормализация домино: Для каждого домино (a, b) мы нормализуем его, всегда записывая меньшее число первым.
		2. Подсчет частот: Используем мапу для подсчета частоты каждого нормализованного домино.
		3. Подсчет пар: Для каждого уникального домино, если оно встречается freq раз, количество пар, которые можно составить из этих домино, равно freq * (freq - 1) / 2.

		TIME COMPLEXITY: O(n)
		- Проход по всем домино: O(n)
		- Проход по мапе для подсчета пар: O(n) в худшем случае, если все домино уникальны.

		SPACE COMPLEXITY: O(n)
		- Мапа для подсчета частот: O(n) в худшем случае, если все домино уникальны.
	*/
	// Создаем мапу для подсчета частоты каждого нормализованного домино
	count := make(map[[2]int]int)

	// Проходим по всем домино
	for _, domino := range dominoes {
		a, b := domino[0], domino[1]
		// Нормализуем домино, всегда записывая меньшее число первым
		if a > b {
			a, b = b, a
		}
		// Увеличиваем счетчик для данного нормализованного домино
		count[[2]int{a, b}]++
	}

	// Считаем количество пар
	pairs := 0
	for _, freq := range count {
		if freq > 1 {
			// Формула для подсчета количества пар из freq элементов
			pairs += freq * (freq - 1) / 2
		}
	}

	return pairs
}

func main() {
	// Пример использования
	dominoes := [][]int{{1, 2}, {2, 1}, {3, 4}, {4, 3}, {1, 2}}
	result := numEquivDominoPairs(dominoes)
	fmt.Println(result) // Вывод: 4
}
