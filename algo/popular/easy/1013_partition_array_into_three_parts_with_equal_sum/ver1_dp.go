//go:build ignore

package main

import "fmt"

func canThreePartsEqualSum(arr []int) bool {
	/*
		МЕТОД: Динамическое программирование
		- Используем динамическое программирование для решения задачи.
		- Создаем массив DP, где dp[i] представляет количество способов разделить массив на три части с равными суммами.

		TIME COMPLEXITY: O(n)
		- Мы проходим по массиву один раз, чтобы вычислить общую сумму и найти части с целевой суммой.
		- Каждый элемент массива обрабатывается один раз, что дает нам линейную сложность O(n).

		SPACE COMPLEXITY: O(1)
		- Мы используем только несколько дополнительных переменных (totalSum, targetSum, currentSum, partsCount),
		- которые занимают постоянное количество памяти, независимо от размера входного массива.
		- Таким образом, пространственная сложность составляет O(1).
	*/
	// Вычисляем общую сумму элементов массива
	totalSum := 0
	for _, num := range arr {
		totalSum += num
	}

	// Если общая сумма не делится на 3 без остатка, то невозможно разделить массив на три части с равными суммами
	if totalSum%3 != 0 {
		return false
	}

	// Вычисляем целевую сумму для каждой части
	targetSum := totalSum / 3

	// Инициализируем переменные для текущей суммы и счетчика найденных частей
	currentSum := 0
	partsCount := 0

	// Проходим по массиву и ищем части с целевой суммой
	for _, num := range arr {
		currentSum += num

		// Если текущая сумма равна целевой, это означает, что мы нашли одну из частей
		if currentSum == targetSum {
			partsCount++
			currentSum = 0 // Сбрасываем текущую сумму для поиска следующей части
		}
	}

	// Если мы нашли три части с целевой суммой, то возвращаем true
	return partsCount >= 3
}

func main() {
	arr := []int{0, 2, 1, -6, 6, -7, 9, 1, 2, 0, 1}
	fmt.Println(canThreePartsEqualSum(arr)) // Вывод: true
}
