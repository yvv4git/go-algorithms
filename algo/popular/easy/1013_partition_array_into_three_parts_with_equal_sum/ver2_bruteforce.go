//go:build ignore

package main

import "fmt"

func canThreePartsEqualSum(arr []int) bool {
	/*
		METHOD: Двухпроходный алгоритм с префиксными суммами
		- Используем двухпроходный алгоритм для решения задачи.
		- В первом проходе вычисляем общую сумму массива и проверяем, делится ли она на 3 без остатка.
		- Во втором проходе используем префиксные суммы для поиска частей массива с целевой суммой.

		TIME COMPLEXITY: O(n)
		- Мы проходим по массиву два раза, что дает нам линейную сложность O(n).
		- Первый проход для вычисления общей суммы: O(n).
		- Второй проход для поиска частей с целевой суммой: O(n).

		SPACE COMPLEXITY: O(1)
		- Мы используем только несколько дополнительных переменных (totalSum, targetSum, currentSum, partsCount),
		- которые занимают постоянное количество памяти, независимо от размера входного массива.
		- Таким образом, пространственная сложность составляет O(1).
	*/
	// Вычисляем общую сумму элементов массива
	totalSum := 0
	for _, num := range arr {
		totalSum += num
	}

	// Если общая сумма не делится на 3 без остатка, то невозможно разделить массив на три части с равными суммами
	if totalSum%3 != 0 {
		return false
	}

	// Вычисляем целевую сумму для каждой части
	targetSum := totalSum / 3

	// Инициализируем переменные для текущей суммы и счетчика найденных частей
	currentSum := 0
	partsCount := 0

	// Проходим по массиву и ищем части с целевой суммой
	for i, num := range arr {
		currentSum += num

		// Если текущая сумма равна целевой, это означает, что мы нашли одну из частей
		if currentSum == targetSum {
			partsCount++
			currentSum = 0 // Сбрасываем текущую сумму для поиска следующей части
		}

		// Если мы нашли три части с целевой суммой, то возвращаем true
		if partsCount == 3 && i < len(arr)-1 {
			return true
		}
	}

	// Если мы не нашли три части с целевой суммой, то возвращаем false
	return false
}

func main() {
	arr := []int{0, 2, 1, -6, 6, -7, 9, 1, 2, 0, 1}
	fmt.Println(canThreePartsEqualSum(arr)) // Вывод: true
}
