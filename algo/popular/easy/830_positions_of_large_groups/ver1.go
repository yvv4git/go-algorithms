package main

import (
	"fmt"
)

func largeGroupPositions(s string) [][]int {
	/*
		METHOD: Loop
		Описание метода:
		- Мы проходим по строке один раз, используя индекс `i`.
		- Для каждого символа проверяем, является ли он началом новой группы или продолжением существующей.
		- Если группа символов длиннее или равна 3, добавляем её начальную и конечную позиции в результирующий список.

		TIME COMPLEXITY: O(n)
		Описание временной сложности:
		- Алгоритм проходит по строке один раз, что требует O(n) операций, где n — длина строки.
		- Внутренний цикл также проходит по строке, но каждый символ обрабатывается только один раз, поэтому общая сложность остается O(n).

		SPACE COMPLEXITY: O(1)
		Описание пространственной сложности:
		- Дополнительная память используется только для хранения результата.
		- Размер результата зависит от количества больших групп, но не от длины строки.
		- В худшем случае, если все символы в строке разные, результат будет пустым, и дополнительная память не будет использоваться.
		- Таким образом, пространственная сложность является константной относительно длины строки, что обозначается как O(1).
	*/
	result := [][]int{} // Инициализация результирующего списка
	n := len(s)         // Длина строки
	i := 0              // Начальный индекс для итерации

	for i < n {
		start := i // Начальная позиция текущей группы
		// Проходим по строке, пока символы одинаковы
		for i < n && s[i] == s[start] {
			i++
		}

		// Если длина группы больше или равна 3
		if i-start >= 3 {
			result = append(result, []int{start, i - 1}) // Добавляем группу в результат
		}
	}

	return result // Возвращаем результат
}

func main() {
	// Примеры использования
	fmt.Println(largeGroupPositions("abbxxxxzzy"))        // [[3, 6]]
	fmt.Println(largeGroupPositions("abc"))               // []
	fmt.Println(largeGroupPositions("abcdddeeeeaabbbcd")) // [[3, 5], [6, 9], [12, 14]]
}
