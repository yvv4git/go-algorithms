package main

import (
	"fmt"
)

func main() {
	// Пример входных данных
	words := []string{"cat", "bt", "hat", "tree"}
	chars := "atach"

	// Вызываем функцию countCharacters
	result := countCharacters(words, chars)

	// Выводим результат
	fmt.Printf("Сумма длин слов, которые можно составить: %d\n", result)
}

// Функция countCharacters (определена выше)
func countCharacters(words []string, chars string) int {
	/*
		METHOD: Hash table & frequency array
		- Используется метод подсчёта частоты символов (частотный массив).
		- Для каждого слова проверяется, можно ли его составить из символов строки chars,
		  используя частотный массив.

		Вы создаете массив charCount размером 26 (по количеству букв в английском алфавите).
		Затем вы проходите по строке chars и увеличиваете соответствующий индекс в массиве для каждого символа.
		Для каждого слова в массиве words вы создаете копию массива charCount и проверяете, можно ли составить слово из символов, имеющихся в строке chars.

		TIME COMPLEXITY:
		- O(n * m), где:
		  - n — количество слов в массиве words.
		  - m — средняя длина слов в массиве words.
		- Обход строки chars: O(c), где c — длина строки chars.
		- Итоговая сложность: O(n * m + c).

		SPACE COMPLEXITY:
		- O(1), так как используется фиксированный массив размером 26 (для английского алфавита).
		- Дополнительно используется массив tempCount размером 26 для каждого слова,
		  но он не увеличивает пространственную сложность, так как размер фиксирован.
	*/
	// Создаем массив для подсчета частоты символов в строке chars.
	charCount := make([]int, 26)

	// Заполняем массив частотами символов из строки chars.
	for _, char := range chars {
		charCount[char-'a']++
	}

	// Переменная для хранения общей длины подходящих слов.
	result := 0

	// Итерируемся по каждому слову в массиве words.
	for _, word := range words {
		// Создаем копию массива charCount, чтобы не изменять оригинал.
		tempCount := make([]int, 26)
		copy(tempCount, charCount)

		// Флаг, который показывает, можно ли составить текущее слово.
		canForm := true

		// Проверяем каждый символ в текущем слове.
		for _, char := range word {
			index := char - 'a'
			// Если символа не хватает, устанавливаем флаг в false и выходим из цикла.
			if tempCount[index] == 0 {
				canForm = false
				break
			}
			// Уменьшаем количество символов в копии.
			tempCount[index]--
		}

		// Если слово можно составить, добавляем его длину к результату.
		if canForm {
			result += len(word)
		}
	}

	// Возвращаем общую длину подходящих слов.
	return result
}
