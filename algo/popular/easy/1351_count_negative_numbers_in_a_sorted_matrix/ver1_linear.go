package main

func countNegatives(grid [][]int) int {
	/*
		APPROACH: Линейный проход с оптимизацией

		Идея: Используем тот факт, что матрица отсортирована по строкам и столбцам.
		Начинаем с нижнего левого угла матрицы и двигаемся вправо и вверх.
		Если текущий элемент отрицательный, то все элементы справа в этой строке также отрицательные.
		Таким образом, мы можем пропускать их и увеличивать счётчик на количество оставшихся элементов в строке.

		TIME COMPLEXITY: O(m + n)
		- В худшем случае мы проходим каждую строку и каждый столбец только один раз.
		- Это эффективнее, чем полный перебор всех элементов (O(m*n)).

		SPACE COMPLEXITY: O(1)
		- Мы используем только константное количество дополнительной памяти (счётчик и переменные для индексов).
	*/
	// Инициализируем счётчик отрицательных чисел
	count := 0

	// Получаем количество строк и столбцов в матрице
	rows := len(grid)
	cols := len(grid[0])

	// Начинаем с последней строки и первого столбца
	row := rows - 1
	col := 0

	// Проходим по матрице
	for row >= 0 && col < cols {
		// Если текущий элемент отрицательный
		if grid[row][col] < 0 {
			// Все элементы в этой строке справа также будут отрицательными
			count += cols - col
			// Переходим на строку выше
			row--
		} else {
			// Иначе переходим к следующему столбцу
			col++
		}
	}

	// Возвращаем общее количество отрицательных чисел
	return count
}

func main() {
	// Пример матрицы
	grid := [][]int{
		{4, 3, 2, -1},
		{3, 2, 1, -1},
		{1, 1, -1, -2},
		{-1, -1, -2, -3},
	}

	// Вызов функции и вывод результата
	result := countNegatives(grid)
	println(result) // Ожидаемый результат: 8
}
