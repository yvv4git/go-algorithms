//go:build ignore

package main

import "fmt"

func smallerNumbersThanCurrent(nums []int) []int {
	/*
		METHOD: Prefix Sums (Префиксные суммы)
		DESCRIPTION:
			- Используем метод подсчета (Counting Sort) для подсчета количества вхождений каждого числа.
			- Затем применяем префиксные суммы, чтобы вычислить количество элементов, меньших текущего.
			- Этот подход эффективен, если диапазон значений ограничен (например, от 0 до 100).

		TIME COMPLEXITY: O(n + k), где:
			- n — количество элементов в массиве nums.
			- k — диапазон значений (в данном случае 101, так как числа от 0 до 100).
			- Подсчет вхождений: O(n).
			- Вычисление префиксных сумм: O(k).
			- Заполнение результирующего массива: O(n).

		SPACE COMPLEXITY: O(k), где:
			- k — диапазон значений (101 в данном случае).
			- Используется дополнительный массив count для хранения количества вхождений и префиксных сумм.
			- Результирующий массив не учитывается в пространственной сложности, так как он является выходными данными.
	*/

	// Создаём массив для хранения количества вхождений каждого числа
	count := make([]int, 101)

	// Подсчитываем количество вхождений каждого числа в массиве nums
	// Временная сложность: O(n)
	for _, num := range nums {
		count[num]++
	}

	// Префиксные суммы: преобразуем массив count так, чтобы для каждого числа хранилось количество элементов, меньших этого числа
	// Временная сложность: O(k), где k = 101
	for i := 1; i < 101; i++ {
		count[i] += count[i-1]
	}

	// Создаём результирующий массив для хранения ответа
	result := make([]int, len(nums))

	// Заполняем результирующий массив
	// Временная сложность: O(n)
	for i, num := range nums {
		if num > 0 {
			// Для числа num результатом будет количество элементов, меньших num, которое хранится в count[num-1]
			result[i] = count[num-1]
		} else {
			// Если num равно 0, то результатом будет 0, так как нет чисел меньше 0
			result[i] = 0
		}
	}

	return result
}

func main() {
	// Пример ввода
	nums := []int{8, 1, 2, 2, 3}

	// Вызываем функцию и получаем результат
	result := smallerNumbersThanCurrent(nums)

	// Выводим результат
	for _, num := range result {
		fmt.Print(num, " ")
	}
	// Output: 4 0 1 1 3
}
