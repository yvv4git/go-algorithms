package _971_find_if_path_exists_in_graph

// Функция для проверки существования пути между двумя вершинами в графе
func validPathV1(n int, edges [][]int, start int, end int) bool {
	/*
		METHOD: DFS
		TIME COMPLEXITY: O(n + m), где n - количество вершин, m - количество ребер
		Space complexity: O(n + m), где n - количество вершин, m - количество ребер

		Time complexity
		Временная сложность алгоритма validPath в худшем случае составляет O(n + m), где n - количество вершин, m - количество ребер.
		1. Построение графа: Время построения графа пропорционально количеству ребер.
		В худшем случае, когда граф полностью связанный, количество ребер будет равно количеству вершин минус один (n - 1).
		Поэтому временная сложность составляет O(n + m).

		2. Поиск пути: В худшем случае, когда мы должны обойти все вершины, алгоритм может посетить каждую вершину и каждое ребро.
		Поэтому временная сложность составляет O(n + m).

		Таким образом, временная сложность O(n + m) связана с построением графа и поиском пути.

		Space complexity
		Пространственная сложность O(n + m) в данном случае связана с хранением графа и массива посещенных вершин.
		1. Граф представлен в виде списка смежности. Для каждой вершины мы храним список смежных вершин.
		В худшем случае, когда граф полностью связанный, количество ребер будет равно количеству вершин минус один (n - 1).
		Поэтому пространственная сложность составляет O(n + m), где m - количество ребер.

		2. Массив посещенных вершин. Для каждой вершины мы храним информацию о том, была ли она посещена.
		В худшем случае, когда мы должны обойти все вершины, количество вершин будет равно n.
		Поэтому пространственная сложность составляет O(n + m), где n - количество вершин.

		Таким образом, пространственная сложность O(n + m) связана с хранением графа и массива посещенных вершин.
	*/

	// Создание графа из ребер
	graph := make([][]int, n)
	for _, edge := range edges {
		graph[edge[0]] = append(graph[edge[0]], edge[1])
		graph[edge[1]] = append(graph[edge[1]], edge[0])
	}

	// Создание массива для отслеживания посещенных вершин
	visited := make([]bool, n)

	// Вызов функции dfs для проверки существования пути
	return dfs(graph, visited, start, end)
}

// Функция для поиска пути в графе с помощью поиска в глубину
// Сложность по времени: O(n + m), где n - количество вершин, m - количество ребер
// Сложность по пространству: O(n), где n - глубина рекурсии
func dfs(graph [][]int, visited []bool, start int, end int) bool {
	// Если начальная и конечная вершины совпадают, то путь существует
	if start == end {
		return true
	}

	// Пометить текущую вершину как посещенную
	visited[start] = true

	// Для каждой непосещенной вершины, смежной с текущей
	for _, node := range graph[start] {
		// Если вершина еще не посещена и существует путь до конечной вершины
		if !visited[node] && dfs(graph, visited, node, end) {
			// То путь существует
			return true
		}
	}

	// Если мы дошли до этой точки, то пути не существует
	return false
}
