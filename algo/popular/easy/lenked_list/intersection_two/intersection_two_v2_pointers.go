package intersection_two

func getIntersectionNodeV2(headA, headB *ListNode) *ListNode {
	/*
		METHOD: Using two pointers.
		Time complexity: O(n + m)
		Space complexity: O(1)

		Объяснение: Здесь есть хитрость, которая ни всегда очевидна.
		- Если оба списка имеют одинаковую длину, то двигая оба указателя за итерацию на 1 шаг, то в какой-то момент они пересекутся на требуемой ListNode.
		Если же пересечения нет, то они пересекутся на nil.
		- Когда оба листа имеют разную длину, тут уже сложнее. Двигая их на один шаг за итерацию, мы никогда не получим пересечение.
		Но, если их как-то уравнять. В общем, когда первый из них доходит до конца, то он переключается на начало другого списка.
		Второй аналогично. Это приведет к тому, что они окажутся на одинаковом расстоянии и до конца им останется одно количество ListNode.
		Проблема решена! Остается двигаться на 1 шаг, пока либо они не пересекутся на пересечении, либо они оба не окажутся равными nil, т.е. дойдут до конца.
	*/
	ptrA, ptrB := headA, headB

	for ptrA != ptrB {
		if ptrA == nil {
			ptrA = headB
		} else {
			ptrA = ptrA.Next
		}

		if ptrB == nil {
			ptrB = headA
		} else {
			ptrB = ptrB.Next
		}
	}

	return ptrA
}
