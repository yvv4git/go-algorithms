package _07_perfect_number

func checkPerfectNumberV1(num int) bool {
	/*
		TIME COMPLEXITY: O(sqrt(n))
		SPACE COMPLEXITY: O(1)

		Это связано с тем, что в цикле for происходит проверка условия left < right, которая выполняется до тех пор,
		пока left не станет больше или равна right. Количество итераций цикла будет равно корню из num,
		так как left увеличивается на 1 на каждой итерации.
		Таким образом, время выполнения цикла будет пропорционально квадратному корню из num,
		что дает асимптотическую сложность O(sqrt(n)).

		Таким образом, алгоритм проверяет все возможные делители числа и проверяет, равна ли сумма этих делителей исходному числу.
		Если да, то число является "хорошим", и функция возвращает true. Если нет, то функция возвращает false.
	*/
	if num == 1 {
		// Если число равно 1, то оно не является совершенным.
		return false
	}

	sum := 1  // Здесь 1 потому, что 1 - это делитель любого числа.
	left := 2 // инициализируется как 2, потому что мы начинаем проверять делители числа num, начиная с самого маленького возможного делителя, который может быть больше 1.
	for {     // METHOD: Two pointer.
		right := num / left
		if left >= right {
			break
		}
		if num%left == 0 { // если число делится на left без остатка, то числа добавляются к результату.
			sum = sum + left + right
		}
		left++
	}

	if sum == num {
		return true
	}

	return false
}
