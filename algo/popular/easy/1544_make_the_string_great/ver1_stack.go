package main

import (
	"fmt"
)

func makeGood(s string) string {
	/*
		METHOD: Stack
		Используем стек для обработки символов строки. Стек позволяет эффективно удалять "плохие" пары символов
		(символы, которые являются одной и той же буквой, но в разных регистрах, например, "aA" или "bB").
		Алгоритм проходит по каждому символу строки и проверяет, образует ли он "плохую" пару с верхним элементом стека.
		Если пара найдена, верхний элемент удаляется из стека. В противном случае символ добавляется в стек.
		В результате в стеке остаются только символы, которые не образуют "плохих" пар.

		TIME COMPLEXITY: O(n), где n - длина строки s
		Алгоритм проходит по каждому символу строки один раз. Каждая операция добавления или удаления элемента из стека
		выполняется за O(1). Таким образом, общая временная сложность составляет O(n).

		SPACE COMPLEXITY: O(n)
		В худшем случае, если строка не содержит "плохих" пар, стек будет содержать все символы строки.
		Например, для строки "abc" стек будет содержать все три символа. Поэтому пространственная сложность составляет O(n).
	*/
	stack := []rune{} // Используем срез рун для работы с символами

	for _, char := range s {
		// Если стек не пуст и текущий символ образует "плохую" пару с верхним элементом стека
		if len(stack) > 0 && abs(int(stack[len(stack)-1])-int(char)) == 32 {
			// Удаляем верхний элемент стека, так как найдена "плохая" пара
			stack = stack[:len(stack)-1]
		} else {
			// Добавляем текущий символ в стек, если он не образует "плохую" пару
			stack = append(stack, char)
		}
	}

	// Преобразуем срез рун обратно в строку и возвращаем результат
	return string(stack)
}

// Функция для вычисления абсолютного значения
func abs(x int) int {
	if x < 0 {
		return -x
	}
	return x
}

func main() {
	// Примеры использования
	fmt.Println(makeGood("leEeetcode")) // Вывод: "leetcode"
	fmt.Println(makeGood("abBAc"))      // Вывод: "c"
	fmt.Println(makeGood("sS"))         // Вывод: ""
}
