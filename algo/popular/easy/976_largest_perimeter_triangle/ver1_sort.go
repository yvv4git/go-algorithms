package main

import (
	"fmt"
	"sort"
)

func largestPerimeter(nums []int) int {
	/*
		METHOD: Sorting.
		Описание: Данный метод основан на сортировке массива по убыванию.
		После сортировки мы проверяем каждую тройку соседних элементов,
		начиная с самого большого, чтобы найти наибольший периметр треугольника.

		TIME COMPLEXITY: O(n log n)
		Описание: Временная сложность определяется сортировкой массива, которая занимает O(n log n) времени, где n — количество элементов в массиве.
		Проход по массиву для проверки каждой тройки соседних элементов занимает O(n) времени.
		Общая сложность алгоритма составляет O(n log n), так как сортировка доминирует над проходом по массиву.

		SPACE COMPLEXITY: O(1)
		Описание: Пространственная сложность алгоритма составляет O(1), что означает постоянное количество дополнительной памяти.
		Мы не создаем новых массивов или структур данных, которые бы росли с увеличением размера входного массива.
	*/
	// Сортируем массив по убыванию
	// Временная сложность сортировки: O(n log n)
	sort.Sort(sort.Reverse(sort.IntSlice(nums)))

	// Проходим по массиву и проверяем каждую тройку соседних элементов
	// Временная сложность прохода по массиву: O(n)
	for i := 0; i < len(nums)-2; i++ {
		// Проверяем условие неравенства треугольника
		if nums[i] < nums[i+1]+nums[i+2] {
			// Если условие выполняется, возвращаем периметр
			return nums[i] + nums[i+1] + nums[i+2]
		}
	}

	// Если не найдено ни одной тройки, удовлетворяющей условию, возвращаем 0
	return 0
}

func main() {
	// Примеры использования функции
	nums1 := []int{2, 1, 2}
	fmt.Println(largestPerimeter(nums1)) // Вывод: 5

	nums2 := []int{1, 2, 1}
	fmt.Println(largestPerimeter(nums2)) // Вывод: 0
}
