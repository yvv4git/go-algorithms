package main

import (
	"fmt"
	"math"
)

var ans []string         // Глобальная переменная для хранения результатов
var lenOfLargest int     // Глобальная переменная для хранения длины самой длинной валидной строки
var minRemoved int       // Глобальная переменная для хранения минимального количества удаленных скобок
var seen map[string]bool // Глобальная переменная для отслеживания посещенных состояний

// Основная функция для удаления неправильных скобок
func removeInvalidParenthesesV2(s string) []string {
	ans = []string{}                          // Инициализация результирующего списка
	seen = make(map[string]bool)              // Инициализация множества для отслеживания посещенных состояний
	lenOfLargest, minRemoved = 0, math.MaxInt // Инициализация переменных для отслеживания длины самой длинной валидной строки и минимального количества удаленных скобок

	solve(s, "", 0, 0, 0) // Начало рекурсивного поиска
	return ans            // Возвращение результата
}

// Рекурсивная функция для поиска валидных скобочных последовательностей
func solve(str, cur string, balance, start, removed int) {
	if balance < 0 {
		return
	}

	// Если баланс отрицательный, значит, есть лишняя закрывающая скобка, поэтому выходим
	if removed > minRemoved {
		return
	}

	// Если удалено больше скобок, чем минимально необходимо, выходим
	if seen[fmt.Sprintf("%v:%v", cur, start)] {
		return
	}

	// Если текущее состояние уже было посещено, выходим
	seen[fmt.Sprintf("%v:%v", cur, start)] = true // Помечаем текущее состояние как посещенное
	if start == len(str) {                        // Если достигли конца строки
		if balance == 0 && lenOfLargest <= len(cur) { // Если баланс равен нулю и длина текущей строки не меньше текущей максимальной длины
			if lenOfLargest < len(cur) { // Если длина текущей строки больше текущей максимальной длины
				ans = []string{}        // Очищаем результирующий список
				lenOfLargest = len(cur) // Обновляем максимальную длину
				minRemoved = removed    // Обновляем минимальное количество удаленных скобок
			}
			ans = append(ans, cur) // Добавляем текущую строку в результат
		}
		return // Выходим
	}

	solve(str, cur+string(str[start]), balance+balanceInt(str[start]), start+1, removed) // Рекурсивный вызов с добавлением текущего символа
	solve(str, cur, balance, start+1, removed+1)                                         // Рекурсивный вызов без добавления текущего символа
}

// Функция для определения баланса скобок
func balanceInt(b byte) int {
	switch b {
	case '(':
		return 1 // Открывающая скобка увеличивает баланс на 1
	case ')':
		return -1 // Закрывающая скобка уменьшает баланс на 1
	}
	return 0 // Если символ не скобка, баланс не меняется
}
