package main

import (
	"fmt"
)

// Функция для проверки, является ли строка правильной скобочной последовательностью
func isValid(s string) bool {
	count := 0
	for _, char := range s {
		if char == '(' {
			count++
		} else if char == ')' {
			count--
			if count < 0 {
				return false
			}
		}
	}
	return count == 0
}

// Основная функция для удаления неправильных скобок
func removeInvalidParentheses(s string) []string {
	/*
		METHOD: BFS
		Этот алгоритм используется для обхода или поиска в структуре данных в виде дерева или графа,
		начиная с корневого узла и исследуя все соседние узлы на текущем уровне перед переходом на следующий уровень.
		В данном случае, BFS применяется для поиска всех возможных комбинаций строки после удаления скобок,
		начиная с исходной строки и постепенно удаляя по одной скобке за раз, пока не будут найдены все валидные скобочные последовательности.

		TIME COMPLEXITY: O(n * 2^n)
		- В худшем случае, каждый символ в строке может быть удален, что приводит к O(2^n) возможным комбинациям, где n — длина строки.
		- Проверка каждой комбинации на валидность занимает O(n) времени.
		Таким образом, общая временная сложность составляет O(n * 2^n).

		SPACE COMPLEXITY: O(2^n)
		- Мы используем очередь для хранения всех возможных комбинаций, что может занимать до O(2^n) пространства.
		- Множество visited также может занимать до O(2^n) пространства.
		Таким образом, общая пространственная сложность составляет O(2^n)
	*/
	result := []string{} // Инициализация результирующего списка
	if s == "" {
		return result // Если входная строка пуста, возвращаем пустой список
	}

	visited := make(map[string]bool) // Создание множества для отслеживания посещенных строк
	queue := []string{s}             // Инициализация очереди с начальной строкой
	found := false                   // Флаг для отслеживания, найдена ли хотя бы одна валидная строка

	for len(queue) > 0 { // Пока очередь не пуста
		current := queue[0] // Берем первую строку из очереди
		queue = queue[1:]   // Удаляем ее из очереди

		if visited[current] { // Если строка уже была посещена
			continue // Пропускаем ее
		}
		visited[current] = true // Помечаем строку как посещенную

		if isValid(current) { // Если текущая строка является валидной скобочной последовательностью
			result = append(result, current) // Добавляем ее в результат
			found = true                     // Устанавливаем флаг, что хотя бы одна валидная строка найдена
		}

		if found { // Если хотя бы одна валидная строка найдена
			continue // Пропускаем генерацию новых строк, так как нас интересуют только минимальные изменения
		}

		for i := 0; i < len(current); i++ { // Перебираем все символы в текущей строке
			if current[i] != '(' && current[i] != ')' { // Если символ не является скобкой
				continue // Пропускаем его
			}
			next := current[:i] + current[i+1:] // Создаем новую строку, удаляя текущий символ
			queue = append(queue, next)         // Добавляем новую строку в очередь
		}
	}

	return result
}

func main() {
	s := "()())()"
	result := removeInvalidParentheses(s)
	fmt.Println(result) // ["()()()", "(())()"]
}
