package main

func minCut(s string) int {
	/*
		METHOD: Dynamic programming
		В этом коде мы используем два вложенных цикла for для проверки всех возможных палиндромов в строке s.
		Эти циклы проверяют палиндромы с различными центрами и длинами.
		1. В этом коде мы используем два вложенных цикла for для проверки всех возможных палиндромов в строке s.
		Эти циклы проверяют палиндромы с различными центрами и длинами.
		2. Проверяем палиндромы с четным количеством символов:
		Во втором цикле мы проверяем палиндромы, у которых два центральных символа.
		Например, в строке "abba" центральными символами будут 'b' и 'b', а палиндромом будет вся строка "abba".

		Почему сначала проверяются палиндромы с нечетным количеством символов, а затем с четным?
		Это связано с тем, как мы строим палиндромы. Когда мы проверяем палиндромы с нечетным количеством символов,
		мы начинаем с центрального символа и расширяемся в обе стороны.
		Например, для строки "aba" центральным символом будет 'b', и мы будем проверять, является ли вся строка палиндромом.

		Когда мы переходим к проверке палиндромов с четным количеством символов, мы также начинаем с центрального символа,
		но теперь у нас два центральных символа. Мы проверяем, является ли палиндромом строка,
		состоящая из двух центральных символов и символов, симметричных относительно этих центров.

		Таким образом, сначала мы проверяем палиндромы с нечетным количеством символов, а затем с четным, чтобы построить все возможные палиндромы в строке.

		TIME COMPLEXITY: O(n^2), где n - длина входной строки,
		так как мы проходим по всем подстрокам и для каждой подстроки проверяем, является ли она палиндромом.

		SPACE COMPLEXITY: O(n^2), так как мы используем массив dp размером n x n для хранения результатов.
	*/
	n := len(s)

	// Создаем массив dp для хранения минимального количества разбиений
	dp := make([]int, n+1)
	for i := range dp {
		dp[i] = i - 1
	}

	// Проходим по всем подстрокам
	for i := 0; i < n; i++ {
		// Проверяем палиндромы с нечетным количеством символов
		for j := 0; i-j >= 0 && i+j < n && s[i-j] == s[i+j]; j++ {
			dp[i+j+1] = min(dp[i+j+1], dp[i-j]+1)
		}

		// Проверяем палиндромы с четным количеством символов
		for j := 1; i-j+1 >= 0 && i+j < n && s[i-j+1] == s[i+j]; j++ {
			dp[i+j+1] = min(dp[i+j+1], dp[i-j+1]+1)
		}
	}

	// Возвращаем минимальное количество разбиений
	return dp[n]
}

func min(a, b int) int {
	if a < b {
		return a
	}

	return b
}
