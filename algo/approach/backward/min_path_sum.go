package main

import "fmt"

// Функция для нахождения минимальной стоимости пути с обратным подходом
func minPathSum(grid [][]int) int {
	/*
		TIME COMPLEXITY (Время): O(m * n), где m — количество строк, а n — количество столбцов.
		Мы проходим по каждой ячейке сетки один раз.

		SPACE COMPLEXITY (Память): O(1) дополнительной памяти.
		Мы используем саму сетку grid для хранения промежуточных результатов, и не выделяем дополнительной памяти,
		за исключением нескольких переменных для индексов и минимальной функции.
	*/
	// Получаем размеры сетки
	m, n := len(grid), len(grid[0])

	// Инициализируем последнюю строку, начиная с правого края
	for i := m - 2; i >= 0; i-- {
		grid[i][n-1] += grid[i+1][n-1] // Добавляем стоимость пути сверху
	}

	// Инициализируем последний столбец, начиная с нижнего края
	for j := n - 2; j >= 0; j-- {
		grid[m-1][j] += grid[m-1][j+1] // Добавляем стоимость пути слева
	}

	// Теперь вычисляем минимальную стоимость для остальных ячеек сетки
	for i := m - 2; i >= 0; i-- {
		for j := n - 2; j >= 0; j-- {
			// Для каждой ячейки выбираем минимальный путь: либо сверху, либо слева
			grid[i][j] += min(grid[i+1][j], grid[i][j+1])
		}
	}

	// Результат — минимальная стоимость пути в левом верхнем углу
	return grid[0][0]
}

// Функция для нахождения минимального из двух значений
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func main() {
	// Пример сетки
	grid := [][]int{
		{1, 3, 1},
		{1, 5, 1},
		{4, 2, 1},
	}
	// Вызов функции для нахождения минимальной стоимости пути
	result := minPathSum(grid)
	// Выводим результат
	fmt.Println("Минимальная стоимость пути:", result)
}
