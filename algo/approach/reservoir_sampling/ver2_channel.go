//go:build ignore

package main

import (
	"fmt"
	"math/rand"
	"time"
)

// Функция для выполнения Reservoir Sampling с потоком данных неизвестного размера
func reservoirSamplingChan(stream <-chan int) int {
	/*
		METHOD: Reservoir sampling

		TIME COMPLEXITY: O(n), где n — количество элементов в потоке данных.
		Алгоритм проходит по всем элементам потока данных один раз.
		Для каждого элемента (начиная со второго) выполняется генерация случайного числа и, возможно, обновление результата.
		Эти операции имеют константное время выполнения, поэтому общая временная сложность линейна относительно размера потока данных.

		SPACE COMPLEXITY: O(1) (или O(k), если учитывать размер резервуара).
		В примере, который мы рассмотрели, k = 1, поэтому пространственная сложность составляет O(1).
		Мы используем только несколько переменных для хранения текущего результата и счетчика, что не зависит от размера потока данных.
		Если бы мы выбирали k элементов, то потребовался бы массив размером k, и пространственная сложность была бы O(k).
	*/
	rand.Seed(time.Now().UnixNano()) // Инициализация генератора случайных чисел

	result := <-stream // Инициализация результата первым элементом потока
	i := 1

	for item := range stream {
		r := rand.Intn(i + 1) // Генерация случайного числа в диапазоне от 0 до i
		if r == 0 {
			result = item // Обновление результата, если сгенерированное число равно 0
		}
		i++
	}

	return result
}

func main() {
	// Пример потока данных
	stream := make(chan int)

	go func() {
		data := []int{10, 20, 30, 40, 50, 60, 70, 80, 90, 100}
		for _, value := range data {
			stream <- value
		}
		close(stream)
	}()

	// Выбор случайного элемента из потока данных
	randomElement := reservoirSamplingChan(stream)

	fmt.Println("Случайный элемент из потока данных:", randomElement)
}
