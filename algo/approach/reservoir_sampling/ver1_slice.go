package main

import (
	"fmt"
	"math/rand"
	"time"
)

// Функция для выполнения Reservoir Sampling
func reservoirSampling(stream []int) int {
	/*
		METHOD: Reservoir sampling

		TIME COMPLEXITY: O(n), где n — количество элементов в потоке данных.
		Объяснение: Алгоритм проходит по всем элементам потока данных один раз.
		Для каждого элемента (начиная со второго) выполняется генерация случайного числа и, возможно, обновление результата.
		Эти операции имеют константное время выполнения, поэтому общая временная сложность линейна относительно размера потока данных.

		SPACE COMPLEXITY: O(1) (или O(k), если учитывать размер резервуара).
		Объяснение: В примере, который мы рассмотрели, k = 1, поэтому пространственная сложность составляет O(1).
		Мы используем только несколько переменных для хранения текущего результата и счетчика, что не зависит от размера потока данных.
		Если бы мы выбирали k элементов, то потребовался бы массив размером k, и пространственная сложность была бы O(k).
	*/
	rand.Seed(time.Now().UnixNano()) // Инициализация генератора случайных чисел

	result := stream[0] // Инициализация результата первым элементом потока

	for i := 1; i < len(stream); i++ {
		r := rand.Intn(i + 1) // Генерация случайного числа в диапазоне от 0 до i
		if r == 0 {
			result = stream[i] // Обновление результата, если сгенерированное число равно 0
		}
	}

	return result
}

func main() {
	// Пример потока данных
	stream := []int{10, 20, 30, 40, 50, 60, 70, 80, 90, 100}

	// Выбор случайного элемента из потока данных
	randomElement := reservoirSampling(stream)

	fmt.Println("Случайный элемент из потока данных:", randomElement)
}
