package main

import "fmt"

/*
Подход "Стек" используется в различных алгоритмических задачах, где требуется обработка данных в определенном порядке,
например, в обратном порядке, или при необходимости запоминания промежуточных результатов для последующего использования.

Где используется:
1. Обработка выражений
Стек используется для обработки арифметических выражений.
Выражения могут быть представлены в инфиксной нотации (например, 2 + 3 * 4), где важен порядок операций.
Стек позволяет записывать операторы в порядке их обнаружения, а затем применять их к соответствующим операндам.

2. Обход деревьев
Стек используется для обхода деревьев. В глубину (DFS) и ширину (BFS) обходы деревьев являются примерами задач,
где стек используется для отслеживания узлов, которые еще не были посещены.

3. Поиск в глубину (DFS)
Стек используется для реализации алгоритма поиска в глубину.
В этом алгоритме мы посещаем каждый узел дерева и запоминаем путь, который мы прошли.
Если мы дошли до узла, который не имеет непосещенных соседей, мы возвращаемся назад и продолжаем поиск.

4. Вычисление постфиксной нотации
Стек используется для вычисления арифметических выражений, записанных в постфиксной нотации.
В этом случае мы считываем выражение слева направо и помещаем операнды в стек.
Когда мы встречаем оператор, мы извлекаем необходимое количество операндов из стека,
выполняем операцию и помещаем результат обратно в стек.

5. Проверка правильности скобочной последовательности
Стек используется для проверки правильности скобочной последовательности.
Мы последовательно считываем символы и помещаем открывающие скобки в стек.
Когда мы встречаем закрывающую скобку, мы проверяем, соответствует ли она последней открывающей скобке в стеке.
Если да, то мы удаляем ее из стека. Если в конце стек пуст, то скобочная последовательность правильная.

6. Обратная польская нотация (RPN)
Стек используется для вычисления выражений, записанных в обратной польской нотации.
В этом случае мы считываем выражение слева направо и помещаем операнды в стек.
Когда мы встречаем оператор, мы извлекаем необходимое количество операндов из стека,
выполняем операцию и помещаем результат обратно в стек.

7. Реализация рекурсии
Стек используется для реализации рекурсивных алгоритмов.
Каждый рекурсивный вызов сохраняется в стеке, что позволяет отслеживать состояние и возвращаться к нему позже.

8. Обратный ход при обходе графа
Стек используется для обхода графа в глубину (DFS) или ширину (BFS), чтобы отслеживать узлы, которые еще не были посещены.
Стек позволяет вернуться к предыдущим узлам после обработки текущего узла.

9. Реализация функции вызовов
Стек используется в языках программирования для реализации функции вызовов.
Каждый вызов функции сохраняется в стеке, что позволяет отслеживать состояние и возвращаться к нему после завершения функции.

10. Реализация алгоритмов сортировки
Стек может использоваться для реализации алгоритмов сортировки, таких как сортировка с использованием стека (стековый сортировщик).
*/

// Функция для проверки правильности скобочной последовательности
func isValid(s string) bool {
	/*
		METHOD: Stack
		TIME COMPLEXITY: O(n), где n - количество символов в строке. Это обусловлено тем, что функция проходит по каждому символу строки ровно один раз.
		SPACE COMPLEXITY: O(n), так как в худшем случае (когда вся строка состоит из открывающих скобок) стек может достигнуть размера n.
		Одним из примеров алгоритмической задачи, в которой используется стек, является задача проверки правильности скобочной последовательности.
		В этой задаче мы должны определить, является ли данная скобочная последовательность правильной.
	*/
	// Создаем стек для хранения открывающих скобок
	stack := []rune{}

	// Сопоставление открывающих и закрывающих скобок
	brackets := map[rune]rune{
		')': '(',
		']': '[',
		'}': '{',
	}

	// Проходим по всем символам в строке
	for _, char := range s {
		// Если текущий символ - открывающая скобка, то добавляем ее в стек
		if char == '(' || char == '[' || char == '{' {
			stack = append(stack, char)
		} else if char == ')' || char == ']' || char == '}' {
			// Если стек пуст или последняя открывающая скобка не соответствует текущей закрывающей скобке,
			// то последовательность неправильная
			if len(stack) == 0 || stack[len(stack)-1] != brackets[char] {
				return false
			}
			// Если соответствует, то удаляем последнюю открывающую скобку из стека
			stack = stack[:len(stack)-1]
		}
	}

	// Если стек пуст, то все скобки соответствуют друг другу, последовательность правильная
	return len(stack) == 0
}

func main() {
	// Пример использования функции
	fmt.Println(isValid("()[]{}")) // true
	fmt.Println(isValid("([)]"))   // false
}
