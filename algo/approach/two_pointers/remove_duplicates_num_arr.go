//go:build ignore

package main

import (
	"fmt"
)

// Функция для удаления дубликатов из отсортированного массива
func removeDuplicates(arr []int) int {
	/*
		METHOD: Two Pointers Approach
		1. Используем два указателя: один для текущего элемента, а второй для новой позиции без дубликатов.
		2. Если текущий элемент не равен предыдущему, перемещаем второй указатель и заменяем элемент.
		3. В конце возвращаем новый размер массива без дубликатов.

		TIME COMPLEXITY: O(n) — проходим по массиву один раз
		SPACE COMPLEXITY: O(1) — дополнительные массивы не создаются.
	*/

	if len(arr) == 0 {
		return 0
	}

	// Указатель для нового массива без дубликатов
	newIndex := 1

	// Проходим по массиву начиная с 1-го элемента
	for i := 1; i < len(arr); i++ {
		if arr[i] != arr[i-1] {
			arr[newIndex] = arr[i]
			newIndex++
		}
	}

	// Возвращаем новый размер массива без дубликатов
	return newIndex
}

/*
	Задача: Удалить дубликаты из отсортированного массива.

	Условия задачи:
	Дан отсортированный массив целых чисел. Требуется удалить из массива все дубликаты, оставив только уникальные элементы. Возвращаем новый размер массива.

	Пример:
	Вход:
		arr = [1, 1, 2]

	Выход:
		2
		Массив после удаления дубликатов: [1, 2]

	Алгоритм использует метод двух указателей для удаления дубликатов в отсортированном массиве.

	ТАЙМ-КОМПЛЕКСНОСТЬ: O(n) — проходим по массиву один раз
	СПЕЙС-КОМПЛЕКСНОСТЬ: O(1) — дополнительные массивы не создаются
*/

func main() {
	// Задаем отсортированный массив с дубликатами
	arr := []int{1, 1, 2}

	// Вызываем функцию для удаления дубликатов
	newSize := removeDuplicates(arr)

	// Выводим результат
	fmt.Printf("Новый размер массива: %d\n", newSize)
	fmt.Println("Массив после удаления дубликатов:", arr[:newSize])
}
