//go:build ignore

package main

import (
	"fmt"
)

// Функция для нахождения максимальной суммы подмассива с заданной длиной
func maxSumSubarray(arr []int, k int) int {
	/*
		METHOD: Two Pointers Approach
		1. Используем два указателя для определения окна фиксированного размера (k).
		2. Перемещаем окно по массиву, суммируя элементы внутри окна.
		3. Для каждого сдвига окна сравниваем сумму и обновляем максимальную сумму.

		TIME COMPLEXITY: O(n) — проходим по массиву один раз.
		SPACE COMPLEXITY: O(1) — дополнительные массивы не создаются.
	*/

	// Инициализация максимальной суммы
	maxSum := 0
	windowSum := 0

	// Первая итерация: суммируем первые k элементов
	for i := 0; i < k; i++ {
		windowSum += arr[i]
	}
	maxSum = windowSum

	// Сдвигаем окно и обновляем сумму
	for i := k; i < len(arr); i++ {
		// Убираем элемент слева из окна и добавляем новый элемент справа
		windowSum += arr[i] - arr[i-k]
		// Обновляем максимальную сумму
		if windowSum > maxSum {
			maxSum = windowSum
		}
	}

	return maxSum
}

/*
	Задача: Найти максимальную сумму подмассива заданной длины в массиве.

	Условия задачи:
	Дан массив целых чисел и целое число k. Требуется найти максимальную сумму подмассива длины k.

	Пример:
	Вход:
		arr = [2, 1, 5, 1, 3, 2], k = 3

	Выход:
		9

	Алгоритм использует метод двух указателей для поиска максимальной суммы подмассива фиксированной длины.

	ТАЙМ-КОМПЛЕКСНОСТЬ: O(n) — проходим по массиву один раз.
	СПЕЙС-КОМПЛЕКСНОСТЬ: O(1) — дополнительные массивы не создаются.
*/

func main() {
	// Задаем массив и длину подмассива
	arr := []int{2, 1, 5, 1, 3, 2}
	k := 3

	// Вызываем функцию для нахождения максимальной суммы подмассива
	result := maxSumSubarray(arr, k)

	// Выводим результат
	fmt.Printf("Максимальная сумма подмассива длины %d: %d\n", k, result)
}
