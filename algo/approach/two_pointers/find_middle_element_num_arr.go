//go:build ignore

package main

import (
	"fmt"
)

// Функция для нахождения центрального элемента в массиве с двумя указателями
func findMiddleElement(nums []int) int {
	/*
		METHOD: Two Pointers Approach
		1. Используем два указателя: один начинает с первого элемента, другой — с последнего.
		2. Двигаем указатели к центру массива, пока они не встретятся.
		3. Когда оба указателя встретятся, это будет центральный элемент.
		4. Если количество элементов четное, возвращаем элемент, который находится ближе к середине.

		TIME COMPLEXITY: O(n) — проходим по массиву один раз.
		SPACE COMPLEXITY: O(1) — дополнительные данные не используются.
	*/

	// Если массив пустой, возвращаем -1
	if len(nums) == 0 {
		return -1
	}

	// Указатели на начало и конец массива
	left, right := 0, len(nums)-1

	// Идем к середине, пока указатели не встретятся
	for left <= right {
		// Если указатели встретились, возвращаем центральный элемент
		if left == right {
			return nums[left]
		}
		// Перемещаем указатели
		left++
		right--
	}

	// Если массив имеет четное количество элементов, вернем элемент в центре
	return nums[left]
}

/*
	Задача: Найти центральный элемент в массиве.

	Условия задачи:
	Дан массив целых чисел. Нужно найти центральный элемент. Если количество элементов в массиве четное, вернуть элемент, который находится ближе к середине.

	Пример:
	Вход:
		nums = [1, 2, 3, 4, 5]

	Выход:
		3

	Алгоритм использует два указателя для поиска центрального элемента.

	ТАЙМ-КОМПЛЕКСНОСТЬ: O(n) — проходим по массиву один раз.
	СПЕЙС-КОМПЛЕКСНОСТЬ: O(1) — дополнительные массивы не создаются.
*/

func main() {
	// Задаем массив чисел
	nums := []int{1, 2, 3, 4, 5}

	// Вызываем функцию для нахождения центрального элемента
	middle := findMiddleElement(nums)

	// Выводим результат
	fmt.Printf("Центральный элемент: %d\n", middle)
}
