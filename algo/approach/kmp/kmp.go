package main

import "fmt"

// Функция для создания префикс-функции для строки pattern
func computeLPSArray(pattern string) []int {
	/*
		Префикс-функция, также известная как таблица частичных совпадений (Partial Match Table),
		является важной частью алгоритма Кнута-Морриса-Пратта (KMP).
		Это массив целых чисел, где каждый элемент представляет длину наибольшего собственного суффикса подстроки,
		который также является префиксом этой подстроки.

		Массив префикс-функции используется для эффективного перемещения по строке при поиске шаблона.
		Он позволяет избежать линейного сканирования текста для каждой позиции в нем, что ускоряет процесс поиска.

		В процессе вычисления префикс-функции, функция computeLPSArray использует два указателя: length и i.
		length отслеживает длину наибольшего собственного суффикса, который также является префиксом,
		найденного до текущей позиции i. i используется для прохода по строке pattern.

		В цикле for функция computeLPSArray сравнивает символы в строке pattern на позициях i и length.
		Если символы совпадают, то увеличивает length и записывает его в lps[i].
		Если символы не совпадают, то функция использует информацию из предыдущих элементов префикс-функции,
		чтобы определить, какой суффикс можно пропустить, чтобы не делать лишнего сравнения.

		Таким образом, префикс-функция позволяет алгоритму KMP эффективно переходить к следующей позиции в строке text,
		которая может содержать часть шаблона, который уже был сопоставлен.
	*/
	// Инициализируем переменную length, которая будет отслеживать длину наибольшего собственного суффикса,
	// который также является префиксом подстроки pattern[:i+1]
	length := 0

	// Создаем слайс lps для хранения значений префикс-функции, инициализируем его с длиной pattern
	lps := make([]int, len(pattern))

	// Префикс-функция для нулевого символа всегда равна 0
	lps[0] = 0

	// Указатель i используется для прохода по строке pattern
	i := 1

	// Проходим по всем символам строки pattern, начиная со второго символа
	for i < len(pattern) {
		// Если символы pattern[i] и pattern[length] совпадают, увеличиваем length и записываем его в lps[i]
		if pattern[i] == pattern[length] {
			length++
			lps[i] = length
			i++
		} else {
			// Если символы не совпадают, и length не равен 0, то мы используем информацию из предыдущих элементов
			// префикс-функции, чтобы определить, какой суффикс можно пропустить, чтобы не делать лишнего сравнения
			if length != 0 {
				length = lps[length-1]
			} else {
				// Если length равен 0, то мы устанавливаем lps[i] в 0 и переходим к следующему символу
				lps[i] = 0
				i++
			}
		}
	}

	// Возвращаем полученный массив префикс-функции
	return lps
}

// KMP - функция для поиска подстроки pattern в строке text с использованием алгоритма KMP
func KMP(text, pattern string) bool {
	// Вычисляем префикс-функцию для шаблона
	lps := computeLPSArray(pattern)

	// Инициализируем два указателя: i для текста и j для шаблона
	i, j := 0, 0

	// Проходим по всем символам текста
	for i < len(text) {
		// Если символы в тексте и шаблоне совпадают, переходим к следующим символам
		if pattern[j] == text[i] {
			i++
			j++
		}

		// Если мы достигли конца шаблона, значит, мы нашли совпадение
		if j == len(pattern) {
			return true // Найдено совпадение
		}

		// Если символы в тексте и шаблоне не совпадают, идем на следующую итерацию
		if i < len(text) && pattern[j] != text[i] {
			// Если мы не находимся в начале шаблона, используем префикс-функцию для перехода к предыдущему совпадению
			if j != 0 {
				j = lps[j-1]
			} else {
				// Если мы находимся в начале шаблона, просто переходим к следующему символу в тексте
				i++
			}
		}
	}

	// Если мы дошли до конца текста и не нашли совпадения, возвращаем false
	return false // Не найдено совпадение
}

// Функция для проверки, является ли строка B циклическим сдвигом строки A
func rotateString(A string, B string) bool {
	// Проверяем, что длины строк равны
	if len(A) != len(B) {
		return false
	}

	// Если строки равны, то они являются циклическим сдвигом друг друга
	if A == B {
		return true
	}

	// Создаем новую строку, состоящую из A и A
	newA := A + A

	// Используем KMP для поиска подстроки B в новой строке newA
	return KMP(newA, B)
}

func main() {
	A := "abcde"
	B := "cdeab"
	fmt.Println(rotateString(A, B)) // Вывод: true
}
