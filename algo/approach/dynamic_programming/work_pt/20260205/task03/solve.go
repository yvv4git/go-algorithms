package main

import (
	"bufio"
	"fmt"
	"os"
)

func solve(N int) int {
	/*
		METHOD: Dynamic Programming (одномерный массив для оптимизации памяти)
		Суть задачи: Подсчёт количества телефонных номеров длины N, которые набираются ходом коня.
		Номер не может начинаться с цифры 0 или 8.

		dp[i][d] - количество способов достичь позицию i с последней цифрой d.
		Переход: dp[i][d] = sum(dp[i-1][prev] для всех prev, откуда можно попасть на d).

		ПОЧЕМУ ТАК:
		- Ходы коня на кнопочном телефоне: L-образный ход (2 по одной оси, 1 по другой)
		- Каждая цифра имеет ограниченное количество "соседей", на которые можно перейти
		- Первая цифра имеет ограничения (не 0, не 8)
		- Используем одномерный массив для оптимизации памяти: O(10) вместо O(n*10)

		Ходы коня на телефонной клавиатуре:
		0 -> 4, 6
		1 -> 6, 8
		2 -> 7, 9
		3 -> 4, 8
		4 -> 0, 3, 9
		5 -> (нет переходов)
		6 -> 1, 7
		7 -> 2, 6
		8 -> 1, 3
		9 -> 2, 4

		TIME COMPLEXITY: O(N * 10) = O(N) - проход по всем позициям и цифрам
		SPACE COMPLEXITY: O(10) - одномерный массив вместо двумерного
	*/

	// Список переходов: для каждой цифры храним список цифр, на которые можно попасть ходом коня
	moves := [][]int{
		{4, 6},    // 0
		{6, 8},    // 1
		{7, 9},    // 2
		{4, 8},    // 3
		{0, 3, 9}, // 4
		{},        // 5
		{1, 7},    // 6
		{2, 6},    // 7
		{1, 3},    // 8
		{2, 4},    // 9
	}

	// dp[d] - количество способов для текущей длины, заканчивающихся на цифру d
	dp := make([]int, 10)

	// База: первая цифра (N >= 1)
	// Номер не может начинаться с 0 или 8
	for d := range 10 {
		if d != 0 && d != 8 {
			dp[d] = 1
		}
	}

	// Если нужна только одна цифра, возвращаем сумму
	if N == 1 {
		sum := 0
		for d := range 10 {
			sum += dp[d]
		}
		return sum
	}

	// Переходы для остальных позиций
	for i := 2; i <= N; i++ {
		// Новый массив для следующей позиции
		newDp := make([]int, 10)

		// Для каждой цифры d вычисляем, сколько способов на неё попасть
		for d := range 10 {
			// Суммируем все переходы на d от предыдущих цифр
			for _, prev := range moves[d] {
				newDp[d] += dp[prev]
			}
		}

		dp = newDp
	}

	// Суммируем все способы для последней позиции
	sum := 0
	for d := range 10 {
		sum += dp[d]
	}

	return sum
}

func main() {
	in := bufio.NewReader(os.Stdin)

	var N int
	fmt.Fscan(in, &N)

	result := solve(N)
	fmt.Println(result)
}
