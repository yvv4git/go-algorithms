//go:build ignore

package main

import "fmt"

// Функция для нахождения максимальной суммы подпоследовательности
// с условием, что элементы не могут быть соседними
func maxSumNonAdjacent(nums []int) int {
	/*
		METHOD: Dynamic Programming

		Пусть есть массив nums, который содержит некоторую последовательность чисел.
		Мы хотим найти максимальную сумму, которую можно получить, если элементы этой последовательности
		не могут быть соседними.

		Мы можем решить эту задачу, используя динамическое программирование.
		Для этого мы будем использовать две переменные: prevMax и currMax.
		prevMax - максимальная сумма, не включая текущий элемент
		currMax - максимальная сумма, включая текущий элемент

		При первом запуске prevMax и currMax будут равны нулю, а после первого элемента prevMax будет равен 0,
		а currMax будет равен первому элементу массива.

		Далее, для каждого элемента в массиве nums, мы будем выбирать, либо не включать его, либо включать.
		Если включаем, то прибавляем его к prevMax (к максимальной сумме без соседних элементов).
		Если не включаем, то прибавляем 0 к prevMax.

		Таким образом, в currMax мы будем хранить максимальную сумму, которую мы можем получить,
		включая текущий элемент.

		После того, как мы прошли все элементы в массиве, currMax будет содержать максимальную сумму,
		которую мы можем получить, включая все элементы.

		В итоге, мы возвращаем currMax.

		TIME COMPLEXITY: O(n)
		SPACE COMPLEXITY: O(1)
	*/
	if len(nums) == 0 {
		return 0
	}

	if len(nums) == 1 {
		return nums[0]
	}

	// Инициализируем две переменные для хранения максимальной суммы
	// prevMax - максимальная сумма, не включая текущий элемент
	// currMax - максимальная сумма, включая текущий элемент
	prevMax := 0
	currMax := nums[0]

	for i := 1; i < len(nums); i++ {
		// Для каждого элемента выбираем: либо не включаем его, либо включаем
		// Если включаем, то прибавляем его к prevMax (к максимальной сумме без соседних элементов)
		newMax := max(currMax, prevMax+nums[i])
		prevMax = currMax
		currMax = newMax
	}

	return currMax
}

// Вспомогательная функция для нахождения максимального числа
func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	// Пример массива
	nums := []int{3, 2, 5, 10, 7}

	// Выводим максимальную сумму, которую можно получить
	fmt.Printf("Максимальная сумма подпоследовательности: %d\n", maxSumNonAdjacent(nums))
}
