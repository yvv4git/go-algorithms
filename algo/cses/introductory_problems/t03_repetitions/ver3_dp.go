package main

// Функция для поиска самой длинной последовательности одинаковых символов в строке ДНК
// с использованием динамического программирования
func longestRepetitionV3(dna string) int {
	/*
		METHOD: Dynamic programming
		TIME COMPLEXITY: O(n), где n - количество символов в строке ДНК.
		Это обусловлено тем, что алгоритм проходит по каждому символу в строке ровно один раз, и для каждого символа выполняется постоянное количество операций.
		SPACE COMPLEXITY: O(n), так как мы используем дополнительный массив dp размера n для хранения длин последовательностей.
		Хранение этого массива требует O(n) памяти, где n - количество символов в строке ДНК.
	*/
	if len(dna) == 0 {
		return 0
	}

	// Инициализируем массив dp и заполняем его для первого символа
	dp := make([]int, len(dna))
	dp[0] = 1
	maxLength := 1

	// Проходим по строке ДНК, начиная со второго символа
	for i := 1; i < len(dna); i++ {
		if dna[i] == dna[i-1] {
			// Если текущий символ равен предыдущему, увеличиваем длину последовательности
			dp[i] = dp[i-1] + 1
		} else {
			// Если текущий символ не равен предыдущему, длина последовательности равна 1
			dp[i] = 1
		}
		// Обновляем максимальную длину, если текущая длина больше
		if dp[i] > maxLength {
			maxLength = dp[i]
		}
	}

	return maxLength
}

//func main() {
//	dna := "ATTCGGGA"
//	fmt.Println(longestRepetition(dna)) // Вывод: 3
//}
