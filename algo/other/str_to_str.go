//go:build ignore

package main

import "fmt"

func main() {
	/*
		Даны две строки s и f (начальная и конечная) и словарь D (набор слов).

		Нужно определить, можно ли преобразовать s в f, используя только слова из словаря D.
		При этом каждое преобразование должно менять только один символ, а длина слова должна оставаться неизменной.
		Если преобразование возможно, нужно найти кратчайшую последовательность таких преобразований и вернуть ее длину.
		Если преобразование невозможно, вернуть "Преобразование невозможно".

		Пример:
		D = ["cat", "cot", "dot", "dog", "bat", "dag"]
		s = "cat"
		t = "dog"

		Вывод: Минимальное количество шагов для преобразования 'cat' в 'dog': 3.

		Пример-2:
		D = ["cat", "cot", "bat"]
		s = "cat"
		t = "dog"
		Вывод: Минимальное количество шагов для преобразования 'cat' в 'dog'.
	*/

	D := []string{"cat", "cot", "dot", "dog", "bat", "dag"}
	s := "cat"
	t := "dog"

	steps := minSteps(D, s, t)
	if steps == -1 {
		fmt.Println("Преобразование невозможно")
	} else {
		fmt.Printf("Минимальное количество шагов для преобразования '%s' в '%s': %d\n", s, t, steps)
	}
}

func minSteps(D []string, s string, t string) int {
	/*
	   METHOD: Поиск в ширину (BFS)


	   TIME COMPLEXITY: O(N * M^2), где N - количество слов в словаре, M - длина слова


	   SPACE COMPLEXITY: O(N * M), где N - количество слов в словаре, M - длина слова
	*/
	// создаем мапу для хранения слов и их преобразований
	// ключ - префикс слова с замененным символом на "*", значение - список слов, которые можно получить из ключа
	words := make(map[string][]string)
	for _, word := range D {
		// для каждого слова в словаре
		for i := range word {
			// для каждого символа в слове
			prefix := word[:i] + "*" + word[i+1:]
			// создаем префикс, заменив текущий символ на "*"
			words[prefix] = append(words[prefix], word)
			// добавляем слово в список слов, которые можно получить из префикса
		}
	}

	// создаем очередь для BFS
	queue := []string{s}
	// добавляем начальное слово в очередь
	visited := make(map[string]bool)
	// создаем мапу для хранения посещенных слов
	visited[s] = true
	// помечаем начальное слово как посещенное
	steps := 0
	// инициализируем количество шагов

	for len(queue) > 0 {
		// пока очередь не пуста
		size := len(queue)
		for i := 0; i < size; i++ {
			// для каждого слова в очереди
			word := queue[0]
			queue = queue[1:]
			// удаляем слово из очереди

			if word == t {
				// если слово равно целевому слову
				return steps
				// возвращаем количество шагов
			}

			for i := range word {
				// для каждого символа в слове
				prefix := word[:i] + "*" + word[i+1:]
				// создаем префикс, заменив текущий символ на "*"
				for _, nextWord := range words[prefix] {
					// для каждого слова, которое можно получить из префикса
					if !visited[nextWord] {
						// если слово не посещено
						visited[nextWord] = true
						// помечаем слово как посещенное
						queue = append(queue, nextWord)
						// добавляем слово в очередь
					}
				}
			}
		}
		steps++
		// увеличиваем количество шагов
	}

	return -1 // преобразование невозможно
}
