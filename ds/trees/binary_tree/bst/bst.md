# Binary tree search / Бинарное поисковое дерево (Binary Search Tree, BST)


## Информация
Бинарное дерево (Binary Tree) - это дерево, в котором у каждого узла не более двух дочерних элементов, 
обычно называемых левым и правым дочерним элементами. В бинарном дереве каждый узел может иметь от 0 до 2 дочерних узлов.

Бинарное дерево поиска (Binary Search Tree) - это бинарное дерево, в котором для всех узлов, лежащих в левом поддереве, 
значения этих узлов меньше, чем значение корня, а для всех узлов, лежащих в правом поддереве, значения этих узлов больше, чем значение корня.


## Отличие от Binary tree
Отличия:
1. В бинарном дереве поиска значения узлов упорядочены, тогда как в обычном бинарном дереве этого не происходит.
2. В бинарном дереве поиска операции поиска, вставки и удаления имеют логарифмическую сложность, 
тогда как в обычном бинарном дереве эти операции могут иметь линейную сложность.
3. Бинарное дерево поиска может быть несбалансированным, тогда как бинарное дерево обычно является сбалансированным.



## Визуализация
        10
       /  \
      5    20
           /  \
          15   30


## Где используется?
Бинарные деревья широко применяются в различных областях программирования и информатики:
1. Представление иерархических структур: Используются для моделирования древовидных структур, таких как генеалогические деревья, организационные структуры или файловые системы.
2. Алгоритмы сортировки: Бинарные деревья используются в алгоритмах сортировки, таких как heapsort, где дерево представляет собой кучу (heap).
3. Выражения и компиляторы: Бинарные деревья выражений используются для представления математических выражений, а также в компиляторах для построения синтаксических деревьев.
4. Базы данных и индексы: Варианты бинарных деревьев, такие как B-деревья, используются для индексации данных в базах данных.
5. Игровые движки и графика: Применяются для пространственного разделения, такого как дерево квадрантов (quadtree) или октодерево (octree) для оптимизации рендеринга и коллизий.


## Алгоритмы на Binary tree

1. **Вставка узла (Insert)**
   - Описание: Вставка нового узла в дерево с сохранением свойств бинарного дерева поиска.
   - Сложность: O(h), где h - высота дерева. В худшем случае (несбалансированное дерево) O(n), в среднем O(log n).
   - Реализация: [`Insert`](ds/trees/binary_tree/bst/bst.go:17)

2. **Поиск узла (Search)**
   - Описание: Поиск узла в дереве по заданному значению.
   - Сложность: O(h), где h - высота дерева. В худшем случае (несбалансированное дерево) O(n), в среднем O(log n).
   - Реализация: [`Search`](ds/trees/binary_tree/bst/bst.go:40)

3. **Обход дерева в порядке возрастания (In-Order Traversal)**
   - Описание: Вывод узлов дерева в отсортированном порядке (левое поддерево, корень, правое поддерево). 
   Этот метод обхода позволяет получить элементы дерева в порядке возрастания, так как сначала обрабатываются все элементы левого поддерева (которые меньше корня), 
   затем сам корень, и, наконец, элементы правого поддерева (которые больше корня).
   - Сложность: O(n), где n - количество узлов в дереве.
   - Реализация: [`PrintInOrder`](ds/trees/binary_tree/bst/bst.go:58)

## Где используется?

Бинарные деревья поиска (BST) широко применяются в различных областях программирования и информатики:

1. **Базы данных**: Используются для индексации данных, что позволяет ускорить операции поиска, вставки и удаления.
2. **Файловые системы**: Применяются для организации и быстрого доступа к файлам и каталогам.
3. **Компиляторы**: Используются для управления таблицами символов и оптимизации кода.
4. **Алгоритмы сортировки и поиска**: BST обеспечивают эффективные операции поиска и сортировки данных.
5. **Игровые движки**: Применяются для управления объектами в игровом мире, такими как дерево квадрантов для пространственного разделения.

## Примеры использования

```go
// Создание нового бинарного дерева поиска
tree := &Node{Value: 100}

// Вставка узлов в дерево
tree.Insert(200)
tree.Insert(300)
tree.Insert(50)
tree.Insert(150)

// Вывод дерева в отсортированном порядке
tree.PrintInOrder()

// Поиск узла в дереве
fmt.Println(tree.Search(150)) // true
fmt.Println(tree.Search(400)) // false
```


## Визуализация алгоритма BST

### Поиск узла (Search)

Пример поиска значения 150 в дереве:

Начальное дерево:
```
      100
     /    \
   50      200
         /    \
       150     300
```

Шаги поиска:
1. Начинаем с корня (100). 150 > 100, идем вправо.
2. Переходим к узлу 200. 150 < 200, идем влево.
3. Переходим к узлу 150. 150 == 150, узел найден.

Если искомое значение не найдено (например, 400):
1. Начинаем с корня (100). 400 > 100, идем вправо.
2. Переходим к узлу 200. 400 > 200, идем вправо.
3. Переходим к узлу 300. 400 > 300, идем вправо.
4. Узел nil, значение не найдено.
