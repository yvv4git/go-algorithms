# DFS

## Что это?
Алгоритм поиска (или обхода) в глубину (англ. depth-first search, DFS) позволяет построить обход ориентированного 
или неориентированного графа, при котором посещаются все вершины, доступные из начальной вершины.

Отличие **поиска в глубину от поиска в ширину(BFS)** заключается в том, 
что (в случае неориентированного графа) результатом алгоритма поиска в глубину является некоторый маршрут, 
следуя которому можно обойти последовательно все вершины графа, доступные из начальной вершины. 
Этим он принципиально отличается от поиска в ширину, где одновременно обрабатывается множество вершин, 
в поиске в глубину в каждый момент исполнения алгоритма обрабатывается только одна вершина. 
С другой стороны, поиск в глубину не находит кратчайших путей, зато он применим в ситуациях, когда граф неизвестен целиком, 
а исследуется каким-то автоматизированным устройством.

Если же граф ориентированный, то поиск в глубину строит дерево путей из начальной вершины во все доступные из нее.


## Алгоритм
Обход в глубину можно представить себе следующим образом. 
Пусть исследователь находится в некотором лабиринте (графе) и он хочет обойти весь лабиринт (посетить все доступные вершины в графе). 
Исследователь находится в некоторой вершине и видит ребра, исходящие из этой вершины. 
Очевидная последовательность действий исследователя такая:
1. Пойти в какую-нибудь смежную вершину.
2. Обойти все, что доступно из этой вершины.
3. Вернуться в начальную вершину.
4. Повторить алгоритм для всех остальных вершин, смежных из начальной.

Видим, что алгоритм является рекурсивным — для обхода всего графа нужно переместиться в соседнюю вершину, 
после чего повторить для этой вершины алгоритм обхода. Но возникает проблема зацикливания — если из вершины A можно перейти в вершину B, 
то из вершины B можно перейти в вершину A и рекурсия будет бесконечной. 
Для борьбы с рекурсией нужно применить очень простую идею — исследователь не должен идти в ту вершину, 
в которой он уже был раньше, то есть которая не представляет для него интерес (считаем, что интерес для исследователя представляют только вершины, 
в которых он не был ранее). Итак, уточненный алгоритм может выглядеть следующим образом:
1. Пойти в какую-нибудь смежную вершину, не посещенную ранее.
2. Запустить из этой вершины алгоритм обхода в глубину.
3. Вернуться в начальную вершину.
4. Повторить пункты 1-3 для всех не посещенных ранее смежных вершин.



## Complexity
### Временная сложность (Time Complexity)
O(n), где n - количество узлов в дереве. Каждый узел посещается ровно один раз.

### Пространственная сложность (Space Complexity)
O(h), где h - высота дерева. В худшем случае (несбалансированное дерево) O(n), 
в лучшем случае (сбалансированное дерево) O(log n). Это обусловлено использованием стека вызовов в рекурсивной реализации.


## Визуализация
Рассмотрим бинарное дерево:

```
        1
       / \
      2   3
     / \
    4   5
```

### Preorder Traversal (корень, левое, правое)
Порядок обхода: 1 -> 2 -> 4 -> 5 -> 3

### Inorder Traversal (левое, корень, правое)
Порядок обхода: 4 -> 2 -> 5 -> 1 -> 3

### Postorder Traversal (левое, правое, корень)
Порядок обхода: 4 -> 5 -> 2 -> 3 -> 1


## Визуализация работы алгоритма DFS

Рассмотрим пошаговую работу DFS на примере preorder traversal (корень, левое, правое):

```
        1
       / \
      2   3
     / \
    4   5
```

Шаг 1: Посетить корень 1. Порядок: [1]

Шаг 2: Перейти к левому поддереву, посетить 2. Порядок: [1, 2]

Шаг 3: Из 2 перейти к левому 4. Порядок: [1, 2, 4]

Шаг 4: Из 4 вернуться к 2, перейти к правому 5. Порядок: [1, 2, 4, 5]

Шаг 5: Из 5 вернуться к 2, затем к 1. Перейти к правому поддереву 3. Порядок: [1, 2, 4, 5, 3]

Алгоритм завершен. Финальный порядок: 1 -> 2 -> 4 -> 5 -> 3


