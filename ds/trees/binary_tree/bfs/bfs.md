# BFS


## Что это?
Алгоритм поиска (или обхода) в ширину (англ. breadth-first search, BFS) позволяет построить обход ориентированного
или неориентированного графа, при котором посещаются все вершины, доступные из начальной вершины, уровень за уровнем.

Отличие **поиска в ширину от поиска в глубину(DFS)** заключается в том,
что BFS обрабатывает вершины по уровням: сначала все вершины на расстоянии 1 от начальной, затем на расстоянии 2 и т.д.
В отличие от DFS, где в каждый момент обрабатывается только одна вершина, BFS одновременно обрабатывает множество вершин одного уровня.
BFS находит кратчайшие пути в невзвешенных графах, но требует больше памяти для хранения очереди.

Если граф ориентированный, BFS строит дерево уровней из начальной вершины.

## Алгоритм
Обход в ширину можно представить следующим образом.
Исследователь начинает с начальной вершины и посещает все ее соседей, затем переходит к соседям соседей и т.д.
Для реализации используется очередь (FIFO): добавляем вершины в конец, извлекаем из начала.

Алгоритм:
1. Поместить начальную вершину в очередь и отметить ее как посещенную.
2. Пока очередь не пуста:
   a. Извлечь вершину из начала очереди.
   b. Обработать вершину (например, добавить в результат).
   c. Добавить всех непосещенных соседей вершины в конец очереди и отметить их как посещенные.

Для предотвращения повторного посещения вершин используется массив или множество посещенных вершин.

## Complexity
### Временная сложность (Time Complexity)
O(n), где n - количество узлов в дереве. Каждый узел посещается ровно один раз.

### Пространственная сложность (Space Complexity)
O(w), где w - максимальная ширина дерева (наибольшее количество узлов на одном уровне).
В худшем случае (полное бинарное дерево) O(n), в лучшем случае (линейное дерево) O(1).

## Визуализация
Рассмотрим бинарное дерево:

```
        1
       / \
      2   3
     / \
    4   5
```

### Level Order Traversal (уровень за уровнем)
Порядок обхода: 1 -> 2 -> 3 -> 4 -> 5

## Визуализация работы алгоритма BFS

Рассмотрим пошаговую работу BFS на примере level order traversal:

```
        1
       / \
      2   3
     / \
    4   5
```

- Шаг 1: Посетить корень 1, добавить его детей 2 и 3 в очередь. Очередь: [2, 3], Порядок: [1]
- Шаг 2: Извлечь 2, посетить, добавить его детей 4 и 5. Очередь: [3, 4, 5], Порядок: [1, 2]
- Шаг 3: Извлечь 3, посетить, детей нет. Очередь: [4, 5], Порядок: [1, 2, 3]
- Шаг 4: Извлечь 4, посетить, детей нет. Очередь: [5], Порядок: [1, 2, 3, 4]
- Шаг 5: Извлечь 5, посетить, детей нет. Очередь: [], Порядок: [1, 2, 3, 4, 5]

Алгоритм завершен. Финальный порядок: 1 -> 2 -> 3 -> 4 -> 5