# Bloom filter

## Что это?
Фильтр Блума - это вероятностная структура данных, придуманная Бёртоном Блумом в 1970 году, позволяющая проверять принадлежность элемента к множеству. 
При этом существует возможность получить ложноположительное срабатывание, но не ложноотрицательное.

Фильтр Блума - это структура данных, цель которой — быстро проверить, 
что элемент НЕ входит в множество (для тех, кто знаком с нотацией O большое, сложность вставки и проверки принадлежности элемента к множеству с помощью фильтра Блума — O(1)). 
Он может быть очень полезен для предотвращения излишнего выполнения задач, требующих интенсивных вычислений, просто проверяя, что элемент совершенно точно не входит в множество. 
Важно понимать, что фильтр Блума - это вероятностная структура данных: он может сказать вам со 100% вероятностью, 
что элемент отсутствует в наборе данных, но сказать со 100% вероятностью, что элемент находится в наборе, он не может (возможны ложно положительные результаты). 
Давайте же поговорим о сценариях, в которых можно использовать фильтр Блума с подробным объяснением его внутреннего устройства и реализацией на Python, и позже вы поймете, откуда фильтр Блума имеет такие показатели!

Фильтр Блума обычно используется перед поиском в множестве с достаточно медленным доступом к элементам. За счет его использования может быть уменьшено как количество поисковых операций над множеством, так и время поиска в целом.


## Как это работает?
Фильтр Блума - это вероятностная структура данных, цель которой очень быстро проверить, что заданный элемент НЕ ВХОДИТ в черный список.
Например, если мы фильтруем ip адреса. Мы имеем список из 100 ipv4 адресов, это черный список. Для решения этой задачи используется
такая хеш функция, которая создает небольшой массив бит(bits array). И когда на вход мы получаем ip адрес, то на выходе должны получить индекс,
по которому лежит бит(0 или 1), если 0, значит ip адрес не из черного списка. А, если 1, значит адрес из черного списка. Конечно же будут коллизии.
Т.е. для ip адресов и небольшого bits array будет очень много коллизий, так как ipv4 это 2^32 адресов(4 294 967 296). Как же тогда быть?
А ни как? Это не проблема. Потому, что цель bloom фильтра проверить, что ip адрес не содержится в черном списке. Т.е. прешел ip, мы проверяем,
присутствует ли он в черном списке. Если да, т.е. если в bits array лежит 1, то тогда можно залезть в черный список и проверить, так ли это.
Но в остальных случаях, это делать не нужно. Тем самым очень сильно сокращается количество обращений к памяти.



## Сценарий использования - фильтр ip адресов
Давайте поразмыслим о сценариях, в которых для ускорения вычисления некоторых задач такая структура данных могла бы оказаться очень полезной. 
Например, мы можем начать с маршрутизатора опорной сети (не такого, который вы можете найти у себя дома). От таких маршрутизаторов может требоваться скорость в uplink более 100 Гбит/с. 
Администратору может понадобиться создать черный список IP-адресов, чтобы заблокировать им доступ в сеть. 
Это означает, что каждый раз, когда маршрутизатор получает пакет на скорости более 100 Гбит/с, 
он должен обращаться к своей памяти и выполнять в лучшем случае логарифмический поиск (O(log(n))), 
чтобы проверить, заблокирован ли IP-адрес, учитывая, что большинство IP-адресов не заблокированы и что поиск не даст результатов для большинства пакетов. 
В этом случае фильтр Блума может быть реализован как раз перед доступом к памяти, чтобы гарантировать, что большинству пакетов не нужно дожидаться поиска IP-адреса для отправки в сеть.



## Снижение вероятности коллизий
1. Увеличить размер массива.  
При увеличении размера массива, вероятность коллизий уменьшается. Вероятность ложного срабатывания в фильтре Блума: $(1-e^(m/n))$.  
Где m - количество элементов, которые предполагается внести в фильтр, а n - размер фильтра.

2. Увеличить количество хэшь-функций.  
Если мы используем новую k хэшь-функций, вероятность ложного срабатывания будет: $(1-e^(mk/n))^k$, что означает, что оптимальное количество хэшь-функций: $(n/m)*ln(2)$
